--- libarchive-3.3.3/libarchive/archive_read_support_format_7zip.c
+++ libarchive-nenuzhnix/libarchive/archive_read_support_format_7zip.c
@@ -1197,9 +1197,10 @@
 #endif
 	case _7Z_DEFLATE:
 #ifdef HAVE_ZLIB_H
-		if (zip->stream_valid)
-			r = inflateReset(&(zip->stream));
-		else
+		if (zip->stream_valid) {
+			inflateReset(&(zip->stream));
+			r = Z_OK;
+		} else
 			r = inflateInit2(&(zip->stream),
 			    -15 /* Don't check for zlib header */);
 		if (r != Z_OK) {
--- /dev/null
+++ libarchive-nenuzhnix/libarchive/archive_read_support_format_7zip.c.orig
@@ -0,0 +1,3873 @@
+/*-
+ * Copyright (c) 2011 Michihiro NAKAJIMA
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "archive_platform.h"
+__FBSDID("$FreeBSD$");
+
+#ifdef HAVE_ERRNO_H
+#include <errno.h>
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_BZLIB_H
+#include <bzlib.h>
+#endif
+#ifdef HAVE_LZMA_H
+#include <lzma.h>
+#endif
+#ifdef HAVE_ZLIB_H
+#include <zlib.h>
+#endif
+
+#include "archive.h"
+#include "archive_entry.h"
+#include "archive_entry_locale.h"
+#include "archive_ppmd7_private.h"
+#include "archive_private.h"
+#include "archive_read_private.h"
+#include "archive_endian.h"
+
+#ifndef HAVE_ZLIB_H
+#include "archive_crc32.h"
+#endif
+
+#define _7ZIP_SIGNATURE	"7z\xBC\xAF\x27\x1C"
+#define SFX_MIN_ADDR	0x27000
+#define SFX_MAX_ADDR	0x60000
+
+
+/*
+ * Codec ID
+ */
+#define _7Z_COPY	0
+#define _7Z_LZMA	0x030101
+#define _7Z_LZMA2	0x21
+#define _7Z_DEFLATE	0x040108
+#define _7Z_BZ2		0x040202
+#define _7Z_PPMD	0x030401
+#define _7Z_DELTA	0x03
+#define _7Z_CRYPTO_MAIN_ZIP			0x06F10101 /* Main Zip crypto algo */
+#define _7Z_CRYPTO_RAR_29			0x06F10303 /* Rar29 AES-128 + (modified SHA-1) */
+#define _7Z_CRYPTO_AES_256_SHA_256	0x06F10701 /* AES-256 + SHA-256 */
+
+
+#define _7Z_X86		0x03030103
+#define _7Z_X86_BCJ2	0x0303011B
+#define _7Z_POWERPC	0x03030205
+#define _7Z_IA64	0x03030401
+#define _7Z_ARM		0x03030501
+#define _7Z_ARMTHUMB	0x03030701
+#define _7Z_SPARC	0x03030805
+
+/*
+ * 7-Zip header property IDs.
+ */
+#define kEnd			0x00
+#define kHeader			0x01
+#define kArchiveProperties	0x02
+#define kAdditionalStreamsInfo	0x03
+#define kMainStreamsInfo	0x04
+#define kFilesInfo		0x05
+#define kPackInfo		0x06
+#define kUnPackInfo		0x07
+#define kSubStreamsInfo		0x08
+#define kSize			0x09
+#define kCRC			0x0A
+#define kFolder			0x0B
+#define kCodersUnPackSize	0x0C
+#define kNumUnPackStream	0x0D
+#define kEmptyStream		0x0E
+#define kEmptyFile		0x0F
+#define kAnti			0x10
+#define kName			0x11
+#define kCTime			0x12
+#define kATime			0x13
+#define kMTime			0x14
+#define kAttributes		0x15
+#define kEncodedHeader		0x17
+#define kDummy			0x19
+
+struct _7z_digests {
+	unsigned char	*defineds;
+	uint32_t	*digests;
+};
+
+
+struct _7z_folder {
+	uint64_t		 numCoders;
+	struct _7z_coder {
+		unsigned long	 codec;
+		uint64_t	 numInStreams;
+		uint64_t	 numOutStreams;
+		uint64_t	 propertiesSize;
+		unsigned char	*properties;
+	} *coders;
+	uint64_t		 numBindPairs;
+	struct {
+		uint64_t	 inIndex;
+		uint64_t	 outIndex;
+	} *bindPairs;
+	uint64_t		 numPackedStreams;
+	uint64_t		*packedStreams;
+	uint64_t		 numInStreams;
+	uint64_t		 numOutStreams;
+	uint64_t		*unPackSize;
+	unsigned char		 digest_defined;
+	uint32_t		 digest;
+	uint64_t		 numUnpackStreams;
+	uint32_t		 packIndex;
+	/* Unoperated bytes. */
+	uint64_t		 skipped_bytes;
+};
+
+struct _7z_coders_info {
+	uint64_t		 numFolders;
+	struct _7z_folder	*folders;
+	uint64_t		 dataStreamIndex;
+};
+
+struct _7z_pack_info {
+	uint64_t		 pos;
+	uint64_t		 numPackStreams;
+	uint64_t		*sizes;
+	struct _7z_digests	 digest;
+	/* Calculated from pos and numPackStreams. */
+	uint64_t		*positions;
+};
+
+struct _7z_substream_info {
+	size_t			 unpack_streams;
+	uint64_t		*unpackSizes;
+	unsigned char		*digestsDefined;
+	uint32_t		*digests;
+};
+
+struct _7z_stream_info {
+	struct _7z_pack_info	 pi;
+	struct _7z_coders_info	 ci;
+	struct _7z_substream_info ss;
+};
+
+struct _7z_header_info {
+	uint64_t		 dataIndex;
+
+	unsigned char		*emptyStreamBools;
+	unsigned char		*emptyFileBools;
+	unsigned char		*antiBools;
+	unsigned char		*attrBools;
+};
+
+struct _7zip_entry {
+	size_t			 name_len;
+	unsigned char		*utf16name;
+#if defined(_WIN32) && !defined(__CYGWIN__) && defined(_DEBUG)
+	const wchar_t		*wname;
+#endif
+	uint32_t		 folderIndex;
+	uint32_t		 ssIndex;
+	unsigned		 flg;
+#define MTIME_IS_SET	(1<<0)
+#define ATIME_IS_SET	(1<<1)
+#define CTIME_IS_SET	(1<<2)
+#define CRC32_IS_SET	(1<<3)
+#define HAS_STREAM	(1<<4)
+
+	time_t			 mtime;
+	time_t			 atime;
+	time_t			 ctime;
+	long			 mtime_ns;
+	long			 atime_ns;
+	long			 ctime_ns;
+	uint32_t		 mode;
+	uint32_t		 attr;
+};
+
+struct _7zip {
+	/* Structural information about the archive. */
+	struct _7z_stream_info	 si;
+
+	int			 header_is_being_read;
+	int			 header_is_encoded;
+	uint64_t		 header_bytes_remaining;
+	unsigned long		 header_crc32;
+	/* Header offset to check that reading points of the file contents
+	 * will not exceed the header. */
+	uint64_t		 header_offset;
+	/* Base offset of the archive file for a seek in case reading SFX. */
+	uint64_t		 seek_base;
+
+	/* List of entries */
+	size_t			 entries_remaining;
+	uint64_t		 numFiles;
+	struct _7zip_entry	*entries;
+	struct _7zip_entry	*entry;
+	unsigned char		*entry_names;
+
+	/* entry_bytes_remaining is the number of bytes we expect. */
+	int64_t			 entry_offset;
+	uint64_t		 entry_bytes_remaining;
+
+	/* Running CRC32 of the decompressed data */
+	unsigned long		 entry_crc32;
+
+	/* Flags to mark progress of decompression. */
+	char			 end_of_entry;
+
+	/* Uncompressed buffer control.  */
+#define UBUFF_SIZE	(64 * 1024)
+	unsigned char 		*uncompressed_buffer;
+	unsigned char 		*uncompressed_buffer_pointer;
+	size_t 			 uncompressed_buffer_size;
+	size_t			 uncompressed_buffer_bytes_remaining;
+
+	/* Offset of the compressed data. */
+	int64_t			 stream_offset;
+
+	/*
+	 * Decompressing control data.
+	 */
+	unsigned		 folder_index;
+	uint64_t		 folder_outbytes_remaining;
+	unsigned		 pack_stream_index;
+	unsigned		 pack_stream_remaining;
+	uint64_t		 pack_stream_inbytes_remaining;
+	size_t			 pack_stream_bytes_unconsumed;
+
+	/* The codec information of a folder. */
+	unsigned long		 codec;
+	unsigned long		 codec2;
+
+	/*
+	 * Decompressor controllers.
+	 */
+	/* Decoding LZMA1 and LZMA2 data. */
+#ifdef HAVE_LZMA_H
+	lzma_stream		 lzstream;
+	int			 lzstream_valid;
+#endif
+	/* Decoding bzip2 data. */
+#if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)
+	bz_stream		 bzstream;
+	int			 bzstream_valid;
+#endif
+	/* Decoding deflate data. */
+#ifdef HAVE_ZLIB_H
+	z_stream		 stream;
+	int			 stream_valid;
+#endif
+	/* Decoding PPMd data. */
+	int			 ppmd7_stat;
+	CPpmd7			 ppmd7_context;
+	CPpmd7z_RangeDec	 range_dec;
+	IByteIn			 bytein;
+	struct {
+		const unsigned char	*next_in;
+		int64_t			 avail_in;
+		int64_t			 total_in;
+		unsigned char		*next_out;
+		int64_t			 avail_out;
+		int64_t			 total_out;
+		int			 overconsumed;
+	} ppstream;
+	int			 ppmd7_valid;
+
+	/* Decoding BCJ and BCJ2 data. */
+	uint32_t		 bcj_state;
+	size_t			 odd_bcj_size;
+	unsigned char		 odd_bcj[4];
+	/* Decoding BCJ data. */
+	size_t			 bcj_prevPosT;
+	uint32_t		 bcj_prevMask;
+	uint32_t		 bcj_ip;
+
+	/* Decoding BCJ2 data. */
+	size_t			 main_stream_bytes_remaining;
+	unsigned char		*sub_stream_buff[3];
+	size_t			 sub_stream_size[3];
+	size_t			 sub_stream_bytes_remaining[3];
+	unsigned char		*tmp_stream_buff;
+	size_t			 tmp_stream_buff_size;
+	size_t			 tmp_stream_bytes_avail;
+	size_t			 tmp_stream_bytes_remaining;
+#ifdef _LZMA_PROB32
+#define CProb uint32_t
+#else
+#define CProb uint16_t
+#endif
+	CProb			 bcj2_p[256 + 2];
+	uint8_t			 bcj2_prevByte;
+	uint32_t		 bcj2_range;
+	uint32_t		 bcj2_code;
+	uint64_t		 bcj2_outPos;
+
+	/* Filename character-set conversion data. */
+	struct archive_string_conv *sconv;
+
+	char			 format_name[64];
+
+	/* Custom value that is non-zero if this archive contains encrypted entries. */
+	int			 has_encrypted_entries;
+};
+
+/* Maximum entry size. This limitation prevents reading intentional
+ * corrupted 7-zip files on assuming there are not so many entries in
+ * the files. */
+#define UMAX_ENTRY	ARCHIVE_LITERAL_ULL(100000000)
+
+static int	archive_read_format_7zip_has_encrypted_entries(struct archive_read *);
+static int	archive_read_support_format_7zip_capabilities(struct archive_read *a);
+static int	archive_read_format_7zip_bid(struct archive_read *, int);
+static int	archive_read_format_7zip_cleanup(struct archive_read *);
+static int	archive_read_format_7zip_read_data(struct archive_read *,
+		    const void **, size_t *, int64_t *);
+static int	archive_read_format_7zip_read_data_skip(struct archive_read *);
+static int	archive_read_format_7zip_read_header(struct archive_read *,
+		    struct archive_entry *);
+static int	check_7zip_header_in_sfx(const char *);
+static unsigned long decode_codec_id(const unsigned char *, size_t);
+static int	decode_encoded_header_info(struct archive_read *,
+		    struct _7z_stream_info *);
+static int	decompress(struct archive_read *, struct _7zip *,
+		    void *, size_t *, const void *, size_t *);
+static ssize_t	extract_pack_stream(struct archive_read *, size_t);
+static void	fileTimeToUtc(uint64_t, time_t *, long *);
+static uint64_t folder_uncompressed_size(struct _7z_folder *);
+static void	free_CodersInfo(struct _7z_coders_info *);
+static void	free_Digest(struct _7z_digests *);
+static void	free_Folder(struct _7z_folder *);
+static void	free_Header(struct _7z_header_info *);
+static void	free_PackInfo(struct _7z_pack_info *);
+static void	free_StreamsInfo(struct _7z_stream_info *);
+static void	free_SubStreamsInfo(struct _7z_substream_info *);
+static int	free_decompression(struct archive_read *, struct _7zip *);
+static ssize_t	get_uncompressed_data(struct archive_read *, const void **,
+		    size_t, size_t);
+static const unsigned char * header_bytes(struct archive_read *, size_t);
+static int	init_decompression(struct archive_read *, struct _7zip *,
+		    const struct _7z_coder *, const struct _7z_coder *);
+static int	parse_7zip_uint64(struct archive_read *, uint64_t *);
+static int	read_Bools(struct archive_read *, unsigned char *, size_t);
+static int	read_CodersInfo(struct archive_read *,
+		    struct _7z_coders_info *);
+static int	read_Digests(struct archive_read *, struct _7z_digests *,
+		    size_t);
+static int	read_Folder(struct archive_read *, struct _7z_folder *);
+static int	read_Header(struct archive_read *, struct _7z_header_info *,
+		    int);
+static int	read_PackInfo(struct archive_read *, struct _7z_pack_info *);
+static int	read_StreamsInfo(struct archive_read *,
+		    struct _7z_stream_info *);
+static int	read_SubStreamsInfo(struct archive_read *,
+		    struct _7z_substream_info *, struct _7z_folder *, size_t);
+static int	read_Times(struct archive_read *, struct _7z_header_info *,
+		    int);
+static void	read_consume(struct archive_read *);
+static ssize_t	read_stream(struct archive_read *, const void **, size_t,
+		    size_t);
+static int	seek_pack(struct archive_read *);
+static int64_t	skip_stream(struct archive_read *, size_t);
+static int	skip_sfx(struct archive_read *, ssize_t);
+static int	slurp_central_directory(struct archive_read *, struct _7zip *,
+		    struct _7z_header_info *);
+static int	setup_decode_folder(struct archive_read *, struct _7z_folder *,
+		    int);
+static void	x86_Init(struct _7zip *);
+static size_t	x86_Convert(struct _7zip *, uint8_t *, size_t);
+static ssize_t		Bcj2_Decode(struct _7zip *, uint8_t *, size_t);
+
+
+int
+archive_read_support_format_7zip(struct archive *_a)
+{
+	struct archive_read *a = (struct archive_read *)_a;
+	struct _7zip *zip;
+	int r;
+
+	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
+	    ARCHIVE_STATE_NEW, "archive_read_support_format_7zip");
+
+	zip = calloc(1, sizeof(*zip));
+	if (zip == NULL) {
+		archive_set_error(&a->archive, ENOMEM,
+		    "Can't allocate 7zip data");
+		return (ARCHIVE_FATAL);
+	}
+
+	/*
+	 * Until enough data has been read, we cannot tell about
+	 * any encrypted entries yet.
+	 */
+	zip->has_encrypted_entries = ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW;
+
+
+	r = __archive_read_register_format(a,
+	    zip,
+	    "7zip",
+	    archive_read_format_7zip_bid,
+	    NULL,
+	    archive_read_format_7zip_read_header,
+	    archive_read_format_7zip_read_data,
+	    archive_read_format_7zip_read_data_skip,
+	    NULL,
+	    archive_read_format_7zip_cleanup,
+	    archive_read_support_format_7zip_capabilities,
+	    archive_read_format_7zip_has_encrypted_entries);
+
+	if (r != ARCHIVE_OK)
+		free(zip);
+	return (ARCHIVE_OK);
+}
+
+static int
+archive_read_support_format_7zip_capabilities(struct archive_read * a)
+{
+	(void)a; /* UNUSED */
+	return (ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_DATA |
+			ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_METADATA);
+}
+
+
+static int
+archive_read_format_7zip_has_encrypted_entries(struct archive_read *_a)
+{
+	if (_a && _a->format) {
+		struct _7zip * zip = (struct _7zip *)_a->format->data;
+		if (zip) {
+			return zip->has_encrypted_entries;
+		}
+	}
+	return ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW;
+}
+
+static int
+archive_read_format_7zip_bid(struct archive_read *a, int best_bid)
+{
+	const char *p;
+
+	/* If someone has already bid more than 32, then avoid
+	   trashing the look-ahead buffers with a seek. */
+	if (best_bid > 32)
+		return (-1);
+
+	if ((p = __archive_read_ahead(a, 6, NULL)) == NULL)
+		return (0);
+
+	/* If first six bytes are the 7-Zip signature,
+	 * return the bid right now. */
+	if (memcmp(p, _7ZIP_SIGNATURE, 6) == 0)
+		return (48);
+
+	/*
+	 * It may a 7-Zip SFX archive file. If first two bytes are
+	 * 'M' and 'Z' available on Windows or first four bytes are
+	 * "\x7F\x45LF" available on posix like system, seek the 7-Zip
+	 * signature. Although we will perform a seek when reading
+	 * a header, what we do not use __archive_read_seek() here is
+	 * due to a bidding performance.
+	 */
+	if ((p[0] == 'M' && p[1] == 'Z') || memcmp(p, "\x7F\x45LF", 4) == 0) {
+		ssize_t offset = SFX_MIN_ADDR;
+		ssize_t window = 4096;
+		ssize_t bytes_avail;
+		while (offset + window <= (SFX_MAX_ADDR)) {
+			const char *buff = __archive_read_ahead(a,
+					offset + window, &bytes_avail);
+			if (buff == NULL) {
+				/* Remaining bytes are less than window. */
+				window >>= 1;
+				if (window < 0x40)
+					return (0);
+				continue;
+			}
+			p = buff + offset;
+			while (p + 32 < buff + bytes_avail) {
+				int step = check_7zip_header_in_sfx(p);
+				if (step == 0)
+					return (48);
+				p += step;
+			}
+			offset = p - buff;
+		}
+	}
+	return (0);
+}
+
+static int
+check_7zip_header_in_sfx(const char *p)
+{
+	switch ((unsigned char)p[5]) {
+	case 0x1C:
+		if (memcmp(p, _7ZIP_SIGNATURE, 6) != 0)
+			return (6);
+		/*
+		 * Test the CRC because its extraction code has 7-Zip
+		 * Magic Code, so we should do this in order not to
+		 * make a mis-detection.
+		 */
+		if (crc32(0, (const unsigned char *)p + 12, 20)
+			!= archive_le32dec(p + 8))
+			return (6);
+		/* Hit the header! */
+		return (0);
+	case 0x37: return (5);
+	case 0x7A: return (4);
+	case 0xBC: return (3);
+	case 0xAF: return (2);
+	case 0x27: return (1);
+	default: return (6);
+	}
+}
+
+static int
+skip_sfx(struct archive_read *a, ssize_t bytes_avail)
+{
+	const void *h;
+	const char *p, *q;
+	size_t skip, offset;
+	ssize_t bytes, window;
+
+	/*
+	 * If bytes_avail > SFX_MIN_ADDR we do not have to call
+	 * __archive_read_seek() at this time since we have
+	 * already had enough data.
+	 */
+	if (bytes_avail > SFX_MIN_ADDR)
+		__archive_read_consume(a, SFX_MIN_ADDR);
+	else if (__archive_read_seek(a, SFX_MIN_ADDR, SEEK_SET) < 0)
+		return (ARCHIVE_FATAL);
+
+	offset = 0;
+	window = 1;
+	while (offset + window <= SFX_MAX_ADDR - SFX_MIN_ADDR) {
+		h = __archive_read_ahead(a, window, &bytes);
+		if (h == NULL) {
+			/* Remaining bytes are less than window. */
+			window >>= 1;
+			if (window < 0x40)
+				goto fatal;
+			continue;
+		}
+		if (bytes < 6) {
+			/* This case might happen when window == 1. */
+			window = 4096;
+			continue;
+		}
+		p = (const char *)h;
+		q = p + bytes;
+
+		/*
+		 * Scan ahead until we find something that looks
+		 * like the 7-Zip header.
+		 */
+		while (p + 32 < q) {
+			int step = check_7zip_header_in_sfx(p);
+			if (step == 0) {
+				struct _7zip *zip =
+				    (struct _7zip *)a->format->data;
+				skip = p - (const char *)h;
+				__archive_read_consume(a, skip);
+				zip->seek_base = SFX_MIN_ADDR + offset + skip;
+				return (ARCHIVE_OK);
+			}
+			p += step;
+		}
+		skip = p - (const char *)h;
+		__archive_read_consume(a, skip);
+		offset += skip;
+		if (window == 1)
+			window = 4096;
+	}
+fatal:
+	archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+	    "Couldn't find out 7-Zip header");
+	return (ARCHIVE_FATAL);
+}
+
+static int
+archive_read_format_7zip_read_header(struct archive_read *a,
+	struct archive_entry *entry)
+{
+	struct _7zip *zip = (struct _7zip *)a->format->data;
+	struct _7zip_entry *zip_entry;
+	int r, ret = ARCHIVE_OK;
+	struct _7z_folder *folder = 0;
+	uint64_t fidx = 0;
+
+	/*
+	 * It should be sufficient to call archive_read_next_header() for
+	 * a reader to determine if an entry is encrypted or not. If the
+	 * encryption of an entry is only detectable when calling
+	 * archive_read_data(), so be it. We'll do the same check there
+	 * as well.
+	 */
+	if (zip->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {
+		zip->has_encrypted_entries = 0;
+	}
+
+	a->archive.archive_format = ARCHIVE_FORMAT_7ZIP;
+	if (a->archive.archive_format_name == NULL)
+		a->archive.archive_format_name = "7-Zip";
+
+	if (zip->entries == NULL) {
+		struct _7z_header_info header;
+
+		memset(&header, 0, sizeof(header));
+		r = slurp_central_directory(a, zip, &header);
+		free_Header(&header);
+		if (r != ARCHIVE_OK)
+			return (r);
+		zip->entries_remaining = (size_t)zip->numFiles;
+		zip->entry = zip->entries;
+	} else {
+		++zip->entry;
+	}
+	zip_entry = zip->entry;
+
+	if (zip->entries_remaining <= 0 || zip_entry == NULL)
+		return ARCHIVE_EOF;
+	--zip->entries_remaining;
+
+	zip->entry_offset = 0;
+	zip->end_of_entry = 0;
+	zip->entry_crc32 = crc32(0, NULL, 0);
+
+	/* Setup a string conversion for a filename. */
+	if (zip->sconv == NULL) {
+		zip->sconv = archive_string_conversion_from_charset(
+		    &a->archive, "UTF-16LE", 1);
+		if (zip->sconv == NULL)
+			return (ARCHIVE_FATAL);
+	}
+
+	/* Figure out if the entry is encrypted by looking at the folder
+	   that is associated to the current 7zip entry. If the folder
+	   has a coder with a _7Z_CRYPTO codec then the folder is encrypted.
+	   Hence the entry must also be encrypted. */
+	if (zip_entry && zip_entry->folderIndex < zip->si.ci.numFolders) {
+		folder = &(zip->si.ci.folders[zip_entry->folderIndex]);
+		for (fidx=0; folder && fidx<folder->numCoders; fidx++) {
+			switch(folder->coders[fidx].codec) {
+				case _7Z_CRYPTO_MAIN_ZIP:
+				case _7Z_CRYPTO_RAR_29:
+				case _7Z_CRYPTO_AES_256_SHA_256: {
+					archive_entry_set_is_data_encrypted(entry, 1);
+					zip->has_encrypted_entries = 1;
+					break;
+				}
+			}
+		}
+	}
+
+	/* Now that we've checked for encryption, if there were still no
+	 * encrypted entries found we can say for sure that there are none.
+	 */
+	if (zip->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {
+		zip->has_encrypted_entries = 0;
+	}
+
+	if (archive_entry_copy_pathname_l(entry,
+	    (const char *)zip_entry->utf16name,
+	    zip_entry->name_len, zip->sconv) != 0) {
+		if (errno == ENOMEM) {
+			archive_set_error(&a->archive, ENOMEM,
+			    "Can't allocate memory for Pathname");
+			return (ARCHIVE_FATAL);
+		}
+		archive_set_error(&a->archive,
+		    ARCHIVE_ERRNO_FILE_FORMAT,
+		    "Pathname cannot be converted "
+		    "from %s to current locale.",
+		    archive_string_conversion_charset_name(zip->sconv));
+		ret = ARCHIVE_WARN;
+	}
+
+	/* Populate some additional entry fields: */
+	archive_entry_set_mode(entry, zip_entry->mode);
+	if (zip_entry->flg & MTIME_IS_SET)
+		archive_entry_set_mtime(entry, zip_entry->mtime,
+			zip_entry->mtime_ns);
+	if (zip_entry->flg & CTIME_IS_SET)
+		archive_entry_set_ctime(entry, zip_entry->ctime,
+		    zip_entry->ctime_ns);
+	if (zip_entry->flg & ATIME_IS_SET)
+		archive_entry_set_atime(entry, zip_entry->atime,
+		    zip_entry->atime_ns);
+	if (zip_entry->ssIndex != (uint32_t)-1) {
+		zip->entry_bytes_remaining =
+		    zip->si.ss.unpackSizes[zip_entry->ssIndex];
+		archive_entry_set_size(entry, zip->entry_bytes_remaining);
+	} else {
+		zip->entry_bytes_remaining = 0;
+		archive_entry_set_size(entry, 0);
+	}
+
+	/* If there's no body, force read_data() to return EOF immediately. */
+	if (zip->entry_bytes_remaining < 1)
+		zip->end_of_entry = 1;
+
+	if ((zip_entry->mode & AE_IFMT) == AE_IFLNK) {
+		unsigned char *symname = NULL;
+		size_t symsize = 0;
+
+		/*
+		 * Symbolic-name is recorded as its contents. We have to
+		 * read the contents at this time.
+		 */
+		while (zip->entry_bytes_remaining > 0) {
+			const void *buff;
+			unsigned char *mem;
+			size_t size;
+			int64_t offset;
+
+			r = archive_read_format_7zip_read_data(a, &buff,
+				&size, &offset);
+			if (r < ARCHIVE_WARN) {
+				free(symname);
+				return (r);
+			}
+			mem = realloc(symname, symsize + size + 1);
+			if (mem == NULL) {
+				free(symname);
+				archive_set_error(&a->archive, ENOMEM,
+				    "Can't allocate memory for Symname");
+				return (ARCHIVE_FATAL);
+			}
+			symname = mem;
+			memcpy(symname+symsize, buff, size);
+			symsize += size;
+		}
+		if (symsize == 0) {
+			/* If there is no symname, handle it as a regular
+			 * file. */
+			zip_entry->mode &= ~AE_IFMT;
+			zip_entry->mode |= AE_IFREG;
+			archive_entry_set_mode(entry, zip_entry->mode);
+		} else {
+			symname[symsize] = '\0';
+			archive_entry_copy_symlink(entry,
+			    (const char *)symname);
+		}
+		free(symname);
+		archive_entry_set_size(entry, 0);
+	}
+
+	/* Set up a more descriptive format name. */
+	sprintf(zip->format_name, "7-Zip");
+	a->archive.archive_format_name = zip->format_name;
+
+	return (ret);
+}
+
+static int
+archive_read_format_7zip_read_data(struct archive_read *a,
+    const void **buff, size_t *size, int64_t *offset)
+{
+	struct _7zip *zip;
+	ssize_t bytes;
+	int ret = ARCHIVE_OK;
+
+	zip = (struct _7zip *)(a->format->data);
+
+	if (zip->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {
+		zip->has_encrypted_entries = 0;
+	}
+
+	if (zip->pack_stream_bytes_unconsumed)
+		read_consume(a);
+
+	*offset = zip->entry_offset;
+	*size = 0;
+	*buff = NULL;
+	/*
+	 * If we hit end-of-entry last time, clean up and return
+	 * ARCHIVE_EOF this time.
+	 */
+	if (zip->end_of_entry)
+		return (ARCHIVE_EOF);
+
+	bytes = read_stream(a, buff,
+		(size_t)zip->entry_bytes_remaining, 0);
+	if (bytes < 0)
+		return ((int)bytes);
+	if (bytes == 0) {
+		archive_set_error(&a->archive,
+		    ARCHIVE_ERRNO_FILE_FORMAT,
+		    "Truncated 7-Zip file body");
+		return (ARCHIVE_FATAL);
+	}
+	zip->entry_bytes_remaining -= bytes;
+	if (zip->entry_bytes_remaining == 0)
+		zip->end_of_entry = 1;
+
+	/* Update checksum */
+	if ((zip->entry->flg & CRC32_IS_SET) && bytes)
+		zip->entry_crc32 = crc32(zip->entry_crc32, *buff,
+		    (unsigned)bytes);
+
+	/* If we hit the end, swallow any end-of-data marker. */
+	if (zip->end_of_entry) {
+		/* Check computed CRC against file contents. */
+		if ((zip->entry->flg & CRC32_IS_SET) &&
+			zip->si.ss.digests[zip->entry->ssIndex] !=
+		    zip->entry_crc32) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "7-Zip bad CRC: 0x%lx should be 0x%lx",
+			    (unsigned long)zip->entry_crc32,
+			    (unsigned long)zip->si.ss.digests[
+			    		zip->entry->ssIndex]);
+			ret = ARCHIVE_WARN;
+		}
+	}
+
+	*size = bytes;
+	*offset = zip->entry_offset;
+	zip->entry_offset += bytes;
+
+	return (ret);
+}
+
+static int
+archive_read_format_7zip_read_data_skip(struct archive_read *a)
+{
+	struct _7zip *zip;
+	int64_t bytes_skipped;
+
+	zip = (struct _7zip *)(a->format->data);
+
+	if (zip->pack_stream_bytes_unconsumed)
+		read_consume(a);
+
+	/* If we've already read to end of data, we're done. */
+	if (zip->end_of_entry)
+		return (ARCHIVE_OK);
+
+	/*
+	 * If the length is at the beginning, we can skip the
+	 * compressed data much more quickly.
+	 */
+	bytes_skipped = skip_stream(a, (size_t)zip->entry_bytes_remaining);
+	if (bytes_skipped < 0)
+		return (ARCHIVE_FATAL);
+	zip->entry_bytes_remaining = 0;
+
+	/* This entry is finished and done. */
+	zip->end_of_entry = 1;
+	return (ARCHIVE_OK);
+}
+
+static int
+archive_read_format_7zip_cleanup(struct archive_read *a)
+{
+	struct _7zip *zip;
+
+	zip = (struct _7zip *)(a->format->data);
+	free_StreamsInfo(&(zip->si));
+	free(zip->entries);
+	free(zip->entry_names);
+	free_decompression(a, zip);
+	free(zip->uncompressed_buffer);
+	free(zip->sub_stream_buff[0]);
+	free(zip->sub_stream_buff[1]);
+	free(zip->sub_stream_buff[2]);
+	free(zip->tmp_stream_buff);
+	free(zip);
+	(a->format->data) = NULL;
+	return (ARCHIVE_OK);
+}
+
+static void
+read_consume(struct archive_read *a)
+{
+	struct _7zip *zip = (struct _7zip *)a->format->data;
+
+	if (zip->pack_stream_bytes_unconsumed) {
+		__archive_read_consume(a, zip->pack_stream_bytes_unconsumed);
+		zip->stream_offset += zip->pack_stream_bytes_unconsumed;
+		zip->pack_stream_bytes_unconsumed = 0;
+	}
+}
+
+#ifdef HAVE_LZMA_H
+
+/*
+ * Set an error code and choose an error message for liblzma.
+ */
+static void
+set_error(struct archive_read *a, int ret)
+{
+
+	switch (ret) {
+	case LZMA_STREAM_END: /* Found end of stream. */
+	case LZMA_OK: /* Decompressor made some progress. */
+		break;
+	case LZMA_MEM_ERROR:
+		archive_set_error(&a->archive, ENOMEM,
+		    "Lzma library error: Cannot allocate memory");
+		break;
+	case LZMA_MEMLIMIT_ERROR:
+		archive_set_error(&a->archive, ENOMEM,
+		    "Lzma library error: Out of memory");
+		break;
+	case LZMA_FORMAT_ERROR:
+		archive_set_error(&a->archive,
+		    ARCHIVE_ERRNO_MISC,
+		    "Lzma library error: format not recognized");
+		break;
+	case LZMA_OPTIONS_ERROR:
+		archive_set_error(&a->archive,
+		    ARCHIVE_ERRNO_MISC,
+		    "Lzma library error: Invalid options");
+		break;
+	case LZMA_DATA_ERROR:
+		archive_set_error(&a->archive,
+		    ARCHIVE_ERRNO_MISC,
+		    "Lzma library error: Corrupted input data");
+		break;
+	case LZMA_BUF_ERROR:
+		archive_set_error(&a->archive,
+		    ARCHIVE_ERRNO_MISC,
+		    "Lzma library error:  No progress is possible");
+		break;
+	default:
+		/* Return an error. */
+		archive_set_error(&a->archive,
+		    ARCHIVE_ERRNO_MISC,
+		    "Lzma decompression failed:  Unknown error");
+		break;
+	}
+}
+
+#endif
+
+static unsigned long
+decode_codec_id(const unsigned char *codecId, size_t id_size)
+{
+	unsigned i;
+	unsigned long id = 0;
+
+	for (i = 0; i < id_size; i++) {
+		id <<= 8;
+		id += codecId[i];
+	}
+	return (id);
+}
+
+static Byte
+ppmd_read(void *p)
+{
+	struct archive_read *a = ((IByteIn*)p)->a;
+	struct _7zip *zip = (struct _7zip *)(a->format->data);
+	Byte b;
+
+	if (zip->ppstream.avail_in == 0) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+		    "Truncated RAR file data");
+		zip->ppstream.overconsumed = 1;
+		return (0);
+	}
+	b = *zip->ppstream.next_in++;
+	zip->ppstream.avail_in--;
+	zip->ppstream.total_in++;
+	return (b);
+}
+
+static int
+init_decompression(struct archive_read *a, struct _7zip *zip,
+    const struct _7z_coder *coder1, const struct _7z_coder *coder2)
+{
+	int r;
+
+	zip->codec = coder1->codec;
+	zip->codec2 = -1;
+
+	switch (zip->codec) {
+	case _7Z_COPY:
+	case _7Z_BZ2:
+	case _7Z_DEFLATE:
+	case _7Z_PPMD:
+		if (coder2 != NULL) {
+			if (coder2->codec != _7Z_X86 &&
+			    coder2->codec != _7Z_X86_BCJ2) {
+				archive_set_error(&a->archive,
+				    ARCHIVE_ERRNO_MISC,
+				    "Unsupported filter %lx for %lx",
+				    coder2->codec, coder1->codec);
+				return (ARCHIVE_FAILED);
+			}
+			zip->codec2 = coder2->codec;
+			zip->bcj_state = 0;
+			if (coder2->codec == _7Z_X86)
+				x86_Init(zip);
+		}
+		break;
+	default:
+		break;
+	}
+
+	switch (zip->codec) {
+	case _7Z_COPY:
+		break;
+
+	case _7Z_LZMA: case _7Z_LZMA2:
+#ifdef HAVE_LZMA_H
+#if LZMA_VERSION_MAJOR >= 5
+/* Effectively disable the limiter. */
+#define LZMA_MEMLIMIT   UINT64_MAX
+#else
+/* NOTE: This needs to check memory size which running system has. */
+#define LZMA_MEMLIMIT   (1U << 30)
+#endif
+	{
+		lzma_options_delta delta_opt;
+		lzma_filter filters[LZMA_FILTERS_MAX], *ff;
+		int fi = 0;
+
+		if (zip->lzstream_valid) {
+			lzma_end(&(zip->lzstream));
+			zip->lzstream_valid = 0;
+		}
+
+		/*
+		 * NOTE: liblzma incompletely handle the BCJ+LZMA compressed
+		 * data made by 7-Zip because 7-Zip does not add End-Of-
+		 * Payload Marker(EOPM) at the end of LZMA compressed data,
+		 * and so liblzma cannot know the end of the compressed data
+		 * without EOPM. So consequently liblzma will not return last
+		 * three or four bytes of uncompressed data because
+		 * LZMA_FILTER_X86 filter does not handle input data if its
+		 * data size is less than five bytes. If liblzma detect EOPM
+		 * or know the uncompressed data size, liblzma will flush out
+		 * the remaining that three or four bytes of uncompressed
+		 * data. That is why we have to use our converting program
+		 * for BCJ+LZMA. If we were able to tell the uncompressed
+		 * size to liblzma when using lzma_raw_decoder() liblzma
+		 * could correctly deal with BCJ+LZMA. But unfortunately
+		 * there is no way to do that.
+		 * Discussion about this can be found at XZ Utils forum.
+		 */
+		if (coder2 != NULL) {
+			zip->codec2 = coder2->codec;
+
+			filters[fi].options = NULL;
+			switch (zip->codec2) {
+			case _7Z_X86:
+				if (zip->codec == _7Z_LZMA2) {
+					filters[fi].id = LZMA_FILTER_X86;
+					fi++;
+				} else
+					/* Use our filter. */
+					x86_Init(zip);
+				break;
+			case _7Z_X86_BCJ2:
+				/* Use our filter. */
+				zip->bcj_state = 0;
+				break;
+			case _7Z_DELTA:
+				filters[fi].id = LZMA_FILTER_DELTA;
+				memset(&delta_opt, 0, sizeof(delta_opt));
+				delta_opt.type = LZMA_DELTA_TYPE_BYTE;
+				delta_opt.dist = 1;
+				filters[fi].options = &delta_opt;
+				fi++;
+				break;
+			/* Following filters have not been tested yet. */
+			case _7Z_POWERPC:
+				filters[fi].id = LZMA_FILTER_POWERPC;
+				fi++;
+				break;
+			case _7Z_IA64:
+				filters[fi].id = LZMA_FILTER_IA64;
+				fi++;
+				break;
+			case _7Z_ARM:
+				filters[fi].id = LZMA_FILTER_ARM;
+				fi++;
+				break;
+			case _7Z_ARMTHUMB:
+				filters[fi].id = LZMA_FILTER_ARMTHUMB;
+				fi++;
+				break;
+			case _7Z_SPARC:
+				filters[fi].id = LZMA_FILTER_SPARC;
+				fi++;
+				break;
+			default:
+				archive_set_error(&a->archive,
+				    ARCHIVE_ERRNO_MISC,
+				    "Unexpected codec ID: %lX", zip->codec2);
+				return (ARCHIVE_FAILED);
+			}
+		}
+
+		if (zip->codec == _7Z_LZMA2)
+			filters[fi].id = LZMA_FILTER_LZMA2;
+		else
+			filters[fi].id = LZMA_FILTER_LZMA1;
+		filters[fi].options = NULL;
+		ff = &filters[fi];
+		r = lzma_properties_decode(&filters[fi], NULL,
+		    coder1->properties, (size_t)coder1->propertiesSize);
+		if (r != LZMA_OK) {
+			set_error(a, r);
+			return (ARCHIVE_FAILED);
+		}
+		fi++;
+
+		filters[fi].id = LZMA_VLI_UNKNOWN;
+		filters[fi].options = NULL;
+		r = lzma_raw_decoder(&(zip->lzstream), filters);
+		free(ff->options);
+		if (r != LZMA_OK) {
+			set_error(a, r);
+			return (ARCHIVE_FAILED);
+		}
+		zip->lzstream_valid = 1;
+		zip->lzstream.total_in = 0;
+		zip->lzstream.total_out = 0;
+		break;
+	}
+#else
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+		    "LZMA codec is unsupported");
+		return (ARCHIVE_FAILED);
+#endif
+	case _7Z_BZ2:
+#if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)
+		if (zip->bzstream_valid) {
+			BZ2_bzDecompressEnd(&(zip->bzstream));
+			zip->bzstream_valid = 0;
+		}
+		r = BZ2_bzDecompressInit(&(zip->bzstream), 0, 0);
+		if (r == BZ_MEM_ERROR)
+			r = BZ2_bzDecompressInit(&(zip->bzstream), 0, 1);
+		if (r != BZ_OK) {
+			int err = ARCHIVE_ERRNO_MISC;
+			const char *detail = NULL;
+			switch (r) {
+			case BZ_PARAM_ERROR:
+				detail = "invalid setup parameter";
+				break;
+			case BZ_MEM_ERROR:
+				err = ENOMEM;
+				detail = "out of memory";
+				break;
+			case BZ_CONFIG_ERROR:
+				detail = "mis-compiled library";
+				break;
+			}
+			archive_set_error(&a->archive, err,
+			    "Internal error initializing decompressor: %s",
+			    detail != NULL ? detail : "??");
+			zip->bzstream_valid = 0;
+			return (ARCHIVE_FAILED);
+		}
+		zip->bzstream_valid = 1;
+		zip->bzstream.total_in_lo32 = 0;
+		zip->bzstream.total_in_hi32 = 0;
+		zip->bzstream.total_out_lo32 = 0;
+		zip->bzstream.total_out_hi32 = 0;
+		break;
+#else
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+		    "BZ2 codec is unsupported");
+		return (ARCHIVE_FAILED);
+#endif
+	case _7Z_DEFLATE:
+#ifdef HAVE_ZLIB_H
+		if (zip->stream_valid)
+			r = inflateReset(&(zip->stream));
+		else
+			r = inflateInit2(&(zip->stream),
+			    -15 /* Don't check for zlib header */);
+		if (r != Z_OK) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "Couldn't initialize zlib stream.");
+			return (ARCHIVE_FAILED);
+		}
+		zip->stream_valid = 1;
+		zip->stream.total_in = 0;
+		zip->stream.total_out = 0;
+		break;
+#else
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+		    "DEFLATE codec is unsupported");
+		return (ARCHIVE_FAILED);
+#endif
+	case _7Z_PPMD:
+	{
+		unsigned order;
+		uint32_t msize;
+
+		if (zip->ppmd7_valid) {
+			__archive_ppmd7_functions.Ppmd7_Free(
+			    &zip->ppmd7_context);
+			zip->ppmd7_valid = 0;
+		}
+
+		if (coder1->propertiesSize < 5) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "Malformed PPMd parameter");
+			return (ARCHIVE_FAILED);
+		}
+		order = coder1->properties[0];
+		msize = archive_le32dec(&(coder1->properties[1]));
+		if (order < PPMD7_MIN_ORDER || order > PPMD7_MAX_ORDER ||
+		    msize < PPMD7_MIN_MEM_SIZE || msize > PPMD7_MAX_MEM_SIZE) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "Malformed PPMd parameter");
+			return (ARCHIVE_FAILED);
+		}
+		__archive_ppmd7_functions.Ppmd7_Construct(&zip->ppmd7_context);
+		r = __archive_ppmd7_functions.Ppmd7_Alloc(
+			&zip->ppmd7_context, msize);
+		if (r == 0) {
+			archive_set_error(&a->archive, ENOMEM,
+			    "Coludn't allocate memory for PPMd");
+			return (ARCHIVE_FATAL);
+		}
+		__archive_ppmd7_functions.Ppmd7_Init(
+			&zip->ppmd7_context, order);
+		__archive_ppmd7_functions.Ppmd7z_RangeDec_CreateVTable(
+			&zip->range_dec);
+		zip->ppmd7_valid = 1;
+		zip->ppmd7_stat = 0;
+		zip->ppstream.overconsumed = 0;
+		zip->ppstream.total_in = 0;
+		zip->ppstream.total_out = 0;
+		break;
+	}
+	case _7Z_X86:
+	case _7Z_X86_BCJ2:
+	case _7Z_POWERPC:
+	case _7Z_IA64:
+	case _7Z_ARM:
+	case _7Z_ARMTHUMB:
+	case _7Z_SPARC:
+	case _7Z_DELTA:
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+		    "Unexpected codec ID: %lX", zip->codec);
+		return (ARCHIVE_FAILED);
+	case _7Z_CRYPTO_MAIN_ZIP:
+	case _7Z_CRYPTO_RAR_29:
+	case _7Z_CRYPTO_AES_256_SHA_256:
+		if (a->entry) {
+			archive_entry_set_is_metadata_encrypted(a->entry, 1);
+			archive_entry_set_is_data_encrypted(a->entry, 1);
+			zip->has_encrypted_entries = 1;
+		}
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+		    "Crypto codec not supported yet (ID: 0x%lX)", zip->codec);
+		return (ARCHIVE_FAILED);
+	default:
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+		    "Unknown codec ID: %lX", zip->codec);
+		return (ARCHIVE_FAILED);
+	}
+
+	return (ARCHIVE_OK);
+}
+
+static int
+decompress(struct archive_read *a, struct _7zip *zip,
+    void *buff, size_t *outbytes, const void *b, size_t *used)
+{
+	const uint8_t *t_next_in;
+	uint8_t *t_next_out;
+	size_t o_avail_in, o_avail_out;
+	size_t t_avail_in, t_avail_out;
+	uint8_t *bcj2_next_out;
+	size_t bcj2_avail_out;
+	int r, ret = ARCHIVE_OK;
+
+	t_avail_in = o_avail_in = *used;
+	t_avail_out = o_avail_out = *outbytes;
+	t_next_in = b;
+	t_next_out = buff;
+
+	if (zip->codec != _7Z_LZMA2 && zip->codec2 == _7Z_X86) {
+		int i;
+
+		/* Do not copy out the BCJ remaining bytes when the output
+		 * buffer size is less than five bytes. */
+		if (o_avail_in != 0 && t_avail_out < 5 && zip->odd_bcj_size) {
+			*used = 0;
+			*outbytes = 0;
+			return (ret);
+		}
+		for (i = 0; zip->odd_bcj_size > 0 && t_avail_out; i++) {
+			*t_next_out++ = zip->odd_bcj[i];
+			t_avail_out--;
+			zip->odd_bcj_size--;
+		}
+		if (o_avail_in == 0 || t_avail_out == 0) {
+			*used = o_avail_in - t_avail_in;
+			*outbytes = o_avail_out - t_avail_out;
+			if (o_avail_in == 0)
+				ret = ARCHIVE_EOF;
+			return (ret);
+		}
+	}
+
+	bcj2_next_out = t_next_out;
+	bcj2_avail_out = t_avail_out;
+	if (zip->codec2 == _7Z_X86_BCJ2) {
+		/*
+		 * Decord a remaining decompressed main stream for BCJ2.
+		 */
+		if (zip->tmp_stream_bytes_remaining) {
+			ssize_t bytes;
+			size_t remaining = zip->tmp_stream_bytes_remaining;
+			bytes = Bcj2_Decode(zip, t_next_out, t_avail_out);
+			if (bytes < 0) {
+				archive_set_error(&(a->archive),
+				    ARCHIVE_ERRNO_MISC,
+				    "BCJ2 conversion Failed");
+				return (ARCHIVE_FAILED);
+			}
+			zip->main_stream_bytes_remaining -=
+			    remaining - zip->tmp_stream_bytes_remaining;
+			t_avail_out -= bytes;
+			if (o_avail_in == 0 || t_avail_out == 0) {
+				*used = 0;
+				*outbytes = o_avail_out - t_avail_out;
+				if (o_avail_in == 0 &&
+				    zip->tmp_stream_bytes_remaining)
+					ret = ARCHIVE_EOF;
+				return (ret);
+			}
+			t_next_out += bytes;
+			bcj2_next_out = t_next_out;
+			bcj2_avail_out = t_avail_out;
+		}
+		t_next_out = zip->tmp_stream_buff;
+		t_avail_out = zip->tmp_stream_buff_size;
+	}
+
+	switch (zip->codec) {
+	case _7Z_COPY:
+	{
+		size_t bytes =
+		    (t_avail_in > t_avail_out)?t_avail_out:t_avail_in;
+
+		memcpy(t_next_out, t_next_in, bytes);
+		t_avail_in -= bytes;
+		t_avail_out -= bytes;
+		if (o_avail_in == 0)
+			ret = ARCHIVE_EOF;
+		break;
+	}
+#ifdef HAVE_LZMA_H
+	case _7Z_LZMA: case _7Z_LZMA2:
+		zip->lzstream.next_in = t_next_in;
+		zip->lzstream.avail_in = t_avail_in;
+		zip->lzstream.next_out = t_next_out;
+		zip->lzstream.avail_out = t_avail_out;
+
+		r = lzma_code(&(zip->lzstream), LZMA_RUN);
+		switch (r) {
+		case LZMA_STREAM_END: /* Found end of stream. */
+			lzma_end(&(zip->lzstream));
+			zip->lzstream_valid = 0;
+			ret = ARCHIVE_EOF;
+			break;
+		case LZMA_OK: /* Decompressor made some progress. */
+			break;
+		default:
+			archive_set_error(&(a->archive),
+			    ARCHIVE_ERRNO_MISC,
+				"Decompression failed(%d)",
+			    r);
+			return (ARCHIVE_FAILED);
+		}
+		t_avail_in = zip->lzstream.avail_in;
+		t_avail_out = zip->lzstream.avail_out;
+		break;
+#endif
+#if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)
+	case _7Z_BZ2:
+		zip->bzstream.next_in = (char *)(uintptr_t)t_next_in;
+		zip->bzstream.avail_in = t_avail_in;
+		zip->bzstream.next_out = (char *)(uintptr_t)t_next_out;
+		zip->bzstream.avail_out = t_avail_out;
+		r = BZ2_bzDecompress(&(zip->bzstream));
+		switch (r) {
+		case BZ_STREAM_END: /* Found end of stream. */
+			switch (BZ2_bzDecompressEnd(&(zip->bzstream))) {
+			case BZ_OK:
+				break;
+			default:
+				archive_set_error(&(a->archive),
+				    ARCHIVE_ERRNO_MISC,
+				    "Failed to clean up decompressor");
+				return (ARCHIVE_FAILED);
+			}
+			zip->bzstream_valid = 0;
+			ret = ARCHIVE_EOF;
+			break;
+		case BZ_OK: /* Decompressor made some progress. */
+			break;
+		default:
+			archive_set_error(&(a->archive),
+			    ARCHIVE_ERRNO_MISC,
+			    "bzip decompression failed");
+			return (ARCHIVE_FAILED);
+		}
+		t_avail_in = zip->bzstream.avail_in;
+		t_avail_out = zip->bzstream.avail_out;
+		break;
+#endif
+#ifdef HAVE_ZLIB_H
+	case _7Z_DEFLATE:
+		zip->stream.next_in = (Bytef *)(uintptr_t)t_next_in;
+		zip->stream.avail_in = (uInt)t_avail_in;
+		zip->stream.next_out = t_next_out;
+		zip->stream.avail_out = (uInt)t_avail_out;
+		r = inflate(&(zip->stream), 0);
+		switch (r) {
+		case Z_STREAM_END: /* Found end of stream. */
+			ret = ARCHIVE_EOF;
+			break;
+		case Z_OK: /* Decompressor made some progress.*/
+			break;
+		default:
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "File decompression failed (%d)", r);
+			return (ARCHIVE_FAILED);
+		}
+		t_avail_in = zip->stream.avail_in;
+		t_avail_out = zip->stream.avail_out;
+		break;
+#endif
+	case _7Z_PPMD:
+	{
+		uint64_t flush_bytes;
+
+		if (!zip->ppmd7_valid || zip->ppmd7_stat < 0 ||
+		    t_avail_out <= 0) {
+			archive_set_error(&(a->archive),
+			    ARCHIVE_ERRNO_MISC,
+			    "Decompression internal error");
+			return (ARCHIVE_FAILED);
+		}
+		zip->ppstream.next_in = t_next_in;
+		zip->ppstream.avail_in = t_avail_in;
+		zip->ppstream.next_out = t_next_out;
+		zip->ppstream.avail_out = t_avail_out;
+		if (zip->ppmd7_stat == 0) {
+			zip->bytein.a = a;
+			zip->bytein.Read = &ppmd_read;
+			zip->range_dec.Stream = &zip->bytein;
+			r = __archive_ppmd7_functions.Ppmd7z_RangeDec_Init(
+				&(zip->range_dec));
+			if (r == 0) {
+				zip->ppmd7_stat = -1;
+				archive_set_error(&a->archive,
+				    ARCHIVE_ERRNO_MISC,
+				    "Failed to initialize PPMd range decorder");
+				return (ARCHIVE_FAILED);
+			}
+			if (zip->ppstream.overconsumed) {
+				zip->ppmd7_stat = -1;
+				return (ARCHIVE_FAILED);
+			}
+			zip->ppmd7_stat = 1;
+		}
+
+		if (t_avail_in == 0)
+			/* XXX Flush out remaining decoded data XXX */
+			flush_bytes = zip->folder_outbytes_remaining;
+		else
+			flush_bytes = 0;
+
+		do {
+			int sym;
+
+			sym = __archive_ppmd7_functions.Ppmd7_DecodeSymbol(
+				&(zip->ppmd7_context), &(zip->range_dec.p));
+			if (sym < 0) {
+				zip->ppmd7_stat = -1;
+				archive_set_error(&a->archive,
+				    ARCHIVE_ERRNO_FILE_FORMAT,
+				    "Failed to decode PPMd");
+				return (ARCHIVE_FAILED);
+			}
+			if (zip->ppstream.overconsumed) {
+				zip->ppmd7_stat = -1;
+				return (ARCHIVE_FAILED);
+			}
+			*zip->ppstream.next_out++ = (unsigned char)sym;
+			zip->ppstream.avail_out--;
+			zip->ppstream.total_out++;
+			if (flush_bytes)
+				flush_bytes--;
+		} while (zip->ppstream.avail_out &&
+			(zip->ppstream.avail_in || flush_bytes));
+
+		t_avail_in = (size_t)zip->ppstream.avail_in;
+		t_avail_out = (size_t)zip->ppstream.avail_out;
+		break;
+	}
+	default:
+		archive_set_error(&(a->archive), ARCHIVE_ERRNO_MISC,
+		    "Decompression internal error");
+		return (ARCHIVE_FAILED);
+	}
+	if (ret != ARCHIVE_OK && ret != ARCHIVE_EOF)
+		return (ret);
+
+	*used = o_avail_in - t_avail_in;
+	*outbytes = o_avail_out - t_avail_out;
+
+	/*
+	 * Decord BCJ.
+	 */
+	if (zip->codec != _7Z_LZMA2 && zip->codec2 == _7Z_X86) {
+		size_t l = x86_Convert(zip, buff, *outbytes);
+		zip->odd_bcj_size = *outbytes - l;
+		if (zip->odd_bcj_size > 0 && zip->odd_bcj_size <= 4 &&
+		    o_avail_in && ret != ARCHIVE_EOF) {
+			memcpy(zip->odd_bcj, ((unsigned char *)buff) + l,
+			    zip->odd_bcj_size);
+			*outbytes = l;
+		} else
+			zip->odd_bcj_size = 0;
+	}
+
+	/*
+	 * Decord BCJ2 with a decompressed main stream.
+	 */
+	if (zip->codec2 == _7Z_X86_BCJ2) {
+		ssize_t bytes;
+
+		zip->tmp_stream_bytes_avail =
+		    zip->tmp_stream_buff_size - t_avail_out;
+		if (zip->tmp_stream_bytes_avail >
+		      zip->main_stream_bytes_remaining)
+			zip->tmp_stream_bytes_avail =
+			    zip->main_stream_bytes_remaining;
+		zip->tmp_stream_bytes_remaining = zip->tmp_stream_bytes_avail;
+		bytes = Bcj2_Decode(zip, bcj2_next_out, bcj2_avail_out);
+		if (bytes < 0) {
+			archive_set_error(&(a->archive),
+			    ARCHIVE_ERRNO_MISC, "BCJ2 conversion Failed");
+			return (ARCHIVE_FAILED);
+		}
+		zip->main_stream_bytes_remaining -=
+		    zip->tmp_stream_bytes_avail
+		      - zip->tmp_stream_bytes_remaining;
+		bcj2_avail_out -= bytes;
+		*outbytes = o_avail_out - bcj2_avail_out;
+	}
+
+	return (ret);
+}
+
+static int
+free_decompression(struct archive_read *a, struct _7zip *zip)
+{
+	int r = ARCHIVE_OK;
+
+#if !defined(HAVE_ZLIB_H) &&\
+	!(defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR))
+	(void)a;/* UNUSED */
+#endif
+#ifdef HAVE_LZMA_H
+	if (zip->lzstream_valid)
+		lzma_end(&(zip->lzstream));
+#endif
+#if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)
+	if (zip->bzstream_valid) {
+		if (BZ2_bzDecompressEnd(&(zip->bzstream)) != BZ_OK) {
+			archive_set_error(&a->archive,
+			    ARCHIVE_ERRNO_MISC,
+			    "Failed to clean up bzip2 decompressor");
+			r = ARCHIVE_FATAL;
+		}
+		zip->bzstream_valid = 0;
+	}
+#endif
+#ifdef HAVE_ZLIB_H
+	if (zip->stream_valid) {
+		if (inflateEnd(&(zip->stream)) != Z_OK) {
+			archive_set_error(&a->archive,
+			    ARCHIVE_ERRNO_MISC,
+			    "Failed to clean up zlib decompressor");
+			r = ARCHIVE_FATAL;
+		}
+		zip->stream_valid = 0;
+	}
+#endif
+	if (zip->ppmd7_valid) {
+		__archive_ppmd7_functions.Ppmd7_Free(
+			&zip->ppmd7_context);
+		zip->ppmd7_valid = 0;
+	}
+	return (r);
+}
+
+static int
+parse_7zip_uint64(struct archive_read *a, uint64_t *val)
+{
+	const unsigned char *p;
+	unsigned char avail, mask;
+	int i;
+
+	if ((p = header_bytes(a, 1)) == NULL)
+		return (-1);
+	avail = *p;
+	mask = 0x80;
+	*val = 0;
+	for (i = 0; i < 8; i++) {
+		if (avail & mask) {
+			if ((p = header_bytes(a, 1)) == NULL)
+				return (-1);
+			*val |= ((uint64_t)*p) << (8 * i);
+			mask >>= 1;
+			continue;
+		}
+		*val += ((uint64_t)(avail & (mask -1))) << (8 * i);
+		break;
+	}
+	return (0);
+}
+
+static int
+read_Bools(struct archive_read *a, unsigned char *data, size_t num)
+{
+	const unsigned char *p;
+	unsigned i, mask = 0, avail = 0;
+
+	for (i = 0; i < num; i++) {
+		if (mask == 0) {
+			if ((p = header_bytes(a, 1)) == NULL)
+				return (-1);
+			avail = *p;
+			mask = 0x80;
+		}
+		data[i] = (avail & mask)?1:0;
+		mask >>= 1;
+	}
+	return (0);
+}
+
+static void
+free_Digest(struct _7z_digests *d)
+{
+	free(d->defineds);
+	free(d->digests);
+}
+
+static int
+read_Digests(struct archive_read *a, struct _7z_digests *d, size_t num)
+{
+	const unsigned char *p;
+	unsigned i;
+
+	if (num == 0)
+		return (-1);
+	memset(d, 0, sizeof(*d));
+
+	d->defineds = malloc(num);
+	if (d->defineds == NULL)
+		return (-1);
+	/*
+	 * Read Bools.
+	 */
+	if ((p = header_bytes(a, 1)) == NULL)
+		return (-1);
+	if (*p == 0) {
+		if (read_Bools(a, d->defineds, num) < 0)
+			return (-1);
+	} else
+		/* All are defined */
+		memset(d->defineds, 1, num);
+
+	d->digests = calloc(num, sizeof(*d->digests));
+	if (d->digests == NULL)
+		return (-1);
+	for (i = 0; i < num; i++) {
+		if (d->defineds[i]) {
+			if ((p = header_bytes(a, 4)) == NULL)
+				return (-1);
+			d->digests[i] = archive_le32dec(p);
+		}
+	}
+
+	return (0);
+}
+
+static void
+free_PackInfo(struct _7z_pack_info *pi)
+{
+	free(pi->sizes);
+	free(pi->positions);
+	free_Digest(&(pi->digest));
+}
+
+static int
+read_PackInfo(struct archive_read *a, struct _7z_pack_info *pi)
+{
+	const unsigned char *p;
+	unsigned i;
+
+	memset(pi, 0, sizeof(*pi));
+
+	/*
+	 * Read PackPos.
+	 */
+	if (parse_7zip_uint64(a, &(pi->pos)) < 0)
+		return (-1);
+
+	/*
+	 * Read NumPackStreams.
+	 */
+	if (parse_7zip_uint64(a, &(pi->numPackStreams)) < 0)
+		return (-1);
+	if (pi->numPackStreams == 0)
+		return (-1);
+	if (UMAX_ENTRY < pi->numPackStreams)
+		return (-1);
+
+	/*
+	 * Read PackSizes[num]
+	 */
+	if ((p = header_bytes(a, 1)) == NULL)
+		return (-1);
+	if (*p == kEnd)
+		/* PackSizes[num] are not present. */
+		return (0);
+	if (*p != kSize)
+		return (-1);
+	pi->sizes = calloc((size_t)pi->numPackStreams, sizeof(uint64_t));
+	pi->positions = calloc((size_t)pi->numPackStreams, sizeof(uint64_t));
+	if (pi->sizes == NULL || pi->positions == NULL)
+		return (-1);
+
+	for (i = 0; i < pi->numPackStreams; i++) {
+		if (parse_7zip_uint64(a, &(pi->sizes[i])) < 0)
+			return (-1);
+	}
+
+	/*
+	 * Read PackStreamDigests[num]
+	 */
+	if ((p = header_bytes(a, 1)) == NULL)
+		return (-1);
+	if (*p == kEnd) {
+		/* PackStreamDigests[num] are not present. */
+		pi->digest.defineds =
+		    calloc((size_t)pi->numPackStreams, sizeof(*pi->digest.defineds));
+		pi->digest.digests =
+		    calloc((size_t)pi->numPackStreams, sizeof(*pi->digest.digests));
+		if (pi->digest.defineds == NULL || pi->digest.digests == NULL)
+			return (-1);
+		return (0);
+	}
+
+	if (*p != kSize)
+		return (-1);
+
+	if (read_Digests(a, &(pi->digest), (size_t)pi->numPackStreams) < 0)
+		return (-1);
+
+	/*
+	 *  Must be marked by kEnd.
+	 */
+	if ((p = header_bytes(a, 1)) == NULL)
+		return (-1);
+	if (*p != kEnd)
+		return (-1);
+	return (0);
+}
+
+static void
+free_Folder(struct _7z_folder *f)
+{
+	unsigned i;
+
+	if (f->coders) {
+		for (i = 0; i< f->numCoders; i++) {
+			free(f->coders[i].properties);
+		}
+		free(f->coders);
+	}
+	free(f->bindPairs);
+	free(f->packedStreams);
+	free(f->unPackSize);
+}
+
+static int
+read_Folder(struct archive_read *a, struct _7z_folder *f)
+{
+	struct _7zip *zip = (struct _7zip *)a->format->data;
+	const unsigned char *p;
+	uint64_t numInStreamsTotal = 0;
+	uint64_t numOutStreamsTotal = 0;
+	unsigned i;
+
+	memset(f, 0, sizeof(*f));
+
+	/*
+	 * Read NumCoders.
+	 */
+	if (parse_7zip_uint64(a, &(f->numCoders)) < 0)
+		return (-1);
+	if (f->numCoders > 4)
+		/* Too many coders. */
+		return (-1);
+
+	f->coders = calloc((size_t)f->numCoders, sizeof(*f->coders));
+	if (f->coders == NULL)
+		return (-1);
+	for (i = 0; i< f->numCoders; i++) {
+		size_t codec_size;
+		int simple, attr;
+
+		if ((p = header_bytes(a, 1)) == NULL)
+			return (-1);
+		/*
+		 * 0:3 CodecIdSize
+		 * 4:  0 - IsSimple
+		 *     1 - Is not Simple
+		 * 5:  0 - No Attributes
+		 *     1 - There are Attributes;
+		 * 7:  Must be zero.
+		 */
+		codec_size = *p & 0xf;
+		simple = (*p & 0x10)?0:1;
+		attr = *p & 0x20;
+		if (*p & 0x80)
+			return (-1);/* Not supported. */
+
+		/*
+		 * Read Decompression Method IDs.
+		 */
+		if ((p = header_bytes(a, codec_size)) == NULL)
+			return (-1);
+
+		f->coders[i].codec = decode_codec_id(p, codec_size);
+
+		if (simple) {
+			f->coders[i].numInStreams = 1;
+			f->coders[i].numOutStreams = 1;
+		} else {
+			if (parse_7zip_uint64(
+			    a, &(f->coders[i].numInStreams)) < 0)
+				return (-1);
+			if (UMAX_ENTRY < f->coders[i].numInStreams)
+				return (-1);
+			if (parse_7zip_uint64(
+			    a, &(f->coders[i].numOutStreams)) < 0)
+				return (-1);
+			if (UMAX_ENTRY < f->coders[i].numOutStreams)
+				return (-1);
+		}
+
+		if (attr) {
+			if (parse_7zip_uint64(
+			    a, &(f->coders[i].propertiesSize)) < 0)
+				return (-1);
+			if ((p = header_bytes(
+			    a, (size_t)f->coders[i].propertiesSize)) == NULL)
+				return (-1);
+			f->coders[i].properties =
+			    malloc((size_t)f->coders[i].propertiesSize);
+			if (f->coders[i].properties == NULL)
+				return (-1);
+			memcpy(f->coders[i].properties, p,
+			    (size_t)f->coders[i].propertiesSize);
+		}
+
+		numInStreamsTotal += f->coders[i].numInStreams;
+		numOutStreamsTotal += f->coders[i].numOutStreams;
+	}
+
+	if (numOutStreamsTotal == 0 ||
+	    numInStreamsTotal < numOutStreamsTotal-1)
+		return (-1);
+
+	f->numBindPairs = numOutStreamsTotal - 1;
+	if (zip->header_bytes_remaining < f->numBindPairs)
+			return (-1);
+	if (f->numBindPairs > 0) {
+		f->bindPairs =
+			calloc((size_t)f->numBindPairs, sizeof(*f->bindPairs));
+		if (f->bindPairs == NULL)
+			return (-1);
+	} else
+		f->bindPairs = NULL;
+	for (i = 0; i < f->numBindPairs; i++) {
+		if (parse_7zip_uint64(a, &(f->bindPairs[i].inIndex)) < 0)
+			return (-1);
+		if (UMAX_ENTRY < f->bindPairs[i].inIndex)
+			return (-1);
+		if (parse_7zip_uint64(a, &(f->bindPairs[i].outIndex)) < 0)
+			return (-1);
+		if (UMAX_ENTRY < f->bindPairs[i].outIndex)
+			return (-1);
+	}
+
+	f->numPackedStreams = numInStreamsTotal - f->numBindPairs;
+	f->packedStreams =
+	    calloc((size_t)f->numPackedStreams, sizeof(*f->packedStreams));
+	if (f->packedStreams == NULL)
+		return (-1);
+	if (f->numPackedStreams == 1) {
+		for (i = 0; i < numInStreamsTotal; i++) {
+			unsigned j;
+			for (j = 0; j < f->numBindPairs; j++) {
+				if (f->bindPairs[j].inIndex == i)
+					break;
+			}
+			if (j == f->numBindPairs)
+				break;
+		}
+		if (i == numInStreamsTotal)
+			return (-1);
+		f->packedStreams[0] = i;
+	} else {
+		for (i = 0; i < f->numPackedStreams; i++) {
+			if (parse_7zip_uint64(a, &(f->packedStreams[i])) < 0)
+				return (-1);
+			if (UMAX_ENTRY < f->packedStreams[i])
+				return (-1);
+		}
+	}
+	f->numInStreams = numInStreamsTotal;
+	f->numOutStreams = numOutStreamsTotal;
+
+	return (0);
+}
+
+static void
+free_CodersInfo(struct _7z_coders_info *ci)
+{
+	unsigned i;
+
+	if (ci->folders) {
+		for (i = 0; i < ci->numFolders; i++)
+			free_Folder(&(ci->folders[i]));
+		free(ci->folders);
+	}
+}
+
+static int
+read_CodersInfo(struct archive_read *a, struct _7z_coders_info *ci)
+{
+	const unsigned char *p;
+	struct _7z_digests digest;
+	unsigned i;
+
+	memset(ci, 0, sizeof(*ci));
+	memset(&digest, 0, sizeof(digest));
+
+	if ((p = header_bytes(a, 1)) == NULL)
+		goto failed;
+	if (*p != kFolder)
+		goto failed;
+
+	/*
+	 * Read NumFolders.
+	 */
+	if (parse_7zip_uint64(a, &(ci->numFolders)) < 0)
+		goto failed;
+	if (UMAX_ENTRY < ci->numFolders)
+		return (-1);
+
+	/*
+	 * Read External.
+	 */
+	if ((p = header_bytes(a, 1)) == NULL)
+		goto failed;
+	switch (*p) {
+	case 0:
+		ci->folders =
+			calloc((size_t)ci->numFolders, sizeof(*ci->folders));
+		if (ci->folders == NULL)
+			return (-1);
+		for (i = 0; i < ci->numFolders; i++) {
+			if (read_Folder(a, &(ci->folders[i])) < 0)
+				goto failed;
+		}
+		break;
+	case 1:
+		if (parse_7zip_uint64(a, &(ci->dataStreamIndex)) < 0)
+			return (-1);
+		if (UMAX_ENTRY < ci->dataStreamIndex)
+			return (-1);
+		if (ci->numFolders > 0) {
+			archive_set_error(&a->archive, -1,
+			    "Malformed 7-Zip archive");
+			goto failed;
+		}
+		break;
+	default:
+		archive_set_error(&a->archive, -1,
+		    "Malformed 7-Zip archive");
+		goto failed;
+	}
+
+	if ((p = header_bytes(a, 1)) == NULL)
+		goto failed;
+	if (*p != kCodersUnPackSize)
+		goto failed;
+
+	for (i = 0; i < ci->numFolders; i++) {
+		struct _7z_folder *folder = &(ci->folders[i]);
+		unsigned j;
+
+		folder->unPackSize =
+		    calloc((size_t)folder->numOutStreams, sizeof(*folder->unPackSize));
+		if (folder->unPackSize == NULL)
+			goto failed;
+		for (j = 0; j < folder->numOutStreams; j++) {
+			if (parse_7zip_uint64(a, &(folder->unPackSize[j])) < 0)
+				goto failed;
+		}
+	}
+
+	/*
+	 * Read CRCs.
+	 */
+	if ((p = header_bytes(a, 1)) == NULL)
+		goto failed;
+	if (*p == kEnd)
+		return (0);
+	if (*p != kCRC)
+		goto failed;
+	if (read_Digests(a, &digest, (size_t)ci->numFolders) < 0)
+		goto failed;
+	for (i = 0; i < ci->numFolders; i++) {
+		ci->folders[i].digest_defined = digest.defineds[i];
+		ci->folders[i].digest = digest.digests[i];
+	}
+
+	/*
+	 *  Must be kEnd.
+	 */
+	if ((p = header_bytes(a, 1)) == NULL)
+		goto failed;
+	if (*p != kEnd)
+		goto failed;
+	free_Digest(&digest);
+	return (0);
+failed:
+	free_Digest(&digest);
+	return (-1);
+}
+
+static uint64_t
+folder_uncompressed_size(struct _7z_folder *f)
+{
+	int n = (int)f->numOutStreams;
+	unsigned pairs = (unsigned)f->numBindPairs;
+
+	while (--n >= 0) {
+		unsigned i;
+		for (i = 0; i < pairs; i++) {
+			if (f->bindPairs[i].outIndex == (uint64_t)n)
+				break;
+		}
+		if (i >= pairs)
+			return (f->unPackSize[n]);
+	}
+	return (0);
+}
+
+static void
+free_SubStreamsInfo(struct _7z_substream_info *ss)
+{
+	free(ss->unpackSizes);
+	free(ss->digestsDefined);
+	free(ss->digests);
+}
+
+static int
+read_SubStreamsInfo(struct archive_read *a, struct _7z_substream_info *ss,
+    struct _7z_folder *f, size_t numFolders)
+{
+	const unsigned char *p;
+	uint64_t *usizes;
+	size_t unpack_streams;
+	int type;
+	unsigned i;
+	uint32_t numDigests;
+
+	memset(ss, 0, sizeof(*ss));
+
+	for (i = 0; i < numFolders; i++)
+		f[i].numUnpackStreams = 1;
+
+	if ((p = header_bytes(a, 1)) == NULL)
+		return (-1);
+	type = *p;
+
+	if (type == kNumUnPackStream) {
+		unpack_streams = 0;
+		for (i = 0; i < numFolders; i++) {
+			if (parse_7zip_uint64(a, &(f[i].numUnpackStreams)) < 0)
+				return (-1);
+			if (UMAX_ENTRY < f[i].numUnpackStreams)
+				return (-1);
+			if (unpack_streams > SIZE_MAX - UMAX_ENTRY) {
+				return (-1);
+			}
+			unpack_streams += (size_t)f[i].numUnpackStreams;
+		}
+		if ((p = header_bytes(a, 1)) == NULL)
+			return (-1);
+		type = *p;
+	} else
+		unpack_streams = numFolders;
+
+	ss->unpack_streams = unpack_streams;
+	if (unpack_streams) {
+		ss->unpackSizes = calloc(unpack_streams,
+		    sizeof(*ss->unpackSizes));
+		ss->digestsDefined = calloc(unpack_streams,
+		    sizeof(*ss->digestsDefined));
+		ss->digests = calloc(unpack_streams,
+		    sizeof(*ss->digests));
+		if (ss->unpackSizes == NULL || ss->digestsDefined == NULL ||
+		    ss->digests == NULL)
+			return (-1);
+	}
+
+	usizes = ss->unpackSizes;
+	for (i = 0; i < numFolders; i++) {
+		unsigned pack;
+		uint64_t sum;
+
+		if (f[i].numUnpackStreams == 0)
+			continue;
+
+		sum = 0;
+		if (type == kSize) {
+			for (pack = 1; pack < f[i].numUnpackStreams; pack++) {
+				if (parse_7zip_uint64(a, usizes) < 0)
+					return (-1);
+				sum += *usizes++;
+			}
+		}
+		*usizes++ = folder_uncompressed_size(&f[i]) - sum;
+	}
+
+	if (type == kSize) {
+		if ((p = header_bytes(a, 1)) == NULL)
+			return (-1);
+		type = *p;
+	}
+
+	for (i = 0; i < unpack_streams; i++) {
+		ss->digestsDefined[i] = 0;
+		ss->digests[i] = 0;
+	}
+
+	numDigests = 0;
+	for (i = 0; i < numFolders; i++) {
+		if (f[i].numUnpackStreams != 1 || !f[i].digest_defined)
+			numDigests += (uint32_t)f[i].numUnpackStreams;
+	}
+
+	if (type == kCRC) {
+		struct _7z_digests tmpDigests;
+		unsigned char *digestsDefined = ss->digestsDefined;
+		uint32_t * digests = ss->digests;
+		int di = 0;
+
+		memset(&tmpDigests, 0, sizeof(tmpDigests));
+		if (read_Digests(a, &(tmpDigests), numDigests) < 0) {
+			free_Digest(&tmpDigests);
+			return (-1);
+		}
+		for (i = 0; i < numFolders; i++) {
+			if (f[i].numUnpackStreams == 1 && f[i].digest_defined) {
+				*digestsDefined++ = 1;
+				*digests++ = f[i].digest;
+			} else {
+				unsigned j;
+
+				for (j = 0; j < f[i].numUnpackStreams;
+				    j++, di++) {
+					*digestsDefined++ =
+					    tmpDigests.defineds[di];
+					*digests++ =
+					    tmpDigests.digests[di];
+				}
+			}
+		}
+		free_Digest(&tmpDigests);
+		if ((p = header_bytes(a, 1)) == NULL)
+			return (-1);
+		type = *p;
+	}
+
+	/*
+	 *  Must be kEnd.
+	 */
+	if (type != kEnd)
+		return (-1);
+	return (0);
+}
+
+static void
+free_StreamsInfo(struct _7z_stream_info *si)
+{
+	free_PackInfo(&(si->pi));
+	free_CodersInfo(&(si->ci));
+	free_SubStreamsInfo(&(si->ss));
+}
+
+static int
+read_StreamsInfo(struct archive_read *a, struct _7z_stream_info *si)
+{
+	struct _7zip *zip = (struct _7zip *)a->format->data;
+	const unsigned char *p;
+	unsigned i;
+
+	memset(si, 0, sizeof(*si));
+
+	if ((p = header_bytes(a, 1)) == NULL)
+		return (-1);
+	if (*p == kPackInfo) {
+		uint64_t packPos;
+
+		if (read_PackInfo(a, &(si->pi)) < 0)
+			return (-1);
+
+		if (si->pi.positions == NULL || si->pi.sizes == NULL)
+			return (-1);
+		/*
+		 * Calculate packed stream positions.
+		 */
+		packPos = si->pi.pos;
+		for (i = 0; i < si->pi.numPackStreams; i++) {
+			si->pi.positions[i] = packPos;
+			packPos += si->pi.sizes[i];
+			if (packPos > zip->header_offset)
+				return (-1);
+		}
+		if ((p = header_bytes(a, 1)) == NULL)
+			return (-1);
+	}
+	if (*p == kUnPackInfo) {
+		uint32_t packIndex;
+		struct _7z_folder *f;
+
+		if (read_CodersInfo(a, &(si->ci)) < 0)
+			return (-1);
+
+		/*
+		 * Calculate packed stream indexes.
+		 */
+		packIndex = 0;
+		f = si->ci.folders;
+		for (i = 0; i < si->ci.numFolders; i++) {
+			f[i].packIndex = packIndex;
+			packIndex += (uint32_t)f[i].numPackedStreams;
+			if (packIndex > si->pi.numPackStreams)
+				return (-1);
+		}
+		if ((p = header_bytes(a, 1)) == NULL)
+			return (-1);
+	}
+
+	if (*p == kSubStreamsInfo) {
+		if (read_SubStreamsInfo(a, &(si->ss),
+		    si->ci.folders, (size_t)si->ci.numFolders) < 0)
+			return (-1);
+		if ((p = header_bytes(a, 1)) == NULL)
+			return (-1);
+	}
+
+	/*
+	 *  Must be kEnd.
+	 */
+	if (*p != kEnd)
+		return (-1);
+	return (0);
+}
+
+static void
+free_Header(struct _7z_header_info *h)
+{
+	free(h->emptyStreamBools);
+	free(h->emptyFileBools);
+	free(h->antiBools);
+	free(h->attrBools);
+}
+
+static int
+read_Header(struct archive_read *a, struct _7z_header_info *h,
+    int check_header_id)
+{
+	struct _7zip *zip = (struct _7zip *)a->format->data;
+	const unsigned char *p;
+	struct _7z_folder *folders;
+	struct _7z_stream_info *si = &(zip->si);
+	struct _7zip_entry *entries;
+	uint32_t folderIndex, indexInFolder;
+	unsigned i;
+	int eindex, empty_streams, sindex;
+
+	if (check_header_id) {
+		/*
+		 * Read Header.
+		 */
+		if ((p = header_bytes(a, 1)) == NULL)
+			return (-1);
+		if (*p != kHeader)
+			return (-1);
+	}
+
+	/*
+	 * Read ArchiveProperties.
+	 */
+	if ((p = header_bytes(a, 1)) == NULL)
+		return (-1);
+	if (*p == kArchiveProperties) {
+		for (;;) {
+			uint64_t size;
+			if ((p = header_bytes(a, 1)) == NULL)
+				return (-1);
+			if (*p == 0)
+				break;
+			if (parse_7zip_uint64(a, &size) < 0)
+				return (-1);
+		}
+		if ((p = header_bytes(a, 1)) == NULL)
+			return (-1);
+	}
+
+	/*
+	 * Read MainStreamsInfo.
+	 */
+	if (*p == kMainStreamsInfo) {
+		if (read_StreamsInfo(a, &(zip->si)) < 0)
+			return (-1);
+		if ((p = header_bytes(a, 1)) == NULL)
+			return (-1);
+	}
+	if (*p == kEnd)
+		return (0);
+
+	/*
+	 * Read FilesInfo.
+	 */
+	if (*p != kFilesInfo)
+		return (-1);
+
+	if (parse_7zip_uint64(a, &(zip->numFiles)) < 0)
+		return (-1);
+	if (UMAX_ENTRY < zip->numFiles)
+		return (-1);
+
+	zip->entries = calloc((size_t)zip->numFiles, sizeof(*zip->entries));
+	if (zip->entries == NULL)
+		return (-1);
+	entries = zip->entries;
+
+	empty_streams = 0;
+	for (;;) {
+		int type;
+		uint64_t size;
+		size_t ll;
+
+		if ((p = header_bytes(a, 1)) == NULL)
+			return (-1);
+		type = *p;
+		if (type == kEnd)
+			break;
+
+		if (parse_7zip_uint64(a, &size) < 0)
+			return (-1);
+		if (zip->header_bytes_remaining < size)
+			return (-1);
+		ll = (size_t)size;
+
+		switch (type) {
+		case kEmptyStream:
+			if (h->emptyStreamBools != NULL)
+				return (-1);
+			h->emptyStreamBools = calloc((size_t)zip->numFiles,
+			    sizeof(*h->emptyStreamBools));
+			if (h->emptyStreamBools == NULL)
+				return (-1);
+			if (read_Bools(
+			    a, h->emptyStreamBools, (size_t)zip->numFiles) < 0)
+				return (-1);
+			empty_streams = 0;
+			for (i = 0; i < zip->numFiles; i++) {
+				if (h->emptyStreamBools[i])
+					empty_streams++;
+			}
+			break;
+		case kEmptyFile:
+			if (empty_streams <= 0) {
+				/* Unexcepted sequence. Skip this. */
+				if (header_bytes(a, ll) == NULL)
+					return (-1);
+				break;
+			}
+			if (h->emptyFileBools != NULL)
+				return (-1);
+			h->emptyFileBools = calloc(empty_streams,
+			    sizeof(*h->emptyFileBools));
+			if (h->emptyFileBools == NULL)
+				return (-1);
+			if (read_Bools(a, h->emptyFileBools, empty_streams) < 0)
+				return (-1);
+			break;
+		case kAnti:
+			if (empty_streams <= 0) {
+				/* Unexcepted sequence. Skip this. */
+				if (header_bytes(a, ll) == NULL)
+					return (-1);
+				break;
+			}
+			if (h->antiBools != NULL)
+				return (-1);
+			h->antiBools = calloc(empty_streams,
+			    sizeof(*h->antiBools));
+			if (h->antiBools == NULL)
+				return (-1);
+			if (read_Bools(a, h->antiBools, empty_streams) < 0)
+				return (-1);
+			break;
+		case kCTime:
+		case kATime:
+		case kMTime:
+			if (read_Times(a, h, type) < 0)
+				return (-1);
+			break;
+		case kName:
+		{
+			unsigned char *np;
+			size_t nl, nb;
+
+			/* Skip one byte. */
+			if ((p = header_bytes(a, 1)) == NULL)
+				return (-1);
+			ll--;
+
+			if ((ll & 1) || ll < zip->numFiles * 4)
+				return (-1);
+
+			if (zip->entry_names != NULL)
+				return (-1);
+			zip->entry_names = malloc(ll);
+			if (zip->entry_names == NULL)
+				return (-1);
+			np = zip->entry_names;
+			nb = ll;
+			/*
+			 * Copy whole file names.
+			 * NOTE: This loop prevents from expanding
+			 * the uncompressed buffer in order not to
+			 * use extra memory resource.
+			 */
+			while (nb) {
+				size_t b;
+				if (nb > UBUFF_SIZE)
+					b = UBUFF_SIZE;
+				else
+					b = nb;
+				if ((p = header_bytes(a, b)) == NULL)
+					return (-1);
+				memcpy(np, p, b);
+				np += b;
+				nb -= b;
+			}
+			np = zip->entry_names;
+			nl = ll;
+
+			for (i = 0; i < zip->numFiles; i++) {
+				entries[i].utf16name = np;
+#if defined(_WIN32) && !defined(__CYGWIN__) && defined(_DEBUG)
+				entries[i].wname = (wchar_t *)np;
+#endif
+
+				/* Find a terminator. */
+				while (nl >= 2 && (np[0] || np[1])) {
+					np += 2;
+					nl -= 2;
+				}
+				if (nl < 2)
+					return (-1);/* Terminator not found */
+				entries[i].name_len = np - entries[i].utf16name;
+				np += 2;
+				nl -= 2;
+			}
+			break;
+		}
+		case kAttributes:
+		{
+			int allAreDefined;
+
+			if ((p = header_bytes(a, 2)) == NULL)
+				return (-1);
+			allAreDefined = *p;
+			if (h->attrBools != NULL)
+				return (-1);
+			h->attrBools = calloc((size_t)zip->numFiles,
+			    sizeof(*h->attrBools));
+			if (h->attrBools == NULL)
+				return (-1);
+			if (allAreDefined)
+				memset(h->attrBools, 1, (size_t)zip->numFiles);
+			else {
+				if (read_Bools(a, h->attrBools,
+				      (size_t)zip->numFiles) < 0)
+					return (-1);
+			}
+			for (i = 0; i < zip->numFiles; i++) {
+				if (h->attrBools[i]) {
+					if ((p = header_bytes(a, 4)) == NULL)
+						return (-1);
+					entries[i].attr = archive_le32dec(p);
+				}
+			}
+			break;
+		}
+		case kDummy:
+			if (ll == 0)
+				break;
+			__LA_FALLTHROUGH;
+		default:
+			if (header_bytes(a, ll) == NULL)
+				return (-1);
+			break;
+		}
+	}
+
+	/*
+	 * Set up entry's attributes.
+	 */
+	folders = si->ci.folders;
+	eindex = sindex = 0;
+	folderIndex = indexInFolder = 0;
+	for (i = 0; i < zip->numFiles; i++) {
+		if (h->emptyStreamBools == NULL || h->emptyStreamBools[i] == 0)
+			entries[i].flg |= HAS_STREAM;
+		/* The high 16 bits of attributes is a posix file mode. */
+		entries[i].mode = entries[i].attr >> 16;
+		if (entries[i].flg & HAS_STREAM) {
+			if ((size_t)sindex >= si->ss.unpack_streams)
+				return (-1);
+			if (entries[i].mode == 0)
+				entries[i].mode = AE_IFREG | 0666;
+			if (si->ss.digestsDefined[sindex])
+				entries[i].flg |= CRC32_IS_SET;
+			entries[i].ssIndex = sindex;
+			sindex++;
+		} else {
+			int dir;
+			if (h->emptyFileBools == NULL)
+				dir = 1;
+			else {
+				if (h->emptyFileBools[eindex])
+					dir = 0;
+				else
+					dir = 1;
+				eindex++;
+			}
+			if (entries[i].mode == 0) {
+				if (dir)
+					entries[i].mode = AE_IFDIR | 0777;
+				else
+					entries[i].mode = AE_IFREG | 0666;
+			} else if (dir &&
+			    (entries[i].mode & AE_IFMT) != AE_IFDIR) {
+				entries[i].mode &= ~AE_IFMT;
+				entries[i].mode |= AE_IFDIR;
+			}
+			if ((entries[i].mode & AE_IFMT) == AE_IFDIR &&
+			    entries[i].name_len >= 2 &&
+			    (entries[i].utf16name[entries[i].name_len-2] != '/' ||
+			     entries[i].utf16name[entries[i].name_len-1] != 0)) {
+				entries[i].utf16name[entries[i].name_len] = '/';
+				entries[i].utf16name[entries[i].name_len+1] = 0;
+				entries[i].name_len += 2;
+			}
+			entries[i].ssIndex = -1;
+		}
+		if (entries[i].attr & 0x01)
+			entries[i].mode &= ~0222;/* Read only. */
+
+		if ((entries[i].flg & HAS_STREAM) == 0 && indexInFolder == 0) {
+			/*
+			 * The entry is an empty file or a directory file,
+			 * those both have no contents.
+			 */
+			entries[i].folderIndex = -1;
+			continue;
+		}
+		if (indexInFolder == 0) {
+			for (;;) {
+				if (folderIndex >= si->ci.numFolders)
+					return (-1);
+				if (folders[folderIndex].numUnpackStreams)
+					break;
+				folderIndex++;
+			}
+		}
+		entries[i].folderIndex = folderIndex;
+		if ((entries[i].flg & HAS_STREAM) == 0)
+			continue;
+		indexInFolder++;
+		if (indexInFolder >= folders[folderIndex].numUnpackStreams) {
+			folderIndex++;
+			indexInFolder = 0;
+		}
+	}
+
+	return (0);
+}
+
+#define EPOC_TIME ARCHIVE_LITERAL_ULL(116444736000000000)
+static void
+fileTimeToUtc(uint64_t fileTime, time_t *timep, long *ns)
+{
+
+	if (fileTime >= EPOC_TIME) {
+		fileTime -= EPOC_TIME;
+		/* milli seconds base */
+		*timep = (time_t)(fileTime / 10000000);
+		/* nano seconds base */
+		*ns = (long)(fileTime % 10000000) * 100;
+	} else {
+		*timep = 0;
+		*ns = 0;
+	}
+}
+
+static int
+read_Times(struct archive_read *a, struct _7z_header_info *h, int type)
+{
+	struct _7zip *zip = (struct _7zip *)a->format->data;
+	const unsigned char *p;
+	struct _7zip_entry *entries = zip->entries;
+	unsigned char *timeBools;
+	int allAreDefined;
+	unsigned i;
+
+	timeBools = calloc((size_t)zip->numFiles, sizeof(*timeBools));
+	if (timeBools == NULL)
+		return (-1);
+
+	/* Read allAreDefined. */
+	if ((p = header_bytes(a, 1)) == NULL)
+		goto failed;
+	allAreDefined = *p;
+	if (allAreDefined)
+		memset(timeBools, 1, (size_t)zip->numFiles);
+	else {
+		if (read_Bools(a, timeBools, (size_t)zip->numFiles) < 0)
+			goto failed;
+	}
+
+	/* Read external. */
+	if ((p = header_bytes(a, 1)) == NULL)
+		goto failed;
+	if (*p) {
+		if (parse_7zip_uint64(a, &(h->dataIndex)) < 0)
+			goto failed;
+		if (UMAX_ENTRY < h->dataIndex)
+			goto failed;
+	}
+
+	for (i = 0; i < zip->numFiles; i++) {
+		if (!timeBools[i])
+			continue;
+		if ((p = header_bytes(a, 8)) == NULL)
+			goto failed;
+		switch (type) {
+		case kCTime:
+			fileTimeToUtc(archive_le64dec(p),
+			    &(entries[i].ctime),
+			    &(entries[i].ctime_ns));
+			entries[i].flg |= CTIME_IS_SET;
+			break;
+		case kATime:
+			fileTimeToUtc(archive_le64dec(p),
+			    &(entries[i].atime),
+			    &(entries[i].atime_ns));
+			entries[i].flg |= ATIME_IS_SET;
+			break;
+		case kMTime:
+			fileTimeToUtc(archive_le64dec(p),
+			    &(entries[i].mtime),
+			    &(entries[i].mtime_ns));
+			entries[i].flg |= MTIME_IS_SET;
+			break;
+		}
+	}
+
+	free(timeBools);
+	return (0);
+failed:
+	free(timeBools);
+	return (-1);
+}
+
+static int
+decode_encoded_header_info(struct archive_read *a, struct _7z_stream_info *si)
+{
+	struct _7zip *zip = (struct _7zip *)a->format->data;
+
+	errno = 0;
+	if (read_StreamsInfo(a, si) < 0) {
+		if (errno == ENOMEM)
+			archive_set_error(&a->archive, -1,
+			    "Couldn't allocate memory");
+		else
+			archive_set_error(&a->archive, -1,
+			    "Malformed 7-Zip archive");
+		return (ARCHIVE_FATAL);
+	}
+
+	if (si->pi.numPackStreams == 0 || si->ci.numFolders == 0) {
+		archive_set_error(&a->archive, -1, "Malformed 7-Zip archive");
+		return (ARCHIVE_FATAL);
+	}
+
+	if (zip->header_offset < si->pi.pos + si->pi.sizes[0] ||
+	    (int64_t)(si->pi.pos + si->pi.sizes[0]) < 0 ||
+	    si->pi.sizes[0] == 0 || (int64_t)si->pi.pos < 0) {
+		archive_set_error(&a->archive, -1, "Malformed Header offset");
+		return (ARCHIVE_FATAL);
+	}
+
+	return (ARCHIVE_OK);
+}
+
+static const unsigned char *
+header_bytes(struct archive_read *a, size_t rbytes)
+{
+	struct _7zip *zip = (struct _7zip *)a->format->data;
+	const unsigned char *p;
+
+	if (zip->header_bytes_remaining < rbytes)
+		return (NULL);
+	if (zip->pack_stream_bytes_unconsumed)
+		read_consume(a);
+
+	if (zip->header_is_encoded == 0) {
+		p = __archive_read_ahead(a, rbytes, NULL);
+		if (p == NULL)
+			return (NULL);
+		zip->header_bytes_remaining -= rbytes;
+		zip->pack_stream_bytes_unconsumed = rbytes;
+	} else {
+		const void *buff;
+		ssize_t bytes;
+
+		bytes = read_stream(a, &buff, rbytes, rbytes);
+		if (bytes <= 0)
+			return (NULL);
+		zip->header_bytes_remaining -= bytes;
+		p = buff;
+	}
+
+	/* Update checksum */
+	zip->header_crc32 = crc32(zip->header_crc32, p, (unsigned)rbytes);
+	return (p);
+}
+
+static int
+slurp_central_directory(struct archive_read *a, struct _7zip *zip,
+    struct _7z_header_info *header)
+{
+	const unsigned char *p;
+	uint64_t next_header_offset;
+	uint64_t next_header_size;
+	uint32_t next_header_crc;
+	ssize_t bytes_avail;
+	int check_header_crc, r;
+
+	if ((p = __archive_read_ahead(a, 32, &bytes_avail)) == NULL)
+		return (ARCHIVE_FATAL);
+
+	if ((p[0] == 'M' && p[1] == 'Z') || memcmp(p, "\x7F\x45LF", 4) == 0) {
+		/* This is an executable ? Must be self-extracting... */
+		r = skip_sfx(a, bytes_avail);
+		if (r < ARCHIVE_WARN)
+			return (r);
+		if ((p = __archive_read_ahead(a, 32, &bytes_avail)) == NULL)
+			return (ARCHIVE_FATAL);
+	}
+	zip->seek_base += 32;
+
+	if (memcmp(p, _7ZIP_SIGNATURE, 6) != 0) {
+		archive_set_error(&a->archive, -1, "Not 7-Zip archive file");
+		return (ARCHIVE_FATAL);
+	}
+
+	/* CRC check. */
+	if (crc32(0, (const unsigned char *)p + 12, 20)
+	    != archive_le32dec(p + 8)) {
+		archive_set_error(&a->archive, -1, "Header CRC error");
+		return (ARCHIVE_FATAL);
+	}
+
+	next_header_offset = archive_le64dec(p + 12);
+	next_header_size = archive_le64dec(p + 20);
+	next_header_crc = archive_le32dec(p + 28);
+
+	if (next_header_size == 0)
+		/* There is no entry in an archive file. */
+		return (ARCHIVE_EOF);
+
+	if (((int64_t)next_header_offset) < 0) {
+		archive_set_error(&a->archive, -1, "Malformed 7-Zip archive");
+		return (ARCHIVE_FATAL);
+	}
+	__archive_read_consume(a, 32);
+	if (next_header_offset != 0) {
+		if (bytes_avail >= (ssize_t)next_header_offset)
+			__archive_read_consume(a, next_header_offset);
+		else if (__archive_read_seek(a,
+		    next_header_offset + zip->seek_base, SEEK_SET) < 0)
+			return (ARCHIVE_FATAL);
+	}
+	zip->stream_offset = next_header_offset;
+	zip->header_offset = next_header_offset;
+	zip->header_bytes_remaining = next_header_size;
+	zip->header_crc32 = 0;
+	zip->header_is_encoded = 0;
+	zip->header_is_being_read = 1;
+	zip->has_encrypted_entries = 0;
+	check_header_crc = 1;
+
+	if ((p = header_bytes(a, 1)) == NULL) {
+		archive_set_error(&a->archive,
+		    ARCHIVE_ERRNO_FILE_FORMAT,
+		    "Truncated 7-Zip file body");
+		return (ARCHIVE_FATAL);
+	}
+	/* Parse ArchiveProperties. */
+	switch (p[0]) {
+	case kEncodedHeader:
+		/*
+		 * The archive has an encoded header and we have to decode it
+		 * in order to parse the header correctly.
+		 */
+		r = decode_encoded_header_info(a, &(zip->si));
+
+		/* Check the EncodedHeader CRC.*/
+		if (r == 0 && zip->header_crc32 != next_header_crc) {
+			archive_set_error(&a->archive, -1,
+			    "Damaged 7-Zip archive");
+			r = -1;
+		}
+		if (r == 0) {
+			if (zip->si.ci.folders[0].digest_defined)
+				next_header_crc = zip->si.ci.folders[0].digest;
+			else
+				check_header_crc = 0;
+			if (zip->pack_stream_bytes_unconsumed)
+				read_consume(a);
+			r = setup_decode_folder(a, zip->si.ci.folders, 1);
+			if (r == 0) {
+				zip->header_bytes_remaining =
+					zip->folder_outbytes_remaining;
+				r = seek_pack(a);
+			}
+		}
+		/* Clean up StreamsInfo. */
+		free_StreamsInfo(&(zip->si));
+		memset(&(zip->si), 0, sizeof(zip->si));
+		if (r < 0)
+			return (ARCHIVE_FATAL);
+		zip->header_is_encoded = 1;
+		zip->header_crc32 = 0;
+		/* FALL THROUGH */
+	case kHeader:
+		/*
+		 * Parse the header.
+		 */
+		errno = 0;
+		r = read_Header(a, header, zip->header_is_encoded);
+		if (r < 0) {
+			if (errno == ENOMEM)
+				archive_set_error(&a->archive, -1,
+				    "Couldn't allocate memory");
+			else
+				archive_set_error(&a->archive, -1,
+				    "Damaged 7-Zip archive");
+			return (ARCHIVE_FATAL);
+		}
+
+		/*
+		 *  Must be kEnd.
+		 */
+		if ((p = header_bytes(a, 1)) == NULL ||*p != kEnd) {
+			archive_set_error(&a->archive, -1,
+			    "Malformed 7-Zip archive");
+			return (ARCHIVE_FATAL);
+		}
+
+		/* Check the Header CRC.*/
+		if (check_header_crc && zip->header_crc32 != next_header_crc) {
+			archive_set_error(&a->archive, -1,
+			    "Malformed 7-Zip archive");
+			return (ARCHIVE_FATAL);
+		}
+		break;
+	default:
+		archive_set_error(&a->archive, -1,
+		    "Unexpected Property ID = %X", p[0]);
+		return (ARCHIVE_FATAL);
+	}
+
+	/* Clean up variables be used for decoding the archive header */
+	zip->pack_stream_remaining = 0;
+	zip->pack_stream_index = 0;
+	zip->folder_outbytes_remaining = 0;
+	zip->uncompressed_buffer_bytes_remaining = 0;
+	zip->pack_stream_bytes_unconsumed = 0;
+	zip->header_is_being_read = 0;
+
+	return (ARCHIVE_OK);
+}
+
+static ssize_t
+get_uncompressed_data(struct archive_read *a, const void **buff, size_t size,
+    size_t minimum)
+{
+	struct _7zip *zip = (struct _7zip *)a->format->data;
+	ssize_t bytes_avail;
+
+	if (zip->codec == _7Z_COPY && zip->codec2 == (unsigned long)-1) {
+		/* Copy mode. */
+
+		/*
+		 * Note: '1' here is a performance optimization.
+		 * Recall that the decompression layer returns a count of
+		 * available bytes; asking for more than that forces the
+		 * decompressor to combine reads by copying data.
+		 */
+		*buff = __archive_read_ahead(a, 1, &bytes_avail);
+		if (bytes_avail <= 0) {
+			archive_set_error(&a->archive,
+			    ARCHIVE_ERRNO_FILE_FORMAT,
+			    "Truncated 7-Zip file data");
+			return (ARCHIVE_FATAL);
+		}
+		if ((size_t)bytes_avail >
+		    zip->uncompressed_buffer_bytes_remaining)
+			bytes_avail = (ssize_t)
+			    zip->uncompressed_buffer_bytes_remaining;
+		if ((size_t)bytes_avail > size)
+			bytes_avail = (ssize_t)size;
+
+		zip->pack_stream_bytes_unconsumed = bytes_avail;
+	} else if (zip->uncompressed_buffer_pointer == NULL) {
+		/* Decompression has failed. */
+		archive_set_error(&(a->archive),
+		    ARCHIVE_ERRNO_MISC, "Damaged 7-Zip archive");
+		return (ARCHIVE_FATAL);
+	} else {
+		/* Packed mode. */
+		if (minimum > zip->uncompressed_buffer_bytes_remaining) {
+			/*
+			 * If remaining uncompressed data size is less than
+			 * the minimum size, fill the buffer up to the
+			 * minimum size.
+			 */
+			if (extract_pack_stream(a, minimum) < 0)
+				return (ARCHIVE_FATAL);
+		}
+		if (size > zip->uncompressed_buffer_bytes_remaining)
+			bytes_avail = (ssize_t)
+			    zip->uncompressed_buffer_bytes_remaining;
+		else
+			bytes_avail = (ssize_t)size;
+		*buff = zip->uncompressed_buffer_pointer;
+		zip->uncompressed_buffer_pointer += bytes_avail;
+	}
+	zip->uncompressed_buffer_bytes_remaining -= bytes_avail;
+	return (bytes_avail);
+}
+
+static ssize_t
+extract_pack_stream(struct archive_read *a, size_t minimum)
+{
+	struct _7zip *zip = (struct _7zip *)a->format->data;
+	ssize_t bytes_avail;
+	int r;
+
+	if (zip->codec == _7Z_COPY && zip->codec2 == (unsigned long)-1) {
+		if (minimum == 0)
+			minimum = 1;
+		if (__archive_read_ahead(a, minimum, &bytes_avail) == NULL
+		    || bytes_avail <= 0) {
+			archive_set_error(&a->archive,
+			    ARCHIVE_ERRNO_FILE_FORMAT,
+			    "Truncated 7-Zip file body");
+			return (ARCHIVE_FATAL);
+		}
+		if (bytes_avail > (ssize_t)zip->pack_stream_inbytes_remaining)
+			bytes_avail = (ssize_t)zip->pack_stream_inbytes_remaining;
+		zip->pack_stream_inbytes_remaining -= bytes_avail;
+		if (bytes_avail > (ssize_t)zip->folder_outbytes_remaining)
+			bytes_avail = (ssize_t)zip->folder_outbytes_remaining;
+		zip->folder_outbytes_remaining -= bytes_avail;
+		zip->uncompressed_buffer_bytes_remaining = bytes_avail;
+		return (ARCHIVE_OK);
+	}
+
+	/* If the buffer hasn't been allocated, allocate it now. */
+	if (zip->uncompressed_buffer == NULL) {
+		zip->uncompressed_buffer_size = UBUFF_SIZE;
+		if (zip->uncompressed_buffer_size < minimum) {
+			zip->uncompressed_buffer_size = minimum + 1023;
+			zip->uncompressed_buffer_size &= ~0x3ff;
+		}
+		zip->uncompressed_buffer =
+		    malloc(zip->uncompressed_buffer_size);
+		if (zip->uncompressed_buffer == NULL) {
+			archive_set_error(&a->archive, ENOMEM,
+			    "No memory for 7-Zip decompression");
+			return (ARCHIVE_FATAL);
+		}
+		zip->uncompressed_buffer_bytes_remaining = 0;
+	} else if (zip->uncompressed_buffer_size < minimum ||
+	    zip->uncompressed_buffer_bytes_remaining < minimum) {
+		/*
+		 * Make sure the uncompressed buffer can have bytes
+		 * at least `minimum' bytes.
+		 * NOTE: This case happen when reading the header.
+		 */
+		size_t used;
+		if (zip->uncompressed_buffer_pointer != 0)
+			used = zip->uncompressed_buffer_pointer -
+				zip->uncompressed_buffer;
+		else
+			used = 0;
+		if (zip->uncompressed_buffer_size < minimum) {
+			/*
+			 * Expand the uncompressed buffer up to
+			 * the minimum size.
+			 */
+			void *p;
+			size_t new_size;
+
+			new_size = minimum + 1023;
+			new_size &= ~0x3ff;
+			p = realloc(zip->uncompressed_buffer, new_size);
+			if (p == NULL) {
+				archive_set_error(&a->archive, ENOMEM,
+				    "No memory for 7-Zip decompression");
+				return (ARCHIVE_FATAL);
+			}
+			zip->uncompressed_buffer = (unsigned char *)p;
+			zip->uncompressed_buffer_size = new_size;
+		}
+		/*
+		 * Move unconsumed bytes to the head.
+		 */
+		if (used) {
+			memmove(zip->uncompressed_buffer,
+				zip->uncompressed_buffer + used,
+				zip->uncompressed_buffer_bytes_remaining);
+		}
+	} else
+		zip->uncompressed_buffer_bytes_remaining = 0;
+	zip->uncompressed_buffer_pointer = NULL;
+	for (;;) {
+		size_t bytes_in, bytes_out;
+		const void *buff_in;
+		unsigned char *buff_out;
+		int end_of_data;
+
+		/*
+		 * Note: '1' here is a performance optimization.
+		 * Recall that the decompression layer returns a count of
+		 * available bytes; asking for more than that forces the
+		 * decompressor to combine reads by copying data.
+		 */
+		buff_in = __archive_read_ahead(a, 1, &bytes_avail);
+		if (bytes_avail <= 0) {
+			archive_set_error(&a->archive,
+			    ARCHIVE_ERRNO_FILE_FORMAT,
+			    "Truncated 7-Zip file body");
+			return (ARCHIVE_FATAL);
+		}
+
+		buff_out = zip->uncompressed_buffer
+			+ zip->uncompressed_buffer_bytes_remaining;
+		bytes_out = zip->uncompressed_buffer_size
+			- zip->uncompressed_buffer_bytes_remaining;
+		bytes_in = bytes_avail;
+		if (bytes_in > zip->pack_stream_inbytes_remaining)
+			bytes_in = (size_t)zip->pack_stream_inbytes_remaining;
+		/* Drive decompression. */
+		r = decompress(a, zip, buff_out, &bytes_out,
+			buff_in, &bytes_in);
+		switch (r) {
+		case ARCHIVE_OK:
+			end_of_data = 0;
+			break;
+		case ARCHIVE_EOF:
+			end_of_data = 1;
+			break;
+		default:
+			return (ARCHIVE_FATAL);
+		}
+		zip->pack_stream_inbytes_remaining -= bytes_in;
+		if (bytes_out > zip->folder_outbytes_remaining)
+			bytes_out = (size_t)zip->folder_outbytes_remaining;
+		zip->folder_outbytes_remaining -= bytes_out;
+		zip->uncompressed_buffer_bytes_remaining += bytes_out;
+		zip->pack_stream_bytes_unconsumed = bytes_in;
+
+		/*
+		 * Continue decompression until uncompressed_buffer is full.
+		 */
+		if (zip->uncompressed_buffer_bytes_remaining ==
+		    zip->uncompressed_buffer_size)
+			break;
+		if (zip->codec2 == _7Z_X86 && zip->odd_bcj_size &&
+		    zip->uncompressed_buffer_bytes_remaining + 5 >
+		    zip->uncompressed_buffer_size)
+			break;
+		if (zip->pack_stream_inbytes_remaining == 0 &&
+		    zip->folder_outbytes_remaining == 0)
+			break;
+		if (end_of_data || (bytes_in == 0 && bytes_out == 0)) {
+			archive_set_error(&(a->archive),
+			    ARCHIVE_ERRNO_MISC, "Damaged 7-Zip archive");
+			return (ARCHIVE_FATAL);
+		}
+		read_consume(a);
+	}
+	if (zip->uncompressed_buffer_bytes_remaining < minimum) {
+		archive_set_error(&(a->archive),
+		    ARCHIVE_ERRNO_MISC, "Damaged 7-Zip archive");
+		return (ARCHIVE_FATAL);
+	}
+	zip->uncompressed_buffer_pointer = zip->uncompressed_buffer;
+	return (ARCHIVE_OK);
+}
+
+static int
+seek_pack(struct archive_read *a)
+{
+	struct _7zip *zip = (struct _7zip *)a->format->data;
+	int64_t pack_offset;
+
+	if (zip->pack_stream_remaining <= 0) {
+		archive_set_error(&(a->archive),
+		    ARCHIVE_ERRNO_MISC, "Damaged 7-Zip archive");
+		return (ARCHIVE_FATAL);
+	}
+	zip->pack_stream_inbytes_remaining =
+	    zip->si.pi.sizes[zip->pack_stream_index];
+	pack_offset = zip->si.pi.positions[zip->pack_stream_index];
+	if (zip->stream_offset != pack_offset) {
+		if (0 > __archive_read_seek(a, pack_offset + zip->seek_base,
+		    SEEK_SET))
+			return (ARCHIVE_FATAL);
+		zip->stream_offset = pack_offset;
+	}
+	zip->pack_stream_index++;
+	zip->pack_stream_remaining--;
+	return (ARCHIVE_OK);
+}
+
+static ssize_t
+read_stream(struct archive_read *a, const void **buff, size_t size,
+    size_t minimum)
+{
+	struct _7zip *zip = (struct _7zip *)a->format->data;
+	uint64_t skip_bytes = 0;
+	ssize_t r;
+
+	if (zip->uncompressed_buffer_bytes_remaining == 0) {
+		if (zip->pack_stream_inbytes_remaining > 0) {
+			r = extract_pack_stream(a, 0);
+			if (r < 0)
+				return (r);
+			return (get_uncompressed_data(a, buff, size, minimum));
+		} else if (zip->folder_outbytes_remaining > 0) {
+			/* Extract a remaining pack stream. */
+			r = extract_pack_stream(a, 0);
+			if (r < 0)
+				return (r);
+			return (get_uncompressed_data(a, buff, size, minimum));
+		}
+	} else
+		return (get_uncompressed_data(a, buff, size, minimum));
+
+	/*
+	 * Current pack stream has been consumed.
+	 */
+	if (zip->pack_stream_remaining == 0) {
+		if (zip->header_is_being_read) {
+			/* Invalid sequence. This might happen when
+			 * reading a malformed archive. */
+			archive_set_error(&(a->archive),
+			    ARCHIVE_ERRNO_MISC, "Malformed 7-Zip archive");
+			return (ARCHIVE_FATAL);
+		}
+
+		/*
+		 * All current folder's pack streams have been
+		 * consumed. Switch to next folder.
+		 */
+		if (zip->folder_index == 0 &&
+		    (zip->si.ci.folders[zip->entry->folderIndex].skipped_bytes
+		     || zip->folder_index != zip->entry->folderIndex)) {
+			zip->folder_index = zip->entry->folderIndex;
+			skip_bytes =
+			    zip->si.ci.folders[zip->folder_index].skipped_bytes;
+		}
+
+		if (zip->folder_index >= zip->si.ci.numFolders) {
+			/*
+			 * We have consumed all folders and its pack streams.
+			 */
+			*buff = NULL;
+			return (0);
+		}
+		r = setup_decode_folder(a,
+			&(zip->si.ci.folders[zip->folder_index]), 0);
+		if (r != ARCHIVE_OK)
+			return (ARCHIVE_FATAL);
+
+		zip->folder_index++;
+	}
+
+	/*
+	 * Switch to next pack stream.
+	 */
+	r = seek_pack(a);
+	if (r < 0)
+		return (r);
+
+	/* Extract a new pack stream. */
+	r = extract_pack_stream(a, 0);
+	if (r < 0)
+		return (r);
+
+	/*
+	 * Skip the bytes we already has skipped in skip_stream().
+	 */
+	while (skip_bytes) {
+		ssize_t skipped;
+
+		if (zip->uncompressed_buffer_bytes_remaining == 0) {
+			if (zip->pack_stream_inbytes_remaining > 0) {
+				r = extract_pack_stream(a, 0);
+				if (r < 0)
+					return (r);
+			} else if (zip->folder_outbytes_remaining > 0) {
+				/* Extract a remaining pack stream. */
+				r = extract_pack_stream(a, 0);
+				if (r < 0)
+					return (r);
+			} else {
+				archive_set_error(&a->archive,
+				    ARCHIVE_ERRNO_FILE_FORMAT,
+				    "Truncated 7-Zip file body");
+				return (ARCHIVE_FATAL);
+			}
+		}
+		skipped = get_uncompressed_data(
+			a, buff, (size_t)skip_bytes, 0);
+		if (skipped < 0)
+			return (skipped);
+		skip_bytes -= skipped;
+		if (zip->pack_stream_bytes_unconsumed)
+			read_consume(a);
+	}
+
+	return (get_uncompressed_data(a, buff, size, minimum));
+}
+
+static int
+setup_decode_folder(struct archive_read *a, struct _7z_folder *folder,
+    int header)
+{
+	struct _7zip *zip = (struct _7zip *)a->format->data;
+	const struct _7z_coder *coder1, *coder2;
+	const char *cname = (header)?"archive header":"file content";
+	unsigned i;
+	int r, found_bcj2 = 0;
+
+	/*
+	 * Release the memory which the previous folder used for BCJ2.
+	 */
+	for (i = 0; i < 3; i++) {
+		if (zip->sub_stream_buff[i] != NULL)
+			free(zip->sub_stream_buff[i]);
+		zip->sub_stream_buff[i] = NULL;
+	}
+
+	/*
+	 * Initialize a stream reader.
+	 */
+	zip->pack_stream_remaining = (unsigned)folder->numPackedStreams;
+	zip->pack_stream_index = (unsigned)folder->packIndex;
+	zip->folder_outbytes_remaining = folder_uncompressed_size(folder);
+	zip->uncompressed_buffer_bytes_remaining = 0;
+
+	/*
+	 * Check coder types.
+	 */
+	for (i = 0; i < folder->numCoders; i++) {
+		switch(folder->coders[i].codec) {
+			case _7Z_CRYPTO_MAIN_ZIP:
+			case _7Z_CRYPTO_RAR_29:
+			case _7Z_CRYPTO_AES_256_SHA_256: {
+				/* For entry that is associated with this folder, mark
+				   it as encrypted (data+metadata). */
+				zip->has_encrypted_entries = 1;
+				if (a->entry) {
+					archive_entry_set_is_data_encrypted(a->entry, 1);
+					archive_entry_set_is_metadata_encrypted(a->entry, 1);
+				}
+				archive_set_error(&(a->archive),
+					ARCHIVE_ERRNO_MISC,
+					"The %s is encrypted, "
+					"but currently not supported", cname);
+				return (ARCHIVE_FATAL);
+			}
+			case _7Z_X86_BCJ2: {
+				found_bcj2++;
+				break;
+			}
+		}
+	}
+	/* Now that we've checked for encryption, if there were still no
+	 * encrypted entries found we can say for sure that there are none.
+	 */
+	if (zip->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {
+		zip->has_encrypted_entries = 0;
+	}
+
+	if ((folder->numCoders > 2 && !found_bcj2) || found_bcj2 > 1) {
+		archive_set_error(&(a->archive),
+		    ARCHIVE_ERRNO_MISC,
+		    "The %s is encoded with many filters, "
+		    "but currently not supported", cname);
+		return (ARCHIVE_FATAL);
+	}
+	coder1 = &(folder->coders[0]);
+	if (folder->numCoders == 2)
+		coder2 = &(folder->coders[1]);
+	else
+		coder2 = NULL;
+
+	if (found_bcj2) {
+		/*
+		 * Preparation to decode BCJ2.
+		 * Decoding BCJ2 requires four sources. Those are at least,
+		 * as far as I know, two types of the storage form.
+		 */
+		const struct _7z_coder *fc = folder->coders;
+		static const struct _7z_coder coder_copy = {0, 1, 1, 0, NULL};
+		const struct _7z_coder *scoder[3] =
+			{&coder_copy, &coder_copy, &coder_copy};
+		const void *buff;
+		ssize_t bytes;
+		unsigned char *b[3] = {NULL, NULL, NULL};
+		uint64_t sunpack[3] ={-1, -1, -1};
+		size_t s[3] = {0, 0, 0};
+		int idx[3] = {0, 1, 2};
+
+		if (folder->numCoders == 4 && fc[3].codec == _7Z_X86_BCJ2 &&
+		    folder->numInStreams == 7 && folder->numOutStreams == 4 &&
+		    zip->pack_stream_remaining == 4) {
+			/* Source type 1 made by 7zr or 7z with -m options. */
+			if (folder->bindPairs[0].inIndex == 5) {
+				/* The form made by 7zr */
+				idx[0] = 1; idx[1] = 2; idx[2] = 0;
+				scoder[1] = &(fc[1]);
+				scoder[2] = &(fc[0]);
+				sunpack[1] = folder->unPackSize[1];
+				sunpack[2] = folder->unPackSize[0];
+				coder1 = &(fc[2]);
+			} else {
+				/*
+				 * NOTE: Some patterns do not work.
+				 * work:
+				 *  7z a -m0=BCJ2 -m1=COPY -m2=COPY
+				 *       -m3=(any)
+				 *  7z a -m0=BCJ2 -m1=COPY -m2=(any)
+				 *       -m3=COPY
+				 *  7z a -m0=BCJ2 -m1=(any) -m2=COPY
+				 *       -m3=COPY
+				 * not work:
+				 *  other patterns.
+				 *
+				 * We have to handle this like `pipe' or
+				 * our libarchive7s filter frame work,
+				 * decoding the BCJ2 main stream sequentially,
+				 * m3 -> m2 -> m1 -> BCJ2.
+				 *
+				 */
+				if (fc[0].codec == _7Z_COPY &&
+				    fc[1].codec == _7Z_COPY)
+					coder1 = &(folder->coders[2]);
+				else if (fc[0].codec == _7Z_COPY &&
+				    fc[2].codec == _7Z_COPY)
+					coder1 = &(folder->coders[1]);
+				else if (fc[1].codec == _7Z_COPY &&
+				    fc[2].codec == _7Z_COPY)
+					coder1 = &(folder->coders[0]);
+				else {
+					archive_set_error(&(a->archive),
+					    ARCHIVE_ERRNO_MISC,
+					    "Unsupported form of "
+					    "BCJ2 streams");
+					return (ARCHIVE_FATAL);
+				}
+			}
+			coder2 = &(fc[3]);
+			zip->main_stream_bytes_remaining =
+				(size_t)folder->unPackSize[2];
+		} else if (coder2 != NULL && coder2->codec == _7Z_X86_BCJ2 &&
+		    zip->pack_stream_remaining == 4 &&
+		    folder->numInStreams == 5 && folder->numOutStreams == 2) {
+			/* Source type 0 made by 7z */
+			zip->main_stream_bytes_remaining =
+				(size_t)folder->unPackSize[0];
+		} else {
+			/* We got an unexpected form. */
+			archive_set_error(&(a->archive),
+			    ARCHIVE_ERRNO_MISC,
+			    "Unsupported form of BCJ2 streams");
+			return (ARCHIVE_FATAL);
+		}
+
+		/* Skip the main stream at this time. */
+		if ((r = seek_pack(a)) < 0)
+			return (r);
+		zip->pack_stream_bytes_unconsumed =
+		    (size_t)zip->pack_stream_inbytes_remaining;
+		read_consume(a);
+
+		/* Read following three sub streams. */
+		for (i = 0; i < 3; i++) {
+			const struct _7z_coder *coder = scoder[i];
+
+			if ((r = seek_pack(a)) < 0) {
+				free(b[0]); free(b[1]); free(b[2]);
+				return (r);
+			}
+
+			if (sunpack[i] == (uint64_t)-1)
+				zip->folder_outbytes_remaining =
+				    zip->pack_stream_inbytes_remaining;
+			else
+				zip->folder_outbytes_remaining = sunpack[i];
+
+			r = init_decompression(a, zip, coder, NULL);
+			if (r != ARCHIVE_OK) {
+				free(b[0]); free(b[1]); free(b[2]);
+				return (ARCHIVE_FATAL);
+			}
+
+			/* Allocate memory for the decoded data of a sub
+			 * stream. */
+			b[i] = malloc((size_t)zip->folder_outbytes_remaining);
+			if (b[i] == NULL) {
+				free(b[0]); free(b[1]); free(b[2]);
+				archive_set_error(&a->archive, ENOMEM,
+				    "No memory for 7-Zip decompression");
+				return (ARCHIVE_FATAL);
+			}
+
+			/* Extract a sub stream. */
+			while (zip->pack_stream_inbytes_remaining > 0) {
+				r = (int)extract_pack_stream(a, 0);
+				if (r < 0) {
+					free(b[0]); free(b[1]); free(b[2]);
+					return (r);
+				}
+				bytes = get_uncompressed_data(a, &buff,
+				    zip->uncompressed_buffer_bytes_remaining,
+				    0);
+				if (bytes < 0) {
+					free(b[0]); free(b[1]); free(b[2]);
+					return ((int)bytes);
+				}
+				memcpy(b[i]+s[i], buff, bytes);
+				s[i] += bytes;
+				if (zip->pack_stream_bytes_unconsumed)
+					read_consume(a);
+			}
+		}
+
+		/* Set the sub streams to the right place. */
+		for (i = 0; i < 3; i++) {
+			zip->sub_stream_buff[i] = b[idx[i]];
+			zip->sub_stream_size[i] = s[idx[i]];
+			zip->sub_stream_bytes_remaining[i] = s[idx[i]];
+		}
+
+		/* Allocate memory used for decoded main stream bytes. */
+		if (zip->tmp_stream_buff == NULL) {
+			zip->tmp_stream_buff_size = 32 * 1024;
+			zip->tmp_stream_buff =
+			    malloc(zip->tmp_stream_buff_size);
+			if (zip->tmp_stream_buff == NULL) {
+				archive_set_error(&a->archive, ENOMEM,
+				    "No memory for 7-Zip decompression");
+				return (ARCHIVE_FATAL);
+			}
+		}
+		zip->tmp_stream_bytes_avail = 0;
+		zip->tmp_stream_bytes_remaining = 0;
+		zip->odd_bcj_size = 0;
+		zip->bcj2_outPos = 0;
+
+		/*
+		 * Reset a stream reader in order to read the main stream
+		 * of BCJ2.
+		 */
+		zip->pack_stream_remaining = 1;
+		zip->pack_stream_index = (unsigned)folder->packIndex;
+		zip->folder_outbytes_remaining =
+		    folder_uncompressed_size(folder);
+		zip->uncompressed_buffer_bytes_remaining = 0;
+	}
+
+	/*
+	 * Initialize the decompressor for the new folder's pack streams.
+	 */
+	r = init_decompression(a, zip, coder1, coder2);
+	if (r != ARCHIVE_OK)
+		return (ARCHIVE_FATAL);
+	return (ARCHIVE_OK);
+}
+
+static int64_t
+skip_stream(struct archive_read *a, size_t skip_bytes)
+{
+	struct _7zip *zip = (struct _7zip *)a->format->data;
+	const void *p;
+	int64_t skipped_bytes;
+	size_t bytes = skip_bytes;
+
+	if (zip->folder_index == 0) {
+		/*
+		 * Optimization for a list mode.
+		 * Avoid unnecessary decoding operations.
+		 */
+		zip->si.ci.folders[zip->entry->folderIndex].skipped_bytes
+		    += skip_bytes;
+		return (skip_bytes);
+	}
+
+	while (bytes) {
+		skipped_bytes = read_stream(a, &p, bytes, 0);
+		if (skipped_bytes < 0)
+			return (skipped_bytes);
+		if (skipped_bytes == 0) {
+			archive_set_error(&a->archive,
+			    ARCHIVE_ERRNO_FILE_FORMAT,
+			    "Truncated 7-Zip file body");
+			return (ARCHIVE_FATAL);
+		}
+		bytes -= (size_t)skipped_bytes;
+		if (zip->pack_stream_bytes_unconsumed)
+			read_consume(a);
+	}
+	return (skip_bytes);
+}
+
+/*
+ * Brought from LZMA SDK.
+ *
+ * Bra86.c -- Converter for x86 code (BCJ)
+ * 2008-10-04 : Igor Pavlov : Public domain
+ *
+ */
+
+#define Test86MSByte(b) ((b) == 0 || (b) == 0xFF)
+
+static void
+x86_Init(struct _7zip *zip)
+{
+	zip->bcj_state = 0;
+	zip->bcj_prevPosT = (size_t)0 - 1;
+	zip->bcj_prevMask = 0;
+	zip->bcj_ip = 5;
+}
+
+static size_t
+x86_Convert(struct _7zip *zip, uint8_t *data, size_t size)
+{
+	static const uint8_t kMaskToAllowedStatus[8] = {1, 1, 1, 0, 1, 0, 0, 0};
+	static const uint8_t kMaskToBitNumber[8] = {0, 1, 2, 2, 3, 3, 3, 3};
+	size_t bufferPos, prevPosT;
+	uint32_t ip, prevMask;
+
+	if (size < 5)
+		return 0;
+
+	bufferPos = 0;
+	prevPosT = zip->bcj_prevPosT;
+	prevMask = zip->bcj_prevMask;
+	ip = zip->bcj_ip;
+
+	for (;;) {
+		uint8_t *p = data + bufferPos;
+		uint8_t *limit = data + size - 4;
+
+		for (; p < limit; p++)
+			if ((*p & 0xFE) == 0xE8)
+				break;
+		bufferPos = (size_t)(p - data);
+		if (p >= limit)
+			break;
+		prevPosT = bufferPos - prevPosT;
+		if (prevPosT > 3)
+			prevMask = 0;
+		else {
+			prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;
+			if (prevMask != 0) {
+				unsigned char b =
+					p[4 - kMaskToBitNumber[prevMask]];
+				if (!kMaskToAllowedStatus[prevMask] ||
+				    Test86MSByte(b)) {
+					prevPosT = bufferPos;
+					prevMask = ((prevMask << 1) & 0x7) | 1;
+					bufferPos++;
+					continue;
+				}
+			}
+		}
+		prevPosT = bufferPos;
+
+		if (Test86MSByte(p[4])) {
+			uint32_t src = ((uint32_t)p[4] << 24) |
+				((uint32_t)p[3] << 16) | ((uint32_t)p[2] << 8) |
+				((uint32_t)p[1]);
+			uint32_t dest;
+			for (;;) {
+				uint8_t b;
+				int b_index;
+
+				dest = src - (ip + (uint32_t)bufferPos);
+				if (prevMask == 0)
+					break;
+				b_index = kMaskToBitNumber[prevMask] * 8;
+				b = (uint8_t)(dest >> (24 - b_index));
+				if (!Test86MSByte(b))
+					break;
+				src = dest ^ ((1 << (32 - b_index)) - 1);
+			}
+			p[4] = (uint8_t)(~(((dest >> 24) & 1) - 1));
+			p[3] = (uint8_t)(dest >> 16);
+			p[2] = (uint8_t)(dest >> 8);
+			p[1] = (uint8_t)dest;
+			bufferPos += 5;
+		} else {
+			prevMask = ((prevMask << 1) & 0x7) | 1;
+			bufferPos++;
+		}
+	}
+	zip->bcj_prevPosT = prevPosT;
+	zip->bcj_prevMask = prevMask;
+	zip->bcj_ip += (uint32_t)bufferPos;
+	return (bufferPos);
+}
+
+/*
+ * Brought from LZMA SDK.
+ *
+ * Bcj2.c -- Converter for x86 code (BCJ2)
+ * 2008-10-04 : Igor Pavlov : Public domain
+ *
+ */
+
+#define SZ_ERROR_DATA	 ARCHIVE_FAILED
+
+#define IsJcc(b0, b1) ((b0) == 0x0F && ((b1) & 0xF0) == 0x80)
+#define IsJ(b0, b1) ((b1 & 0xFE) == 0xE8 || IsJcc(b0, b1))
+
+#define kNumTopBits 24
+#define kTopValue ((uint32_t)1 << kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 << kNumBitModelTotalBits)
+#define kNumMoveBits 5
+
+#define RC_READ_BYTE (*buffer++)
+#define RC_TEST { if (buffer == bufferLim) return SZ_ERROR_DATA; }
+#define RC_INIT2 zip->bcj2_code = 0; zip->bcj2_range = 0xFFFFFFFF; \
+  { int ii; for (ii = 0; ii < 5; ii++) { RC_TEST; zip->bcj2_code = (zip->bcj2_code << 8) | RC_READ_BYTE; }}
+
+#define NORMALIZE if (zip->bcj2_range < kTopValue) { RC_TEST; zip->bcj2_range <<= 8; zip->bcj2_code = (zip->bcj2_code << 8) | RC_READ_BYTE; }
+
+#define IF_BIT_0(p) ttt = *(p); bound = (zip->bcj2_range >> kNumBitModelTotalBits) * ttt; if (zip->bcj2_code < bound)
+#define UPDATE_0(p) zip->bcj2_range = bound; *(p) = (CProb)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits)); NORMALIZE;
+#define UPDATE_1(p) zip->bcj2_range -= bound; zip->bcj2_code -= bound; *(p) = (CProb)(ttt - (ttt >> kNumMoveBits)); NORMALIZE;
+
+static ssize_t
+Bcj2_Decode(struct _7zip *zip, uint8_t *outBuf, size_t outSize)
+{
+	size_t inPos = 0, outPos = 0;
+	const uint8_t *buf0, *buf1, *buf2, *buf3;
+	size_t size0, size1, size2, size3;
+	const uint8_t *buffer, *bufferLim;
+	unsigned int i, j;
+
+	size0 = zip->tmp_stream_bytes_remaining;
+	buf0 = zip->tmp_stream_buff + zip->tmp_stream_bytes_avail - size0;
+	size1 = zip->sub_stream_bytes_remaining[0];
+	buf1 = zip->sub_stream_buff[0] + zip->sub_stream_size[0] - size1;
+	size2 = zip->sub_stream_bytes_remaining[1];
+	buf2 = zip->sub_stream_buff[1] + zip->sub_stream_size[1] - size2;
+	size3 = zip->sub_stream_bytes_remaining[2];
+	buf3 = zip->sub_stream_buff[2] + zip->sub_stream_size[2] - size3;
+
+	buffer = buf3;
+	bufferLim = buffer + size3;
+
+	if (zip->bcj_state == 0) {
+		/*
+		 * Initialize.
+		 */
+		zip->bcj2_prevByte = 0;
+		for (i = 0;
+		    i < sizeof(zip->bcj2_p) / sizeof(zip->bcj2_p[0]); i++)
+			zip->bcj2_p[i] = kBitModelTotal >> 1;
+		RC_INIT2;
+		zip->bcj_state = 1;
+	}
+
+	/*
+	 * Gather the odd bytes of a previous call.
+	 */
+	for (i = 0; zip->odd_bcj_size > 0 && outPos < outSize; i++) {
+		outBuf[outPos++] = zip->odd_bcj[i];
+		zip->odd_bcj_size--;
+	}
+
+	if (outSize == 0) {
+		zip->bcj2_outPos += outPos;
+		return (outPos);
+	}
+
+	for (;;) {
+		uint8_t b;
+		CProb *prob;
+		uint32_t bound;
+		uint32_t ttt;
+
+		size_t limit = size0 - inPos;
+		if (outSize - outPos < limit)
+			limit = outSize - outPos;
+
+		if (zip->bcj_state == 1) {
+			while (limit != 0) {
+				uint8_t bb = buf0[inPos];
+				outBuf[outPos++] = bb;
+				if (IsJ(zip->bcj2_prevByte, bb)) {
+					zip->bcj_state = 2;
+					break;
+				}
+				inPos++;
+				zip->bcj2_prevByte = bb;
+				limit--;
+			}
+		}
+
+		if (limit == 0 || outPos == outSize)
+			break;
+		zip->bcj_state = 1;
+
+		b = buf0[inPos++];
+
+		if (b == 0xE8)
+			prob = zip->bcj2_p + zip->bcj2_prevByte;
+		else if (b == 0xE9)
+			prob = zip->bcj2_p + 256;
+		else
+			prob = zip->bcj2_p + 257;
+
+		IF_BIT_0(prob) {
+			UPDATE_0(prob)
+			zip->bcj2_prevByte = b;
+		} else {
+			uint32_t dest;
+			const uint8_t *v;
+			uint8_t out[4];
+
+			UPDATE_1(prob)
+			if (b == 0xE8) {
+				v = buf1;
+				if (size1 < 4)
+					return SZ_ERROR_DATA;
+				buf1 += 4;
+				size1 -= 4;
+			} else {
+				v = buf2;
+				if (size2 < 4)
+					return SZ_ERROR_DATA;
+				buf2 += 4;
+				size2 -= 4;
+			}
+			dest = (((uint32_t)v[0] << 24) |
+			    ((uint32_t)v[1] << 16) |
+			    ((uint32_t)v[2] << 8) |
+			    ((uint32_t)v[3])) -
+			    ((uint32_t)zip->bcj2_outPos + (uint32_t)outPos + 4);
+			out[0] = (uint8_t)dest;
+			out[1] = (uint8_t)(dest >> 8);
+			out[2] = (uint8_t)(dest >> 16);
+			out[3] = zip->bcj2_prevByte = (uint8_t)(dest >> 24);
+
+			for (i = 0; i < 4 && outPos < outSize; i++)
+				outBuf[outPos++] = out[i];
+			if (i < 4) {
+				/*
+				 * Save odd bytes which we could not add into
+				 * the output buffer because of out of space.
+				 */
+				zip->odd_bcj_size = 4 -i;
+				for (; i < 4; i++) {
+					j = i - 4 + (unsigned)zip->odd_bcj_size;
+					zip->odd_bcj[j] = out[i];
+				}
+				break;
+			}
+		}
+	}
+	zip->tmp_stream_bytes_remaining -= inPos;
+	zip->sub_stream_bytes_remaining[0] = size1;
+	zip->sub_stream_bytes_remaining[1] = size2;
+	zip->sub_stream_bytes_remaining[2] = bufferLim - buffer;
+	zip->bcj2_outPos += outPos;
+
+	return ((ssize_t)outPos);
+}
+
--- libarchive-3.3.3/libarchive/archive_read_support_format_cab.c
+++ libarchive-nenuzhnix/libarchive/archive_read_support_format_cab.c
@@ -1433,9 +1433,10 @@
 		cab->stream.next_out = NULL;
 		cab->stream.avail_out = 0;
 		cab->stream.total_out = 0;
-		if (cab->stream_valid)
-			r = inflateReset(&cab->stream);
-		else
+		if (cab->stream_valid) {
+			inflateReset(&cab->stream);
+			r = Z_OK;
+		} else
 			r = inflateInit2(&cab->stream,
 			    -15 /* Don't check for zlib header */);
 		if (r != Z_OK) {
@@ -1577,13 +1578,14 @@
 	 */
 	if (cab->entry_cffolder->cfdata_index <
 	    cab->entry_cffolder->cfdata_count) {
-		r = inflateReset(&cab->stream);
+		inflateReset(&cab->stream);
+		r = Z_OK;
 		if (r != Z_OK)
 			goto zlibfailed;
-		r = inflateSetDictionary(&cab->stream,
+		/*r = inflateSetDictionary(&cab->stream,
 		    cab->uncompressed_buffer, cfdata->uncompressed_size);
 		if (r != Z_OK)
-			goto zlibfailed;
+			goto zlibfailed;*/
 	}
 
 	d = cab->uncompressed_buffer + cfdata->read_offset;
--- libarchive-3.3.3/libarchive/archive_read_support_format_iso9660.c
+++ libarchive-nenuzhnix/libarchive/archive_read_support_format_iso9660.c
@@ -1568,9 +1568,10 @@
 		zisofs->block_off += 4;
 
 		/* Initialize compression library for new block. */
-		if (zisofs->stream_valid)
-			r = inflateReset(&zisofs->stream);
-		else
+		if (zisofs->stream_valid) {
+			inflateReset(&zisofs->stream);
+			r = Z_OK;
+		} else
 			r = inflateInit(&zisofs->stream);
 		if (r != Z_OK) {
 			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
--- /dev/null
+++ libarchive-nenuzhnix/libarchive/archive_read_support_format_iso9660.c.orig
@@ -0,0 +1,3271 @@
+/*-
+ * Copyright (c) 2003-2007 Tim Kientzle
+ * Copyright (c) 2009 Andreas Henriksson <andreas@fatal.se>
+ * Copyright (c) 2009-2012 Michihiro NAKAJIMA
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "archive_platform.h"
+__FBSDID("$FreeBSD: head/lib/libarchive/archive_read_support_format_iso9660.c 201246 2009-12-30 05:30:35Z kientzle $");
+
+#ifdef HAVE_ERRNO_H
+#include <errno.h>
+#endif
+/* #include <stdint.h> */ /* See archive_platform.h */
+#include <stdio.h>
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#include <time.h>
+#ifdef HAVE_ZLIB_H
+#include <zlib.h>
+#endif
+
+#include "archive.h"
+#include "archive_endian.h"
+#include "archive_entry.h"
+#include "archive_entry_locale.h"
+#include "archive_private.h"
+#include "archive_read_private.h"
+#include "archive_string.h"
+
+/*
+ * An overview of ISO 9660 format:
+ *
+ * Each disk is laid out as follows:
+ *   * 32k reserved for private use
+ *   * Volume descriptor table.  Each volume descriptor
+ *     is 2k and specifies basic format information.
+ *     The "Primary Volume Descriptor" (PVD) is defined by the
+ *     standard and should always be present; other volume
+ *     descriptors include various vendor-specific extensions.
+ *   * Files and directories.  Each file/dir is specified by
+ *     an "extent" (starting sector and length in bytes).
+ *     Dirs are just files with directory records packed one
+ *     after another.  The PVD contains a single dir entry
+ *     specifying the location of the root directory.  Everything
+ *     else follows from there.
+ *
+ * This module works by first reading the volume descriptors, then
+ * building a list of directory entries, sorted by starting
+ * sector.  At each step, I look for the earliest dir entry that
+ * hasn't yet been read, seek forward to that location and read
+ * that entry.  If it's a dir, I slurp in the new dir entries and
+ * add them to the heap; if it's a regular file, I return the
+ * corresponding archive_entry and wait for the client to request
+ * the file body.  This strategy allows us to read most compliant
+ * CDs with a single pass through the data, as required by libarchive.
+ */
+#define	LOGICAL_BLOCK_SIZE	2048
+#define	SYSTEM_AREA_BLOCK	16
+
+/* Structure of on-disk primary volume descriptor. */
+#define PVD_type_offset 0
+#define PVD_type_size 1
+#define PVD_id_offset (PVD_type_offset + PVD_type_size)
+#define PVD_id_size 5
+#define PVD_version_offset (PVD_id_offset + PVD_id_size)
+#define PVD_version_size 1
+#define PVD_reserved1_offset (PVD_version_offset + PVD_version_size)
+#define PVD_reserved1_size 1
+#define PVD_system_id_offset (PVD_reserved1_offset + PVD_reserved1_size)
+#define PVD_system_id_size 32
+#define PVD_volume_id_offset (PVD_system_id_offset + PVD_system_id_size)
+#define PVD_volume_id_size 32
+#define PVD_reserved2_offset (PVD_volume_id_offset + PVD_volume_id_size)
+#define PVD_reserved2_size 8
+#define PVD_volume_space_size_offset (PVD_reserved2_offset + PVD_reserved2_size)
+#define PVD_volume_space_size_size 8
+#define PVD_reserved3_offset (PVD_volume_space_size_offset + PVD_volume_space_size_size)
+#define PVD_reserved3_size 32
+#define PVD_volume_set_size_offset (PVD_reserved3_offset + PVD_reserved3_size)
+#define PVD_volume_set_size_size 4
+#define PVD_volume_sequence_number_offset (PVD_volume_set_size_offset + PVD_volume_set_size_size)
+#define PVD_volume_sequence_number_size 4
+#define PVD_logical_block_size_offset (PVD_volume_sequence_number_offset + PVD_volume_sequence_number_size)
+#define PVD_logical_block_size_size 4
+#define PVD_path_table_size_offset (PVD_logical_block_size_offset + PVD_logical_block_size_size)
+#define PVD_path_table_size_size 8
+#define PVD_type_1_path_table_offset (PVD_path_table_size_offset + PVD_path_table_size_size)
+#define PVD_type_1_path_table_size 4
+#define PVD_opt_type_1_path_table_offset (PVD_type_1_path_table_offset + PVD_type_1_path_table_size)
+#define PVD_opt_type_1_path_table_size 4
+#define PVD_type_m_path_table_offset (PVD_opt_type_1_path_table_offset + PVD_opt_type_1_path_table_size)
+#define PVD_type_m_path_table_size 4
+#define PVD_opt_type_m_path_table_offset (PVD_type_m_path_table_offset + PVD_type_m_path_table_size)
+#define PVD_opt_type_m_path_table_size 4
+#define PVD_root_directory_record_offset (PVD_opt_type_m_path_table_offset + PVD_opt_type_m_path_table_size)
+#define PVD_root_directory_record_size 34
+#define PVD_volume_set_id_offset (PVD_root_directory_record_offset + PVD_root_directory_record_size)
+#define PVD_volume_set_id_size 128
+#define PVD_publisher_id_offset (PVD_volume_set_id_offset + PVD_volume_set_id_size)
+#define PVD_publisher_id_size 128
+#define PVD_preparer_id_offset (PVD_publisher_id_offset + PVD_publisher_id_size)
+#define PVD_preparer_id_size 128
+#define PVD_application_id_offset (PVD_preparer_id_offset + PVD_preparer_id_size)
+#define PVD_application_id_size 128
+#define PVD_copyright_file_id_offset (PVD_application_id_offset + PVD_application_id_size)
+#define PVD_copyright_file_id_size 37
+#define PVD_abstract_file_id_offset (PVD_copyright_file_id_offset + PVD_copyright_file_id_size)
+#define PVD_abstract_file_id_size 37
+#define PVD_bibliographic_file_id_offset (PVD_abstract_file_id_offset + PVD_abstract_file_id_size)
+#define PVD_bibliographic_file_id_size 37
+#define PVD_creation_date_offset (PVD_bibliographic_file_id_offset + PVD_bibliographic_file_id_size)
+#define PVD_creation_date_size 17
+#define PVD_modification_date_offset (PVD_creation_date_offset + PVD_creation_date_size)
+#define PVD_modification_date_size 17
+#define PVD_expiration_date_offset (PVD_modification_date_offset + PVD_modification_date_size)
+#define PVD_expiration_date_size 17
+#define PVD_effective_date_offset (PVD_expiration_date_offset + PVD_expiration_date_size)
+#define PVD_effective_date_size 17
+#define PVD_file_structure_version_offset (PVD_effective_date_offset + PVD_effective_date_size)
+#define PVD_file_structure_version_size 1
+#define PVD_reserved4_offset (PVD_file_structure_version_offset + PVD_file_structure_version_size)
+#define PVD_reserved4_size 1
+#define PVD_application_data_offset (PVD_reserved4_offset + PVD_reserved4_size)
+#define PVD_application_data_size 512
+#define PVD_reserved5_offset (PVD_application_data_offset + PVD_application_data_size)
+#define PVD_reserved5_size (2048 - PVD_reserved5_offset)
+
+/* TODO: It would make future maintenance easier to just hardcode the
+ * above values.  In particular, ECMA119 states the offsets as part of
+ * the standard.  That would eliminate the need for the following check.*/
+#if PVD_reserved5_offset != 1395
+#error PVD offset and size definitions are wrong.
+#endif
+
+
+/* Structure of optional on-disk supplementary volume descriptor. */
+#define SVD_type_offset 0
+#define SVD_type_size 1
+#define SVD_id_offset (SVD_type_offset + SVD_type_size)
+#define SVD_id_size 5
+#define SVD_version_offset (SVD_id_offset + SVD_id_size)
+#define SVD_version_size 1
+/* ... */
+#define SVD_reserved1_offset	72
+#define SVD_reserved1_size	8
+#define SVD_volume_space_size_offset 80
+#define SVD_volume_space_size_size 8
+#define SVD_escape_sequences_offset (SVD_volume_space_size_offset + SVD_volume_space_size_size)
+#define SVD_escape_sequences_size 32
+/* ... */
+#define SVD_logical_block_size_offset 128
+#define SVD_logical_block_size_size 4
+#define SVD_type_L_path_table_offset 140
+#define SVD_type_M_path_table_offset 148
+/* ... */
+#define SVD_root_directory_record_offset 156
+#define SVD_root_directory_record_size 34
+#define SVD_file_structure_version_offset 881
+#define SVD_reserved2_offset	882
+#define SVD_reserved2_size	1
+#define SVD_reserved3_offset	1395
+#define SVD_reserved3_size	653
+/* ... */
+/* FIXME: validate correctness of last SVD entry offset. */
+
+/* Structure of an on-disk directory record. */
+/* Note:  ISO9660 stores each multi-byte integer twice, once in
+ * each byte order.  The sizes here are the size of just one
+ * of the two integers.  (This is why the offset of a field isn't
+ * the same as the offset+size of the previous field.) */
+#define DR_length_offset 0
+#define DR_length_size 1
+#define DR_ext_attr_length_offset 1
+#define DR_ext_attr_length_size 1
+#define DR_extent_offset 2
+#define DR_extent_size 4
+#define DR_size_offset 10
+#define DR_size_size 4
+#define DR_date_offset 18
+#define DR_date_size 7
+#define DR_flags_offset 25
+#define DR_flags_size 1
+#define DR_file_unit_size_offset 26
+#define DR_file_unit_size_size 1
+#define DR_interleave_offset 27
+#define DR_interleave_size 1
+#define DR_volume_sequence_number_offset 28
+#define DR_volume_sequence_number_size 2
+#define DR_name_len_offset 32
+#define DR_name_len_size 1
+#define DR_name_offset 33
+
+#ifdef HAVE_ZLIB_H
+static const unsigned char zisofs_magic[8] = {
+	0x37, 0xE4, 0x53, 0x96, 0xC9, 0xDB, 0xD6, 0x07
+};
+
+struct zisofs {
+	/* Set 1 if this file compressed by paged zlib */
+	int		 pz;
+	int		 pz_log2_bs; /* Log2 of block size */
+	uint64_t	 pz_uncompressed_size;
+
+	int		 initialized;
+	unsigned char	*uncompressed_buffer;
+	size_t		 uncompressed_buffer_size;
+
+	uint32_t	 pz_offset;
+	unsigned char	 header[16];
+	size_t		 header_avail;
+	int		 header_passed;
+	unsigned char	*block_pointers;
+	size_t		 block_pointers_alloc;
+	size_t		 block_pointers_size;
+	size_t		 block_pointers_avail;
+	size_t		 block_off;
+	uint32_t	 block_avail;
+
+	z_stream	 stream;
+	int		 stream_valid;
+};
+#else
+struct zisofs {
+	/* Set 1 if this file compressed by paged zlib */
+	int		 pz;
+};
+#endif
+
+struct content {
+	uint64_t	 offset;/* Offset on disk.		*/
+	uint64_t	 size;	/* File size in bytes.		*/
+	struct content	*next;
+};
+
+/* In-memory storage for a directory record. */
+struct file_info {
+	struct file_info	*use_next;
+	struct file_info	*parent;
+	struct file_info	*next;
+	struct file_info	*re_next;
+	int		 subdirs;
+	uint64_t	 key;		/* Heap Key.			*/
+	uint64_t	 offset;	/* Offset on disk.		*/
+	uint64_t	 size;		/* File size in bytes.		*/
+	uint32_t	 ce_offset;	/* Offset of CE.		*/
+	uint32_t	 ce_size;	/* Size of CE.			*/
+	char		 rr_moved;	/* Flag to rr_moved.		*/
+	char		 rr_moved_has_re_only;
+	char		 re;		/* Having RRIP "RE" extension.	*/
+	char		 re_descendant;
+	uint64_t	 cl_offset;	/* Having RRIP "CL" extension.	*/
+	int		 birthtime_is_set;
+	time_t		 birthtime;	/* File created time.		*/
+	time_t		 mtime;		/* File last modified time.	*/
+	time_t		 atime;		/* File last accessed time.	*/
+	time_t		 ctime;		/* File attribute change time.	*/
+	uint64_t	 rdev;		/* Device number.		*/
+	mode_t		 mode;
+	uid_t		 uid;
+	gid_t		 gid;
+	int64_t		 number;
+	int		 nlinks;
+	struct archive_string name; /* Pathname */
+	unsigned char	*utf16be_name;
+	size_t		 utf16be_bytes;
+	char		 name_continues; /* Non-zero if name continues */
+	struct archive_string symlink;
+	char		 symlink_continues; /* Non-zero if link continues */
+	/* Set 1 if this file compressed by paged zlib(zisofs) */
+	int		 pz;
+	int		 pz_log2_bs; /* Log2 of block size */
+	uint64_t	 pz_uncompressed_size;
+	/* Set 1 if this file is multi extent. */
+	int		 multi_extent;
+	struct {
+		struct content	*first;
+		struct content	**last;
+	} contents;
+	struct {
+		struct file_info	*first;
+		struct file_info	**last;
+	} rede_files;
+};
+
+struct heap_queue {
+	struct file_info **files;
+	int		 allocated;
+	int		 used;
+};
+
+struct iso9660 {
+	int	magic;
+#define ISO9660_MAGIC   0x96609660
+
+	int opt_support_joliet;
+	int opt_support_rockridge;
+
+	struct archive_string pathname;
+	char	seenRockridge;	/* Set true if RR extensions are used. */
+	char	seenSUSP;	/* Set true if SUSP is being used. */
+	char	seenJoliet;
+
+	unsigned char	suspOffset;
+	struct file_info *rr_moved;
+	struct read_ce_queue {
+		struct read_ce_req {
+			uint64_t	 offset;/* Offset of CE on disk. */
+			struct file_info *file;
+		}		*reqs;
+		int		 cnt;
+		int		 allocated;
+	}	read_ce_req;
+
+	int64_t		previous_number;
+	struct archive_string previous_pathname;
+
+	struct file_info		*use_files;
+	struct heap_queue		 pending_files;
+	struct {
+		struct file_info	*first;
+		struct file_info	**last;
+	}	cache_files;
+	struct {
+		struct file_info	*first;
+		struct file_info	**last;
+	}	re_files;
+
+	uint64_t current_position;
+	ssize_t	logical_block_size;
+	uint64_t volume_size; /* Total size of volume in bytes. */
+	int32_t  volume_block;/* Total size of volume in logical blocks. */
+
+	struct vd {
+		int		location;	/* Location of Extent.	*/
+		uint32_t	size;
+	} primary, joliet;
+
+	int64_t	entry_sparse_offset;
+	int64_t	entry_bytes_remaining;
+	size_t  entry_bytes_unconsumed;
+	struct zisofs	 entry_zisofs;
+	struct content	*entry_content;
+	struct archive_string_conv *sconv_utf16be;
+	/*
+	 * Buffers for a full pathname in UTF-16BE in Joliet extensions.
+	 */
+#define UTF16_NAME_MAX	1024
+	unsigned char *utf16be_path;
+	size_t		 utf16be_path_len;
+	unsigned char *utf16be_previous_path;
+	size_t		 utf16be_previous_path_len;
+	/* Null buffer used in bidder to improve its performance. */
+	unsigned char	 null[2048];
+};
+
+static int	archive_read_format_iso9660_bid(struct archive_read *, int);
+static int	archive_read_format_iso9660_options(struct archive_read *,
+		    const char *, const char *);
+static int	archive_read_format_iso9660_cleanup(struct archive_read *);
+static int	archive_read_format_iso9660_read_data(struct archive_read *,
+		    const void **, size_t *, int64_t *);
+static int	archive_read_format_iso9660_read_data_skip(struct archive_read *);
+static int	archive_read_format_iso9660_read_header(struct archive_read *,
+		    struct archive_entry *);
+static const char *build_pathname(struct archive_string *, struct file_info *, int);
+static int	build_pathname_utf16be(unsigned char *, size_t, size_t *,
+		    struct file_info *);
+#if DEBUG
+static void	dump_isodirrec(FILE *, const unsigned char *isodirrec);
+#endif
+static time_t	time_from_tm(struct tm *);
+static time_t	isodate17(const unsigned char *);
+static time_t	isodate7(const unsigned char *);
+static int	isBootRecord(struct iso9660 *, const unsigned char *);
+static int	isVolumePartition(struct iso9660 *, const unsigned char *);
+static int	isVDSetTerminator(struct iso9660 *, const unsigned char *);
+static int	isJolietSVD(struct iso9660 *, const unsigned char *);
+static int	isSVD(struct iso9660 *, const unsigned char *);
+static int	isEVD(struct iso9660 *, const unsigned char *);
+static int	isPVD(struct iso9660 *, const unsigned char *);
+static int	next_cache_entry(struct archive_read *, struct iso9660 *,
+		    struct file_info **);
+static int	next_entry_seek(struct archive_read *, struct iso9660 *,
+		    struct file_info **);
+static struct file_info *
+		parse_file_info(struct archive_read *a,
+		    struct file_info *parent, const unsigned char *isodirrec,
+		    size_t reclen);
+static int	parse_rockridge(struct archive_read *a,
+		    struct file_info *file, const unsigned char *start,
+		    const unsigned char *end);
+static int	register_CE(struct archive_read *a, int32_t location,
+		    struct file_info *file);
+static int	read_CE(struct archive_read *a, struct iso9660 *iso9660);
+static void	parse_rockridge_NM1(struct file_info *,
+		    const unsigned char *, int);
+static void	parse_rockridge_SL1(struct file_info *,
+		    const unsigned char *, int);
+static void	parse_rockridge_TF1(struct file_info *,
+		    const unsigned char *, int);
+static void	parse_rockridge_ZF1(struct file_info *,
+		    const unsigned char *, int);
+static void	register_file(struct iso9660 *, struct file_info *);
+static void	release_files(struct iso9660 *);
+static unsigned	toi(const void *p, int n);
+static inline void re_add_entry(struct iso9660 *, struct file_info *);
+static inline struct file_info * re_get_entry(struct iso9660 *);
+static inline int rede_add_entry(struct file_info *);
+static inline struct file_info * rede_get_entry(struct file_info *);
+static inline void cache_add_entry(struct iso9660 *iso9660,
+		    struct file_info *file);
+static inline struct file_info *cache_get_entry(struct iso9660 *iso9660);
+static int	heap_add_entry(struct archive_read *a, struct heap_queue *heap,
+		    struct file_info *file, uint64_t key);
+static struct file_info *heap_get_entry(struct heap_queue *heap);
+
+#define add_entry(arch, iso9660, file)	\
+	heap_add_entry(arch, &((iso9660)->pending_files), file, file->offset)
+#define next_entry(iso9660)		\
+	heap_get_entry(&((iso9660)->pending_files))
+
+int
+archive_read_support_format_iso9660(struct archive *_a)
+{
+	struct archive_read *a = (struct archive_read *)_a;
+	struct iso9660 *iso9660;
+	int r;
+
+	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
+	    ARCHIVE_STATE_NEW, "archive_read_support_format_iso9660");
+
+	iso9660 = (struct iso9660 *)calloc(1, sizeof(*iso9660));
+	if (iso9660 == NULL) {
+		archive_set_error(&a->archive, ENOMEM,
+		    "Can't allocate iso9660 data");
+		return (ARCHIVE_FATAL);
+	}
+	iso9660->magic = ISO9660_MAGIC;
+	iso9660->cache_files.first = NULL;
+	iso9660->cache_files.last = &(iso9660->cache_files.first);
+	iso9660->re_files.first = NULL;
+	iso9660->re_files.last = &(iso9660->re_files.first);
+	/* Enable to support Joliet extensions by default.	*/
+	iso9660->opt_support_joliet = 1;
+	/* Enable to support Rock Ridge extensions by default.	*/
+	iso9660->opt_support_rockridge = 1;
+
+	r = __archive_read_register_format(a,
+	    iso9660,
+	    "iso9660",
+	    archive_read_format_iso9660_bid,
+	    archive_read_format_iso9660_options,
+	    archive_read_format_iso9660_read_header,
+	    archive_read_format_iso9660_read_data,
+	    archive_read_format_iso9660_read_data_skip,
+	    NULL,
+	    archive_read_format_iso9660_cleanup,
+	    NULL,
+	    NULL);
+
+	if (r != ARCHIVE_OK) {
+		free(iso9660);
+		return (r);
+	}
+	return (ARCHIVE_OK);
+}
+
+
+static int
+archive_read_format_iso9660_bid(struct archive_read *a, int best_bid)
+{
+	struct iso9660 *iso9660;
+	ssize_t bytes_read;
+	const unsigned char *p;
+	int seenTerminator;
+
+	/* If there's already a better bid than we can ever
+	   make, don't bother testing. */
+	if (best_bid > 48)
+		return (-1);
+
+	iso9660 = (struct iso9660 *)(a->format->data);
+
+	/*
+	 * Skip the first 32k (reserved area) and get the first
+	 * 8 sectors of the volume descriptor table.  Of course,
+	 * if the I/O layer gives us more, we'll take it.
+	 */
+#define RESERVED_AREA	(SYSTEM_AREA_BLOCK * LOGICAL_BLOCK_SIZE)
+	p = __archive_read_ahead(a,
+	    RESERVED_AREA + 8 * LOGICAL_BLOCK_SIZE,
+	    &bytes_read);
+	if (p == NULL)
+	    return (-1);
+
+	/* Skip the reserved area. */
+	bytes_read -= RESERVED_AREA;
+	p += RESERVED_AREA;
+
+	/* Check each volume descriptor. */
+	seenTerminator = 0;
+	for (; bytes_read > LOGICAL_BLOCK_SIZE;
+	    bytes_read -= LOGICAL_BLOCK_SIZE, p += LOGICAL_BLOCK_SIZE) {
+		/* Do not handle undefined Volume Descriptor Type. */
+		if (p[0] >= 4 && p[0] <= 254)
+			return (0);
+		/* Standard Identifier must be "CD001" */
+		if (memcmp(p + 1, "CD001", 5) != 0)
+			return (0);
+		if (isPVD(iso9660, p))
+			continue;
+		if (!iso9660->joliet.location) {
+			if (isJolietSVD(iso9660, p))
+				continue;
+		}
+		if (isBootRecord(iso9660, p))
+			continue;
+		if (isEVD(iso9660, p))
+			continue;
+		if (isSVD(iso9660, p))
+			continue;
+		if (isVolumePartition(iso9660, p))
+			continue;
+		if (isVDSetTerminator(iso9660, p)) {
+			seenTerminator = 1;
+			break;
+		}
+		return (0);
+	}
+	/*
+	 * ISO 9660 format must have Primary Volume Descriptor and
+	 * Volume Descriptor Set Terminator.
+	 */
+	if (seenTerminator && iso9660->primary.location > 16)
+		return (48);
+
+	/* We didn't find a valid PVD; return a bid of zero. */
+	return (0);
+}
+
+static int
+archive_read_format_iso9660_options(struct archive_read *a,
+		const char *key, const char *val)
+{
+	struct iso9660 *iso9660;
+
+	iso9660 = (struct iso9660 *)(a->format->data);
+
+	if (strcmp(key, "joliet") == 0) {
+		if (val == NULL || strcmp(val, "off") == 0 ||
+				strcmp(val, "ignore") == 0 ||
+				strcmp(val, "disable") == 0 ||
+				strcmp(val, "0") == 0)
+			iso9660->opt_support_joliet = 0;
+		else
+			iso9660->opt_support_joliet = 1;
+		return (ARCHIVE_OK);
+	}
+	if (strcmp(key, "rockridge") == 0 ||
+	    strcmp(key, "Rockridge") == 0) {
+		iso9660->opt_support_rockridge = val != NULL;
+		return (ARCHIVE_OK);
+	}
+
+	/* Note: The "warn" return is just to inform the options
+	 * supervisor that we didn't handle it.  It will generate
+	 * a suitable error if no one used this option. */
+	return (ARCHIVE_WARN);
+}
+
+static int
+isNull(struct iso9660 *iso9660, const unsigned char *h, unsigned offset,
+unsigned bytes)
+{
+
+	while (bytes >= sizeof(iso9660->null)) {
+		if (!memcmp(iso9660->null, h + offset, sizeof(iso9660->null)))
+			return (0);
+		offset += sizeof(iso9660->null);
+		bytes -= sizeof(iso9660->null);
+	}
+	if (bytes)
+		return memcmp(iso9660->null, h + offset, bytes) == 0;
+	else
+		return (1);
+}
+
+static int
+isBootRecord(struct iso9660 *iso9660, const unsigned char *h)
+{
+	(void)iso9660; /* UNUSED */
+
+	/* Type of the Volume Descriptor Boot Record must be 0. */
+	if (h[0] != 0)
+		return (0);
+
+	/* Volume Descriptor Version must be 1. */
+	if (h[6] != 1)
+		return (0);
+
+	return (1);
+}
+
+static int
+isVolumePartition(struct iso9660 *iso9660, const unsigned char *h)
+{
+	int32_t location;
+
+	/* Type of the Volume Partition Descriptor must be 3. */
+	if (h[0] != 3)
+		return (0);
+
+	/* Volume Descriptor Version must be 1. */
+	if (h[6] != 1)
+		return (0);
+	/* Unused Field */
+	if (h[7] != 0)
+		return (0);
+
+	location = archive_le32dec(h + 72);
+	if (location <= SYSTEM_AREA_BLOCK ||
+	    location >= iso9660->volume_block)
+		return (0);
+	if ((uint32_t)location != archive_be32dec(h + 76))
+		return (0);
+
+	return (1);
+}
+
+static int
+isVDSetTerminator(struct iso9660 *iso9660, const unsigned char *h)
+{
+	(void)iso9660; /* UNUSED */
+
+	/* Type of the Volume Descriptor Set Terminator must be 255. */
+	if (h[0] != 255)
+		return (0);
+
+	/* Volume Descriptor Version must be 1. */
+	if (h[6] != 1)
+		return (0);
+
+	/* Reserved field must be 0. */
+	if (!isNull(iso9660, h, 7, 2048-7))
+		return (0);
+
+	return (1);
+}
+
+static int
+isJolietSVD(struct iso9660 *iso9660, const unsigned char *h)
+{
+	const unsigned char *p;
+	ssize_t logical_block_size;
+	int32_t volume_block;
+
+	/* Check if current sector is a kind of Supplementary Volume
+	 * Descriptor. */
+	if (!isSVD(iso9660, h))
+		return (0);
+
+	/* FIXME: do more validations according to joliet spec. */
+
+	/* check if this SVD contains joliet extension! */
+	p = h + SVD_escape_sequences_offset;
+	/* N.B. Joliet spec says p[1] == '\\', but.... */
+	if (p[0] == '%' && p[1] == '/') {
+		int level = 0;
+
+		if (p[2] == '@')
+			level = 1;
+		else if (p[2] == 'C')
+			level = 2;
+		else if (p[2] == 'E')
+			level = 3;
+		else /* not joliet */
+			return (0);
+
+		iso9660->seenJoliet = level;
+
+	} else /* not joliet */
+		return (0);
+
+	logical_block_size =
+	    archive_le16dec(h + SVD_logical_block_size_offset);
+	volume_block = archive_le32dec(h + SVD_volume_space_size_offset);
+
+	iso9660->logical_block_size = logical_block_size;
+	iso9660->volume_block = volume_block;
+	iso9660->volume_size = logical_block_size * (uint64_t)volume_block;
+	/* Read Root Directory Record in Volume Descriptor. */
+	p = h + SVD_root_directory_record_offset;
+	iso9660->joliet.location = archive_le32dec(p + DR_extent_offset);
+	iso9660->joliet.size = archive_le32dec(p + DR_size_offset);
+
+	return (48);
+}
+
+static int
+isSVD(struct iso9660 *iso9660, const unsigned char *h)
+{
+	const unsigned char *p;
+	ssize_t logical_block_size;
+	int32_t volume_block;
+	int32_t location;
+
+	(void)iso9660; /* UNUSED */
+
+	/* Type 2 means it's a SVD. */
+	if (h[SVD_type_offset] != 2)
+		return (0);
+
+	/* Reserved field must be 0. */
+	if (!isNull(iso9660, h, SVD_reserved1_offset, SVD_reserved1_size))
+		return (0);
+	if (!isNull(iso9660, h, SVD_reserved2_offset, SVD_reserved2_size))
+		return (0);
+	if (!isNull(iso9660, h, SVD_reserved3_offset, SVD_reserved3_size))
+		return (0);
+
+	/* File structure version must be 1 for ISO9660/ECMA119. */
+	if (h[SVD_file_structure_version_offset] != 1)
+		return (0);
+
+	logical_block_size =
+	    archive_le16dec(h + SVD_logical_block_size_offset);
+	if (logical_block_size <= 0)
+		return (0);
+
+	volume_block = archive_le32dec(h + SVD_volume_space_size_offset);
+	if (volume_block <= SYSTEM_AREA_BLOCK+4)
+		return (0);
+
+	/* Location of Occurrence of Type L Path Table must be
+	 * available location,
+	 * >= SYSTEM_AREA_BLOCK(16) + 2 and < Volume Space Size. */
+	location = archive_le32dec(h+SVD_type_L_path_table_offset);
+	if (location < SYSTEM_AREA_BLOCK+2 || location >= volume_block)
+		return (0);
+
+	/* The Type M Path Table must be at a valid location (WinISO
+	 * and probably other programs omit this, so we allow zero)
+	 *
+	 * >= SYSTEM_AREA_BLOCK(16) + 2 and < Volume Space Size. */
+	location = archive_be32dec(h+SVD_type_M_path_table_offset);
+	if ((location > 0 && location < SYSTEM_AREA_BLOCK+2)
+	    || location >= volume_block)
+		return (0);
+
+	/* Read Root Directory Record in Volume Descriptor. */
+	p = h + SVD_root_directory_record_offset;
+	if (p[DR_length_offset] != 34)
+		return (0);
+
+	return (48);
+}
+
+static int
+isEVD(struct iso9660 *iso9660, const unsigned char *h)
+{
+	const unsigned char *p;
+	ssize_t logical_block_size;
+	int32_t volume_block;
+	int32_t location;
+
+	(void)iso9660; /* UNUSED */
+
+	/* Type of the Enhanced Volume Descriptor must be 2. */
+	if (h[PVD_type_offset] != 2)
+		return (0);
+
+	/* EVD version must be 2. */
+	if (h[PVD_version_offset] != 2)
+		return (0);
+
+	/* Reserved field must be 0. */
+	if (h[PVD_reserved1_offset] != 0)
+		return (0);
+
+	/* Reserved field must be 0. */
+	if (!isNull(iso9660, h, PVD_reserved2_offset, PVD_reserved2_size))
+		return (0);
+
+	/* Reserved field must be 0. */
+	if (!isNull(iso9660, h, PVD_reserved3_offset, PVD_reserved3_size))
+		return (0);
+
+	/* Logical block size must be > 0. */
+	/* I've looked at Ecma 119 and can't find any stronger
+	 * restriction on this field. */
+	logical_block_size =
+	    archive_le16dec(h + PVD_logical_block_size_offset);
+	if (logical_block_size <= 0)
+		return (0);
+
+	volume_block =
+	    archive_le32dec(h + PVD_volume_space_size_offset);
+	if (volume_block <= SYSTEM_AREA_BLOCK+4)
+		return (0);
+
+	/* File structure version must be 2 for ISO9660:1999. */
+	if (h[PVD_file_structure_version_offset] != 2)
+		return (0);
+
+	/* Location of Occurrence of Type L Path Table must be
+	 * available location,
+	 * >= SYSTEM_AREA_BLOCK(16) + 2 and < Volume Space Size. */
+	location = archive_le32dec(h+PVD_type_1_path_table_offset);
+	if (location < SYSTEM_AREA_BLOCK+2 || location >= volume_block)
+		return (0);
+
+	/* Location of Occurrence of Type M Path Table must be
+	 * available location,
+	 * >= SYSTEM_AREA_BLOCK(16) + 2 and < Volume Space Size. */
+	location = archive_be32dec(h+PVD_type_m_path_table_offset);
+	if ((location > 0 && location < SYSTEM_AREA_BLOCK+2)
+	    || location >= volume_block)
+		return (0);
+
+	/* Reserved field must be 0. */
+	if (!isNull(iso9660, h, PVD_reserved4_offset, PVD_reserved4_size))
+		return (0);
+
+	/* Reserved field must be 0. */
+	if (!isNull(iso9660, h, PVD_reserved5_offset, PVD_reserved5_size))
+		return (0);
+
+	/* Read Root Directory Record in Volume Descriptor. */
+	p = h + PVD_root_directory_record_offset;
+	if (p[DR_length_offset] != 34)
+		return (0);
+
+	return (48);
+}
+
+static int
+isPVD(struct iso9660 *iso9660, const unsigned char *h)
+{
+	const unsigned char *p;
+	ssize_t logical_block_size;
+	int32_t volume_block;
+	int32_t location;
+	int i;
+
+	/* Type of the Primary Volume Descriptor must be 1. */
+	if (h[PVD_type_offset] != 1)
+		return (0);
+
+	/* PVD version must be 1. */
+	if (h[PVD_version_offset] != 1)
+		return (0);
+
+	/* Reserved field must be 0. */
+	if (h[PVD_reserved1_offset] != 0)
+		return (0);
+
+	/* Reserved field must be 0. */
+	if (!isNull(iso9660, h, PVD_reserved2_offset, PVD_reserved2_size))
+		return (0);
+
+	/* Reserved field must be 0. */
+	if (!isNull(iso9660, h, PVD_reserved3_offset, PVD_reserved3_size))
+		return (0);
+
+	/* Logical block size must be > 0. */
+	/* I've looked at Ecma 119 and can't find any stronger
+	 * restriction on this field. */
+	logical_block_size =
+	    archive_le16dec(h + PVD_logical_block_size_offset);
+	if (logical_block_size <= 0)
+		return (0);
+
+	volume_block = archive_le32dec(h + PVD_volume_space_size_offset);
+	if (volume_block <= SYSTEM_AREA_BLOCK+4)
+		return (0);
+
+	/* File structure version must be 1 for ISO9660/ECMA119. */
+	if (h[PVD_file_structure_version_offset] != 1)
+		return (0);
+
+	/* Location of Occurrence of Type L Path Table must be
+	 * available location,
+	 * > SYSTEM_AREA_BLOCK(16) + 2 and < Volume Space Size. */
+	location = archive_le32dec(h+PVD_type_1_path_table_offset);
+	if (location < SYSTEM_AREA_BLOCK+2 || location >= volume_block)
+		return (0);
+
+	/* The Type M Path Table must also be at a valid location
+	 * (although ECMA 119 requires a Type M Path Table, WinISO and
+	 * probably other programs omit it, so we permit a zero here)
+	 *
+	 * >= SYSTEM_AREA_BLOCK(16) + 2 and < Volume Space Size. */
+	location = archive_be32dec(h+PVD_type_m_path_table_offset);
+	if ((location > 0 && location < SYSTEM_AREA_BLOCK+2)
+	    || location >= volume_block)
+		return (0);
+
+	/* Reserved field must be 0. */
+	/* But accept NetBSD/FreeBSD "makefs" images with 0x20 here. */
+	for (i = 0; i < PVD_reserved4_size; ++i)
+		if (h[PVD_reserved4_offset + i] != 0
+		    && h[PVD_reserved4_offset + i] != 0x20)
+			return (0);
+
+	/* Reserved field must be 0. */
+	if (!isNull(iso9660, h, PVD_reserved5_offset, PVD_reserved5_size))
+		return (0);
+
+	/* XXX TODO: Check other values for sanity; reject more
+	 * malformed PVDs. XXX */
+
+	/* Read Root Directory Record in Volume Descriptor. */
+	p = h + PVD_root_directory_record_offset;
+	if (p[DR_length_offset] != 34)
+		return (0);
+
+	if (!iso9660->primary.location) {
+		iso9660->logical_block_size = logical_block_size;
+		iso9660->volume_block = volume_block;
+		iso9660->volume_size =
+		    logical_block_size * (uint64_t)volume_block;
+		iso9660->primary.location =
+		    archive_le32dec(p + DR_extent_offset);
+		iso9660->primary.size = archive_le32dec(p + DR_size_offset);
+	}
+
+	return (48);
+}
+
+static int
+read_children(struct archive_read *a, struct file_info *parent)
+{
+	struct iso9660 *iso9660;
+	const unsigned char *b, *p;
+	struct file_info *multi;
+	size_t step, skip_size;
+
+	iso9660 = (struct iso9660 *)(a->format->data);
+	/* flush any remaining bytes from the last round to ensure
+	 * we're positioned */
+	if (iso9660->entry_bytes_unconsumed) {
+		__archive_read_consume(a, iso9660->entry_bytes_unconsumed);
+		iso9660->entry_bytes_unconsumed = 0;
+	}
+	if (iso9660->current_position > parent->offset) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+		    "Ignoring out-of-order directory (%s) %jd > %jd",
+		    parent->name.s,
+		    (intmax_t)iso9660->current_position,
+		    (intmax_t)parent->offset);
+		return (ARCHIVE_WARN);
+	}
+	if (parent->offset + parent->size > iso9660->volume_size) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+		    "Directory is beyond end-of-media: %s",
+		    parent->name.s);
+		return (ARCHIVE_WARN);
+	}
+	if (iso9660->current_position < parent->offset) {
+		int64_t skipsize;
+
+		skipsize = parent->offset - iso9660->current_position;
+		skipsize = __archive_read_consume(a, skipsize);
+		if (skipsize < 0)
+			return ((int)skipsize);
+		iso9660->current_position = parent->offset;
+	}
+
+	step = (size_t)(((parent->size + iso9660->logical_block_size -1) /
+	    iso9660->logical_block_size) * iso9660->logical_block_size);
+	b = __archive_read_ahead(a, step, NULL);
+	if (b == NULL) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+		    "Failed to read full block when scanning "
+		    "ISO9660 directory list");
+		return (ARCHIVE_FATAL);
+	}
+	iso9660->current_position += step;
+	multi = NULL;
+	skip_size = step;
+	while (step) {
+		p = b;
+		b += iso9660->logical_block_size;
+		step -= iso9660->logical_block_size;
+		for (; *p != 0 && p < b && p + *p <= b; p += *p) {
+			struct file_info *child;
+
+			/* N.B.: these special directory identifiers
+			 * are 8 bit "values" even on a
+			 * Joliet CD with UCS-2 (16bit) encoding.
+			 */
+
+			/* Skip '.' entry. */
+			if (*(p + DR_name_len_offset) == 1
+			    && *(p + DR_name_offset) == '\0')
+				continue;
+			/* Skip '..' entry. */
+			if (*(p + DR_name_len_offset) == 1
+			    && *(p + DR_name_offset) == '\001')
+				continue;
+			child = parse_file_info(a, parent, p, b - p);
+			if (child == NULL) {
+				__archive_read_consume(a, skip_size);
+				return (ARCHIVE_FATAL);
+			}
+			if (child->cl_offset == 0 &&
+			    (child->multi_extent || multi != NULL)) {
+				struct content *con;
+
+				if (multi == NULL) {
+					multi = child;
+					multi->contents.first = NULL;
+					multi->contents.last =
+					    &(multi->contents.first);
+				}
+				con = malloc(sizeof(struct content));
+				if (con == NULL) {
+					archive_set_error(
+					    &a->archive, ENOMEM,
+					    "No memory for multi extent");
+					__archive_read_consume(a, skip_size);
+					return (ARCHIVE_FATAL);
+				}
+				con->offset = child->offset;
+				con->size = child->size;
+				con->next = NULL;
+				*multi->contents.last = con;
+				multi->contents.last = &(con->next);
+				if (multi == child) {
+					if (add_entry(a, iso9660, child)
+					    != ARCHIVE_OK)
+						return (ARCHIVE_FATAL);
+				} else {
+					multi->size += child->size;
+					if (!child->multi_extent)
+						multi = NULL;
+				}
+			} else
+				if (add_entry(a, iso9660, child) != ARCHIVE_OK)
+					return (ARCHIVE_FATAL);
+		}
+	}
+
+	__archive_read_consume(a, skip_size);
+
+	/* Read data which recorded by RRIP "CE" extension. */
+	if (read_CE(a, iso9660) != ARCHIVE_OK)
+		return (ARCHIVE_FATAL);
+
+	return (ARCHIVE_OK);
+}
+
+static int
+choose_volume(struct archive_read *a, struct iso9660 *iso9660)
+{
+	struct file_info *file;
+	int64_t skipsize;
+	struct vd *vd;
+	const void *block;
+	char seenJoliet;
+
+	vd = &(iso9660->primary);
+	if (!iso9660->opt_support_joliet)
+		iso9660->seenJoliet = 0;
+	if (iso9660->seenJoliet &&
+		vd->location > iso9660->joliet.location)
+		/* This condition is unlikely; by way of caution. */
+		vd = &(iso9660->joliet);
+
+	skipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;
+	skipsize = __archive_read_consume(a, skipsize);
+	if (skipsize < 0)
+		return ((int)skipsize);
+	iso9660->current_position = skipsize;
+
+	block = __archive_read_ahead(a, vd->size, NULL);
+	if (block == NULL) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+		    "Failed to read full block when scanning "
+		    "ISO9660 directory list");
+		return (ARCHIVE_FATAL);
+	}
+
+	/*
+	 * While reading Root Directory, flag seenJoliet must be zero to
+	 * avoid converting special name 0x00(Current Directory) and
+	 * next byte to UCS2.
+	 */
+	seenJoliet = iso9660->seenJoliet;/* Save flag. */
+	iso9660->seenJoliet = 0;
+	file = parse_file_info(a, NULL, block, vd->size);
+	if (file == NULL)
+		return (ARCHIVE_FATAL);
+	iso9660->seenJoliet = seenJoliet;
+
+	/*
+	 * If the iso image has both RockRidge and Joliet, we preferentially
+	 * use RockRidge Extensions rather than Joliet ones.
+	 */
+	if (vd == &(iso9660->primary) && iso9660->seenRockridge
+	    && iso9660->seenJoliet)
+		iso9660->seenJoliet = 0;
+
+	if (vd == &(iso9660->primary) && !iso9660->seenRockridge
+	    && iso9660->seenJoliet) {
+		/* Switch reading data from primary to joliet. */
+		vd = &(iso9660->joliet);
+		skipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;
+		skipsize -= iso9660->current_position;
+		skipsize = __archive_read_consume(a, skipsize);
+		if (skipsize < 0)
+			return ((int)skipsize);
+		iso9660->current_position += skipsize;
+
+		block = __archive_read_ahead(a, vd->size, NULL);
+		if (block == NULL) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "Failed to read full block when scanning "
+			    "ISO9660 directory list");
+			return (ARCHIVE_FATAL);
+		}
+		iso9660->seenJoliet = 0;
+		file = parse_file_info(a, NULL, block, vd->size);
+		if (file == NULL)
+			return (ARCHIVE_FATAL);
+		iso9660->seenJoliet = seenJoliet;
+	}
+
+	/* Store the root directory in the pending list. */
+	if (add_entry(a, iso9660, file) != ARCHIVE_OK)
+		return (ARCHIVE_FATAL);
+	if (iso9660->seenRockridge) {
+		a->archive.archive_format = ARCHIVE_FORMAT_ISO9660_ROCKRIDGE;
+		a->archive.archive_format_name =
+		    "ISO9660 with Rockridge extensions";
+	}
+
+	return (ARCHIVE_OK);
+}
+
+static int
+archive_read_format_iso9660_read_header(struct archive_read *a,
+    struct archive_entry *entry)
+{
+	struct iso9660 *iso9660;
+	struct file_info *file;
+	int r, rd_r = ARCHIVE_OK;
+
+	iso9660 = (struct iso9660 *)(a->format->data);
+
+	if (!a->archive.archive_format) {
+		a->archive.archive_format = ARCHIVE_FORMAT_ISO9660;
+		a->archive.archive_format_name = "ISO9660";
+	}
+
+	if (iso9660->current_position == 0) {
+		r = choose_volume(a, iso9660);
+		if (r != ARCHIVE_OK)
+			return (r);
+	}
+
+	file = NULL;/* Eliminate a warning. */
+	/* Get the next entry that appears after the current offset. */
+	r = next_entry_seek(a, iso9660, &file);
+	if (r != ARCHIVE_OK)
+		return (r);
+
+	if (iso9660->seenJoliet) {
+		/*
+		 * Convert UTF-16BE of a filename to local locale MBS
+		 * and store the result into a filename field.
+		 */
+		if (iso9660->sconv_utf16be == NULL) {
+			iso9660->sconv_utf16be =
+			    archive_string_conversion_from_charset(
+				&(a->archive), "UTF-16BE", 1);
+			if (iso9660->sconv_utf16be == NULL)
+				/* Couldn't allocate memory */
+				return (ARCHIVE_FATAL);
+		}
+		if (iso9660->utf16be_path == NULL) {
+			iso9660->utf16be_path = malloc(UTF16_NAME_MAX);
+			if (iso9660->utf16be_path == NULL) {
+				archive_set_error(&a->archive, ENOMEM,
+				    "No memory");
+				return (ARCHIVE_FATAL);
+			}
+		}
+		if (iso9660->utf16be_previous_path == NULL) {
+			iso9660->utf16be_previous_path = malloc(UTF16_NAME_MAX);
+			if (iso9660->utf16be_previous_path == NULL) {
+				archive_set_error(&a->archive, ENOMEM,
+				    "No memory");
+				return (ARCHIVE_FATAL);
+			}
+		}
+
+		iso9660->utf16be_path_len = 0;
+		if (build_pathname_utf16be(iso9660->utf16be_path,
+		    UTF16_NAME_MAX, &(iso9660->utf16be_path_len), file) != 0) {
+			archive_set_error(&a->archive,
+			    ARCHIVE_ERRNO_FILE_FORMAT,
+			    "Pathname is too long");
+			return (ARCHIVE_FATAL);
+		}
+
+		r = archive_entry_copy_pathname_l(entry,
+		    (const char *)iso9660->utf16be_path,
+		    iso9660->utf16be_path_len,
+		    iso9660->sconv_utf16be);
+		if (r != 0) {
+			if (errno == ENOMEM) {
+				archive_set_error(&a->archive, ENOMEM,
+				    "No memory for Pathname");
+				return (ARCHIVE_FATAL);
+			}
+			archive_set_error(&a->archive,
+			    ARCHIVE_ERRNO_FILE_FORMAT,
+			    "Pathname cannot be converted "
+			    "from %s to current locale.",
+			    archive_string_conversion_charset_name(
+			      iso9660->sconv_utf16be));
+
+			rd_r = ARCHIVE_WARN;
+		}
+	} else {
+		const char *path = build_pathname(&iso9660->pathname, file, 0);
+		if (path == NULL) {
+			archive_set_error(&a->archive,
+			    ARCHIVE_ERRNO_FILE_FORMAT,
+			    "Pathname is too long");
+			return (ARCHIVE_FATAL);
+		} else {
+			archive_string_empty(&iso9660->pathname);
+			archive_entry_set_pathname(entry, path);
+		}
+	}
+
+	iso9660->entry_bytes_remaining = file->size;
+	/* Offset for sparse-file-aware clients. */
+	iso9660->entry_sparse_offset = 0;
+
+	if (file->offset + file->size > iso9660->volume_size) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+		    "File is beyond end-of-media: %s",
+		    archive_entry_pathname(entry));
+		iso9660->entry_bytes_remaining = 0;
+		return (ARCHIVE_WARN);
+	}
+
+	/* Set up the entry structure with information about this entry. */
+	archive_entry_set_mode(entry, file->mode);
+	archive_entry_set_uid(entry, file->uid);
+	archive_entry_set_gid(entry, file->gid);
+	archive_entry_set_nlink(entry, file->nlinks);
+	if (file->birthtime_is_set)
+		archive_entry_set_birthtime(entry, file->birthtime, 0);
+	else
+		archive_entry_unset_birthtime(entry);
+	archive_entry_set_mtime(entry, file->mtime, 0);
+	archive_entry_set_ctime(entry, file->ctime, 0);
+	archive_entry_set_atime(entry, file->atime, 0);
+	/* N.B.: Rock Ridge supports 64-bit device numbers. */
+	archive_entry_set_rdev(entry, (dev_t)file->rdev);
+	archive_entry_set_size(entry, iso9660->entry_bytes_remaining);
+	if (file->symlink.s != NULL)
+		archive_entry_copy_symlink(entry, file->symlink.s);
+
+	/* Note: If the input isn't seekable, we can't rewind to
+	 * return the same body again, so if the next entry refers to
+	 * the same data, we have to return it as a hardlink to the
+	 * original entry. */
+	if (file->number != -1 &&
+	    file->number == iso9660->previous_number) {
+		if (iso9660->seenJoliet) {
+			r = archive_entry_copy_hardlink_l(entry,
+			    (const char *)iso9660->utf16be_previous_path,
+			    iso9660->utf16be_previous_path_len,
+			    iso9660->sconv_utf16be);
+			if (r != 0) {
+				if (errno == ENOMEM) {
+					archive_set_error(&a->archive, ENOMEM,
+					    "No memory for Linkname");
+					return (ARCHIVE_FATAL);
+				}
+				archive_set_error(&a->archive,
+				    ARCHIVE_ERRNO_FILE_FORMAT,
+				    "Linkname cannot be converted "
+				    "from %s to current locale.",
+				    archive_string_conversion_charset_name(
+				      iso9660->sconv_utf16be));
+				rd_r = ARCHIVE_WARN;
+			}
+		} else
+			archive_entry_set_hardlink(entry,
+			    iso9660->previous_pathname.s);
+		archive_entry_unset_size(entry);
+		iso9660->entry_bytes_remaining = 0;
+		return (rd_r);
+	}
+
+	if ((file->mode & AE_IFMT) != AE_IFDIR &&
+	    file->offset < iso9660->current_position) {
+		int64_t r64;
+
+		r64 = __archive_read_seek(a, file->offset, SEEK_SET);
+		if (r64 != (int64_t)file->offset) {
+			/* We can't seek backwards to extract it, so issue
+			 * a warning.  Note that this can only happen if
+			 * this entry was added to the heap after we passed
+			 * this offset, that is, only if the directory
+			 * mentioning this entry is later than the body of
+			 * the entry. Such layouts are very unusual; most
+			 * ISO9660 writers lay out and record all directory
+			 * information first, then store all file bodies. */
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "Ignoring out-of-order file @%jx (%s) %jd < %jd",
+			    (intmax_t)file->number,
+			    iso9660->pathname.s,
+			    (intmax_t)file->offset,
+			    (intmax_t)iso9660->current_position);
+			iso9660->entry_bytes_remaining = 0;
+			return (ARCHIVE_WARN);
+		}
+		iso9660->current_position = (uint64_t)r64;
+	}
+
+	/* Initialize zisofs variables. */
+	iso9660->entry_zisofs.pz = file->pz;
+	if (file->pz) {
+#ifdef HAVE_ZLIB_H
+		struct zisofs  *zisofs;
+
+		zisofs = &iso9660->entry_zisofs;
+		zisofs->initialized = 0;
+		zisofs->pz_log2_bs = file->pz_log2_bs;
+		zisofs->pz_uncompressed_size = file->pz_uncompressed_size;
+		zisofs->pz_offset = 0;
+		zisofs->header_avail = 0;
+		zisofs->header_passed = 0;
+		zisofs->block_pointers_avail = 0;
+#endif
+		archive_entry_set_size(entry, file->pz_uncompressed_size);
+	}
+
+	iso9660->previous_number = file->number;
+	if (iso9660->seenJoliet) {
+		memcpy(iso9660->utf16be_previous_path, iso9660->utf16be_path,
+		    iso9660->utf16be_path_len);
+		iso9660->utf16be_previous_path_len = iso9660->utf16be_path_len;
+	} else
+		archive_strcpy(
+		    &iso9660->previous_pathname, iso9660->pathname.s);
+
+	/* Reset entry_bytes_remaining if the file is multi extent. */
+	iso9660->entry_content = file->contents.first;
+	if (iso9660->entry_content != NULL)
+		iso9660->entry_bytes_remaining = iso9660->entry_content->size;
+
+	if (archive_entry_filetype(entry) == AE_IFDIR) {
+		/* Overwrite nlinks by proper link number which is
+		 * calculated from number of sub directories. */
+		archive_entry_set_nlink(entry, 2 + file->subdirs);
+		/* Directory data has been read completely. */
+		iso9660->entry_bytes_remaining = 0;
+	}
+
+	if (rd_r != ARCHIVE_OK)
+		return (rd_r);
+	return (ARCHIVE_OK);
+}
+
+static int
+archive_read_format_iso9660_read_data_skip(struct archive_read *a)
+{
+	/* Because read_next_header always does an explicit skip
+	 * to the next entry, we don't need to do anything here. */
+	(void)a; /* UNUSED */
+	return (ARCHIVE_OK);
+}
+
+#ifdef HAVE_ZLIB_H
+
+static int
+zisofs_read_data(struct archive_read *a,
+    const void **buff, size_t *size, int64_t *offset)
+{
+	struct iso9660 *iso9660;
+	struct zisofs  *zisofs;
+	const unsigned char *p;
+	size_t avail;
+	ssize_t bytes_read;
+	size_t uncompressed_size;
+	int r;
+
+	iso9660 = (struct iso9660 *)(a->format->data);
+	zisofs = &iso9660->entry_zisofs;
+
+	p = __archive_read_ahead(a, 1, &bytes_read);
+	if (bytes_read <= 0) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+		    "Truncated zisofs file body");
+		return (ARCHIVE_FATAL);
+	}
+	if (bytes_read > iso9660->entry_bytes_remaining)
+		bytes_read = (ssize_t)iso9660->entry_bytes_remaining;
+	avail = bytes_read;
+	uncompressed_size = 0;
+
+	if (!zisofs->initialized) {
+		size_t ceil, xsize;
+
+		/* Allocate block pointers buffer. */
+		ceil = (size_t)((zisofs->pz_uncompressed_size +
+			(((int64_t)1) << zisofs->pz_log2_bs) - 1)
+			>> zisofs->pz_log2_bs);
+		xsize = (ceil + 1) * 4;
+		if (zisofs->block_pointers_alloc < xsize) {
+			size_t alloc;
+
+			if (zisofs->block_pointers != NULL)
+				free(zisofs->block_pointers);
+			alloc = ((xsize >> 10) + 1) << 10;
+			zisofs->block_pointers = malloc(alloc);
+			if (zisofs->block_pointers == NULL) {
+				archive_set_error(&a->archive, ENOMEM,
+				    "No memory for zisofs decompression");
+				return (ARCHIVE_FATAL);
+			}
+			zisofs->block_pointers_alloc = alloc;
+		}
+		zisofs->block_pointers_size = xsize;
+
+		/* Allocate uncompressed data buffer. */
+		xsize = (size_t)1UL << zisofs->pz_log2_bs;
+		if (zisofs->uncompressed_buffer_size < xsize) {
+			if (zisofs->uncompressed_buffer != NULL)
+				free(zisofs->uncompressed_buffer);
+			zisofs->uncompressed_buffer = malloc(xsize);
+			if (zisofs->uncompressed_buffer == NULL) {
+				archive_set_error(&a->archive, ENOMEM,
+				    "No memory for zisofs decompression");
+				return (ARCHIVE_FATAL);
+			}
+		}
+		zisofs->uncompressed_buffer_size = xsize;
+
+		/*
+		 * Read the file header, and check the magic code of zisofs.
+		 */
+		if (zisofs->header_avail < sizeof(zisofs->header)) {
+			xsize = sizeof(zisofs->header) - zisofs->header_avail;
+			if (avail < xsize)
+				xsize = avail;
+			memcpy(zisofs->header + zisofs->header_avail, p, xsize);
+			zisofs->header_avail += xsize;
+			avail -= xsize;
+			p += xsize;
+		}
+		if (!zisofs->header_passed &&
+		    zisofs->header_avail == sizeof(zisofs->header)) {
+			int err = 0;
+
+			if (memcmp(zisofs->header, zisofs_magic,
+			    sizeof(zisofs_magic)) != 0)
+				err = 1;
+			if (archive_le32dec(zisofs->header + 8)
+			    != zisofs->pz_uncompressed_size)
+				err = 1;
+			if (zisofs->header[12] != 4)
+				err = 1;
+			if (zisofs->header[13] != zisofs->pz_log2_bs)
+				err = 1;
+			if (err) {
+				archive_set_error(&a->archive,
+				    ARCHIVE_ERRNO_FILE_FORMAT,
+				    "Illegal zisofs file body");
+				return (ARCHIVE_FATAL);
+			}
+			zisofs->header_passed = 1;
+		}
+		/*
+		 * Read block pointers.
+		 */
+		if (zisofs->header_passed &&
+		    zisofs->block_pointers_avail < zisofs->block_pointers_size) {
+			xsize = zisofs->block_pointers_size
+			    - zisofs->block_pointers_avail;
+			if (avail < xsize)
+				xsize = avail;
+			memcpy(zisofs->block_pointers
+			    + zisofs->block_pointers_avail, p, xsize);
+			zisofs->block_pointers_avail += xsize;
+			avail -= xsize;
+			p += xsize;
+		    	if (zisofs->block_pointers_avail
+			    == zisofs->block_pointers_size) {
+				/* We've got all block pointers and initialize
+				 * related variables.	*/
+				zisofs->block_off = 0;
+				zisofs->block_avail = 0;
+				/* Complete a initialization */
+				zisofs->initialized = 1;
+			}
+		}
+
+		if (!zisofs->initialized)
+			goto next_data; /* We need more data. */
+	}
+
+	/*
+	 * Get block offsets from block pointers.
+	 */
+	if (zisofs->block_avail == 0) {
+		uint32_t bst, bed;
+
+		if (zisofs->block_off + 4 >= zisofs->block_pointers_size) {
+			/* There isn't a pair of offsets. */
+			archive_set_error(&a->archive,
+			    ARCHIVE_ERRNO_FILE_FORMAT,
+			    "Illegal zisofs block pointers");
+			return (ARCHIVE_FATAL);
+		}
+		bst = archive_le32dec(
+		    zisofs->block_pointers + zisofs->block_off);
+		if (bst != zisofs->pz_offset + (bytes_read - avail)) {
+			/* TODO: Should we seek offset of current file
+			 * by bst ? */
+			archive_set_error(&a->archive,
+			    ARCHIVE_ERRNO_FILE_FORMAT,
+			    "Illegal zisofs block pointers(cannot seek)");
+			return (ARCHIVE_FATAL);
+		}
+		bed = archive_le32dec(
+		    zisofs->block_pointers + zisofs->block_off + 4);
+		if (bed < bst) {
+			archive_set_error(&a->archive,
+			    ARCHIVE_ERRNO_FILE_FORMAT,
+			    "Illegal zisofs block pointers");
+			return (ARCHIVE_FATAL);
+		}
+		zisofs->block_avail = bed - bst;
+		zisofs->block_off += 4;
+
+		/* Initialize compression library for new block. */
+		if (zisofs->stream_valid)
+			r = inflateReset(&zisofs->stream);
+		else
+			r = inflateInit(&zisofs->stream);
+		if (r != Z_OK) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "Can't initialize zisofs decompression.");
+			return (ARCHIVE_FATAL);
+		}
+		zisofs->stream_valid = 1;
+		zisofs->stream.total_in = 0;
+		zisofs->stream.total_out = 0;
+	}
+
+	/*
+	 * Make uncompressed data.
+	 */
+	if (zisofs->block_avail == 0) {
+		memset(zisofs->uncompressed_buffer, 0,
+		    zisofs->uncompressed_buffer_size);
+		uncompressed_size = zisofs->uncompressed_buffer_size;
+	} else {
+		zisofs->stream.next_in = (Bytef *)(uintptr_t)(const void *)p;
+		if (avail > zisofs->block_avail)
+			zisofs->stream.avail_in = zisofs->block_avail;
+		else
+			zisofs->stream.avail_in = (uInt)avail;
+		zisofs->stream.next_out = zisofs->uncompressed_buffer;
+		zisofs->stream.avail_out =
+		    (uInt)zisofs->uncompressed_buffer_size;
+
+		r = inflate(&zisofs->stream, 0);
+		switch (r) {
+		case Z_OK: /* Decompressor made some progress.*/
+		case Z_STREAM_END: /* Found end of stream. */
+			break;
+		default:
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "zisofs decompression failed (%d)", r);
+			return (ARCHIVE_FATAL);
+		}
+		uncompressed_size =
+		    zisofs->uncompressed_buffer_size - zisofs->stream.avail_out;
+		avail -= zisofs->stream.next_in - p;
+		zisofs->block_avail -= (uint32_t)(zisofs->stream.next_in - p);
+	}
+next_data:
+	bytes_read -= avail;
+	*buff = zisofs->uncompressed_buffer;
+	*size = uncompressed_size;
+	*offset = iso9660->entry_sparse_offset;
+	iso9660->entry_sparse_offset += uncompressed_size;
+	iso9660->entry_bytes_remaining -= bytes_read;
+	iso9660->current_position += bytes_read;
+	zisofs->pz_offset += (uint32_t)bytes_read;
+	iso9660->entry_bytes_unconsumed += bytes_read;
+
+	return (ARCHIVE_OK);
+}
+
+#else /* HAVE_ZLIB_H */
+
+static int
+zisofs_read_data(struct archive_read *a,
+    const void **buff, size_t *size, int64_t *offset)
+{
+
+	(void)buff;/* UNUSED */
+	(void)size;/* UNUSED */
+	(void)offset;/* UNUSED */
+	archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+	    "zisofs is not supported on this platform.");
+	return (ARCHIVE_FAILED);
+}
+
+#endif /* HAVE_ZLIB_H */
+
+static int
+archive_read_format_iso9660_read_data(struct archive_read *a,
+    const void **buff, size_t *size, int64_t *offset)
+{
+	ssize_t bytes_read;
+	struct iso9660 *iso9660;
+
+	iso9660 = (struct iso9660 *)(a->format->data);
+
+	if (iso9660->entry_bytes_unconsumed) {
+		__archive_read_consume(a, iso9660->entry_bytes_unconsumed);
+		iso9660->entry_bytes_unconsumed = 0;
+	}
+
+	if (iso9660->entry_bytes_remaining <= 0) {
+		if (iso9660->entry_content != NULL)
+			iso9660->entry_content = iso9660->entry_content->next;
+		if (iso9660->entry_content == NULL) {
+			*buff = NULL;
+			*size = 0;
+			*offset = iso9660->entry_sparse_offset;
+			return (ARCHIVE_EOF);
+		}
+		/* Seek forward to the start of the entry. */
+		if (iso9660->current_position < iso9660->entry_content->offset) {
+			int64_t step;
+
+			step = iso9660->entry_content->offset -
+			    iso9660->current_position;
+			step = __archive_read_consume(a, step);
+			if (step < 0)
+				return ((int)step);
+			iso9660->current_position =
+			    iso9660->entry_content->offset;
+		}
+		if (iso9660->entry_content->offset < iso9660->current_position) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "Ignoring out-of-order file (%s) %jd < %jd",
+			    iso9660->pathname.s,
+			    (intmax_t)iso9660->entry_content->offset,
+			    (intmax_t)iso9660->current_position);
+			*buff = NULL;
+			*size = 0;
+			*offset = iso9660->entry_sparse_offset;
+			return (ARCHIVE_WARN);
+		}
+		iso9660->entry_bytes_remaining = iso9660->entry_content->size;
+	}
+	if (iso9660->entry_zisofs.pz)
+		return (zisofs_read_data(a, buff, size, offset));
+
+	*buff = __archive_read_ahead(a, 1, &bytes_read);
+	if (bytes_read == 0)
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+		    "Truncated input file");
+	if (*buff == NULL)
+		return (ARCHIVE_FATAL);
+	if (bytes_read > iso9660->entry_bytes_remaining)
+		bytes_read = (ssize_t)iso9660->entry_bytes_remaining;
+	*size = bytes_read;
+	*offset = iso9660->entry_sparse_offset;
+	iso9660->entry_sparse_offset += bytes_read;
+	iso9660->entry_bytes_remaining -= bytes_read;
+	iso9660->entry_bytes_unconsumed = bytes_read;
+	iso9660->current_position += bytes_read;
+	return (ARCHIVE_OK);
+}
+
+static int
+archive_read_format_iso9660_cleanup(struct archive_read *a)
+{
+	struct iso9660 *iso9660;
+	int r = ARCHIVE_OK;
+
+	iso9660 = (struct iso9660 *)(a->format->data);
+	release_files(iso9660);
+	free(iso9660->read_ce_req.reqs);
+	archive_string_free(&iso9660->pathname);
+	archive_string_free(&iso9660->previous_pathname);
+	if (iso9660->pending_files.files)
+		free(iso9660->pending_files.files);
+#ifdef HAVE_ZLIB_H
+	free(iso9660->entry_zisofs.uncompressed_buffer);
+	free(iso9660->entry_zisofs.block_pointers);
+	if (iso9660->entry_zisofs.stream_valid) {
+		if (inflateEnd(&iso9660->entry_zisofs.stream) != Z_OK) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "Failed to clean up zlib decompressor");
+			r = ARCHIVE_FATAL;
+		}
+	}
+#endif
+	free(iso9660->utf16be_path);
+	free(iso9660->utf16be_previous_path);
+	free(iso9660);
+	(a->format->data) = NULL;
+	return (r);
+}
+
+/*
+ * This routine parses a single ISO directory record, makes sense
+ * of any extensions, and stores the result in memory.
+ */
+static struct file_info *
+parse_file_info(struct archive_read *a, struct file_info *parent,
+    const unsigned char *isodirrec, size_t reclen)
+{
+	struct iso9660 *iso9660;
+	struct file_info *file, *filep;
+	size_t name_len;
+	const unsigned char *rr_start, *rr_end;
+	const unsigned char *p;
+	size_t dr_len;
+	uint64_t fsize, offset;
+	int32_t location;
+	int flags;
+
+	iso9660 = (struct iso9660 *)(a->format->data);
+
+	if (reclen != 0)
+		dr_len = (size_t)isodirrec[DR_length_offset];
+	/*
+	 * Sanity check that reclen is not zero and dr_len is greater than
+	 * reclen but at least 34
+	 */
+	if (reclen == 0 || reclen < dr_len || dr_len < 34) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			"Invalid length of directory record");
+		return (NULL);
+	}
+	name_len = (size_t)isodirrec[DR_name_len_offset];
+	location = archive_le32dec(isodirrec + DR_extent_offset);
+	fsize = toi(isodirrec + DR_size_offset, DR_size_size);
+	/* Sanity check that name_len doesn't exceed dr_len. */
+	if (dr_len - 33 < name_len || name_len == 0) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+		    "Invalid length of file identifier");
+		return (NULL);
+	}
+	/* Sanity check that location doesn't exceed volume block.
+	 * Don't check lower limit of location; it's possibility
+	 * the location has negative value when file type is symbolic
+	 * link or file size is zero. As far as I know latest mkisofs
+	 * do that.
+	 */
+	if (location > 0 &&
+	    (location + ((fsize + iso9660->logical_block_size -1)
+	       / iso9660->logical_block_size))
+			> (uint32_t)iso9660->volume_block) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+		    "Invalid location of extent of file");
+		return (NULL);
+	}
+	/* Sanity check that location doesn't have a negative value
+	 * when the file is not empty. it's too large. */
+	if (fsize != 0 && location < 0) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+		    "Invalid location of extent of file");
+		return (NULL);
+	}
+
+	/* Sanity check that this entry does not create a cycle. */
+	offset = iso9660->logical_block_size * (uint64_t)location;
+	for (filep = parent; filep != NULL; filep = filep->parent) {
+		if (filep->offset == offset) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+			    "Directory structure contains loop");
+			return (NULL);
+		}
+	}
+
+	/* Create a new file entry and copy data from the ISO dir record. */
+	file = (struct file_info *)calloc(1, sizeof(*file));
+	if (file == NULL) {
+		archive_set_error(&a->archive, ENOMEM,
+		    "No memory for file entry");
+		return (NULL);
+	}
+	file->parent = parent;
+	file->offset = offset;
+	file->size = fsize;
+	file->mtime = isodate7(isodirrec + DR_date_offset);
+	file->ctime = file->atime = file->mtime;
+	file->rede_files.first = NULL;
+	file->rede_files.last = &(file->rede_files.first);
+
+	p = isodirrec + DR_name_offset;
+	/* Rockridge extensions (if any) follow name.  Compute this
+	 * before fidgeting the name_len below. */
+	rr_start = p + name_len + (name_len & 1 ? 0 : 1);
+	rr_end = isodirrec + dr_len;
+
+	if (iso9660->seenJoliet) {
+		/* Joliet names are max 64 chars (128 bytes) according to spec,
+		 * but genisoimage/mkisofs allows recording longer Joliet
+		 * names which are 103 UCS2 characters(206 bytes) by their
+		 * option '-joliet-long'.
+		 */
+		if (name_len > 206)
+			name_len = 206;
+		name_len &= ~1;
+
+		/* trim trailing first version and dot from filename.
+		 *
+		 * Remember we were in UTF-16BE land!
+		 * SEPARATOR 1 (.) and SEPARATOR 2 (;) are both
+		 * 16 bits big endian characters on Joliet.
+		 *
+		 * TODO: sanitize filename?
+		 *       Joliet allows any UCS-2 char except:
+		 *       *, /, :, ;, ? and \.
+		 */
+		/* Chop off trailing ';1' from files. */
+		if (name_len > 4 && p[name_len-4] == 0 && p[name_len-3] == ';'
+		    && p[name_len-2] == 0 && p[name_len-1] == '1')
+			name_len -= 4;
+#if 0 /* XXX: this somehow manages to strip of single-character file extensions, like '.c'. */
+		/* Chop off trailing '.' from filenames. */
+		if (name_len > 2 && p[name_len-2] == 0 && p[name_len-1] == '.')
+			name_len -= 2;
+#endif
+		if ((file->utf16be_name = malloc(name_len)) == NULL) {
+			archive_set_error(&a->archive, ENOMEM,
+			    "No memory for file name");
+			goto fail;
+		}
+		memcpy(file->utf16be_name, p, name_len);
+		file->utf16be_bytes = name_len;
+	} else {
+		/* Chop off trailing ';1' from files. */
+		if (name_len > 2 && p[name_len - 2] == ';' &&
+				p[name_len - 1] == '1')
+			name_len -= 2;
+		/* Chop off trailing '.' from filenames. */
+		if (name_len > 1 && p[name_len - 1] == '.')
+			--name_len;
+
+		archive_strncpy(&file->name, (const char *)p, name_len);
+	}
+
+	flags = isodirrec[DR_flags_offset];
+	if (flags & 0x02)
+		file->mode = AE_IFDIR | 0700;
+	else
+		file->mode = AE_IFREG | 0400;
+	if (flags & 0x80)
+		file->multi_extent = 1;
+	else
+		file->multi_extent = 0;
+	/*
+	 * Use a location for the file number, which is treated as an inode
+	 * number to find out hardlink target. If Rockridge extensions is
+	 * being used, the file number will be overwritten by FILE SERIAL
+	 * NUMBER of RRIP "PX" extension.
+	 * Note: Old mkisofs did not record that FILE SERIAL NUMBER
+	 * in ISO images.
+	 * Note2: xorriso set 0 to the location of a symlink file. 
+	 */
+	if (file->size == 0 && location >= 0) {
+		/* If file->size is zero, its location points wrong place,
+		 * and so we should not use it for the file number.
+		 * When the location has negative value, it can be used
+		 * for the file number.
+		 */
+		file->number = -1;
+		/* Do not appear before any directory entries. */
+		file->offset = -1;
+	} else
+		file->number = (int64_t)(uint32_t)location;
+
+	/* Rockridge extensions overwrite information from above. */
+	if (iso9660->opt_support_rockridge) {
+		if (parent == NULL && rr_end - rr_start >= 7) {
+			p = rr_start;
+			if (memcmp(p, "SP\x07\x01\xbe\xef", 6) == 0) {
+				/*
+				 * SP extension stores the suspOffset
+				 * (Number of bytes to skip between
+				 * filename and SUSP records.)
+				 * It is mandatory by the SUSP standard
+				 * (IEEE 1281).
+				 *
+				 * It allows SUSP to coexist with
+				 * non-SUSP uses of the System
+				 * Use Area by placing non-SUSP data
+				 * before SUSP data.
+				 *
+				 * SP extension must be in the root
+				 * directory entry, disable all SUSP
+				 * processing if not found.
+				 */
+				iso9660->suspOffset = p[6];
+				iso9660->seenSUSP = 1;
+				rr_start += 7;
+			}
+		}
+		if (iso9660->seenSUSP) {
+			int r;
+
+			file->name_continues = 0;
+			file->symlink_continues = 0;
+			rr_start += iso9660->suspOffset;
+			r = parse_rockridge(a, file, rr_start, rr_end);
+			if (r != ARCHIVE_OK)
+				goto fail;
+			/*
+			 * A file size of symbolic link files in ISO images
+			 * made by makefs is not zero and its location is
+			 * the same as those of next regular file. That is
+			 * the same as hard like file and it causes unexpected
+			 * error. 
+			 */
+			if (file->size > 0 &&
+			    (file->mode & AE_IFMT) == AE_IFLNK) {
+				file->size = 0;
+				file->number = -1;
+				file->offset = -1;
+			}
+		} else
+			/* If there isn't SUSP, disable parsing
+			 * rock ridge extensions. */
+			iso9660->opt_support_rockridge = 0;
+	}
+
+	file->nlinks = 1;/* Reset nlink. we'll calculate it later. */
+	/* Tell file's parent how many children that parent has. */
+	if (parent != NULL && (flags & 0x02))
+		parent->subdirs++;
+
+	if (iso9660->seenRockridge) {
+		if (parent != NULL && parent->parent == NULL &&
+		    (flags & 0x02) && iso9660->rr_moved == NULL &&
+		    file->name.s &&
+		    (strcmp(file->name.s, "rr_moved") == 0 ||
+		     strcmp(file->name.s, ".rr_moved") == 0)) {
+			iso9660->rr_moved = file;
+			file->rr_moved = 1;
+			file->rr_moved_has_re_only = 1;
+			file->re = 0;
+			parent->subdirs--;
+		} else if (file->re) {
+			/*
+			 * Sanity check: file's parent is rr_moved.
+			 */
+			if (parent == NULL || parent->rr_moved == 0) {
+				archive_set_error(&a->archive,
+				    ARCHIVE_ERRNO_MISC,
+				    "Invalid Rockridge RE");
+				goto fail;
+			}
+			/*
+			 * Sanity check: file does not have "CL" extension.
+			 */
+			if (file->cl_offset) {
+				archive_set_error(&a->archive,
+				    ARCHIVE_ERRNO_MISC,
+				    "Invalid Rockridge RE and CL");
+				goto fail;
+			}
+			/*
+			 * Sanity check: The file type must be a directory.
+			 */
+			if ((flags & 0x02) == 0) {
+				archive_set_error(&a->archive,
+				    ARCHIVE_ERRNO_MISC,
+				    "Invalid Rockridge RE");
+				goto fail;
+			}
+		} else if (parent != NULL && parent->rr_moved)
+			file->rr_moved_has_re_only = 0;
+		else if (parent != NULL && (flags & 0x02) &&
+		    (parent->re || parent->re_descendant))
+			file->re_descendant = 1;
+		if (file->cl_offset) {
+			struct file_info *r;
+
+			if (parent == NULL || parent->parent == NULL) {
+				archive_set_error(&a->archive,
+				    ARCHIVE_ERRNO_MISC,
+				    "Invalid Rockridge CL");
+				goto fail;
+			}
+			/*
+			 * Sanity check: The file type must be a regular file.
+			 */
+			if ((flags & 0x02) != 0) {
+				archive_set_error(&a->archive,
+				    ARCHIVE_ERRNO_MISC,
+				    "Invalid Rockridge CL");
+				goto fail;
+			}
+			parent->subdirs++;
+			/* Overwrite an offset and a number of this "CL" entry
+			 * to appear before other dirs. "+1" to those is to
+			 * make sure to appear after "RE" entry which this
+			 * "CL" entry should be connected with. */
+			file->offset = file->number = file->cl_offset + 1;
+
+			/*
+			 * Sanity check: cl_offset does not point at its
+			 * the parents or itself.
+			 */
+			for (r = parent; r; r = r->parent) {
+				if (r->offset == file->cl_offset) {
+					archive_set_error(&a->archive,
+					    ARCHIVE_ERRNO_MISC,
+					    "Invalid Rockridge CL");
+					goto fail;
+				}
+			}
+			if (file->cl_offset == file->offset ||
+			    parent->rr_moved) {
+				archive_set_error(&a->archive,
+				    ARCHIVE_ERRNO_MISC,
+				    "Invalid Rockridge CL");
+				goto fail;
+			}
+		}
+	}
+
+#if DEBUG
+	/* DEBUGGING: Warn about attributes I don't yet fully support. */
+	if ((flags & ~0x02) != 0) {
+		fprintf(stderr, "\n ** Unrecognized flag: ");
+		dump_isodirrec(stderr, isodirrec);
+		fprintf(stderr, "\n");
+	} else if (toi(isodirrec + DR_volume_sequence_number_offset, 2) != 1) {
+		fprintf(stderr, "\n ** Unrecognized sequence number: ");
+		dump_isodirrec(stderr, isodirrec);
+		fprintf(stderr, "\n");
+	} else if (*(isodirrec + DR_file_unit_size_offset) != 0) {
+		fprintf(stderr, "\n ** Unexpected file unit size: ");
+		dump_isodirrec(stderr, isodirrec);
+		fprintf(stderr, "\n");
+	} else if (*(isodirrec + DR_interleave_offset) != 0) {
+		fprintf(stderr, "\n ** Unexpected interleave: ");
+		dump_isodirrec(stderr, isodirrec);
+		fprintf(stderr, "\n");
+	} else if (*(isodirrec + DR_ext_attr_length_offset) != 0) {
+		fprintf(stderr, "\n ** Unexpected extended attribute length: ");
+		dump_isodirrec(stderr, isodirrec);
+		fprintf(stderr, "\n");
+	}
+#endif
+	register_file(iso9660, file);
+	return (file);
+fail:
+	archive_string_free(&file->name);
+	free(file);
+	return (NULL);
+}
+
+static int
+parse_rockridge(struct archive_read *a, struct file_info *file,
+    const unsigned char *p, const unsigned char *end)
+{
+	struct iso9660 *iso9660;
+
+	iso9660 = (struct iso9660 *)(a->format->data);
+
+	while (p + 4 <= end  /* Enough space for another entry. */
+	    && p[0] >= 'A' && p[0] <= 'Z' /* Sanity-check 1st char of name. */
+	    && p[1] >= 'A' && p[1] <= 'Z' /* Sanity-check 2nd char of name. */
+	    && p[2] >= 4 /* Sanity-check length. */
+	    && p + p[2] <= end) { /* Sanity-check length. */
+		const unsigned char *data = p + 4;
+		int data_length = p[2] - 4;
+		int version = p[3];
+
+		switch(p[0]) {
+		case 'C':
+			if (p[1] == 'E') {
+				if (version == 1 && data_length == 24) {
+					/*
+					 * CE extension comprises:
+					 *   8 byte sector containing extension
+					 *   8 byte offset w/in above sector
+					 *   8 byte length of continuation
+					 */
+					int32_t location =
+					    archive_le32dec(data);
+					file->ce_offset =
+					    archive_le32dec(data+8);
+					file->ce_size =
+					    archive_le32dec(data+16);
+					if (register_CE(a, location, file)
+					    != ARCHIVE_OK)
+						return (ARCHIVE_FATAL);
+				}
+			}
+			else if (p[1] == 'L') {
+				if (version == 1 && data_length == 8) {
+					file->cl_offset = (uint64_t)
+					    iso9660->logical_block_size *
+					    (uint64_t)archive_le32dec(data);
+					iso9660->seenRockridge = 1;
+				}
+			}
+			break;
+		case 'N':
+			if (p[1] == 'M') {
+				if (version == 1) {
+					parse_rockridge_NM1(file,
+					    data, data_length);
+					iso9660->seenRockridge = 1;
+				}
+			}
+			break;
+		case 'P':
+			/*
+			 * PD extension is padding;
+			 * contents are always ignored.
+			 *
+			 * PL extension won't appear;
+			 * contents are always ignored.
+			 */
+			if (p[1] == 'N') {
+				if (version == 1 && data_length == 16) {
+					file->rdev = toi(data,4);
+					file->rdev <<= 32;
+					file->rdev |= toi(data + 8, 4);
+					iso9660->seenRockridge = 1;
+				}
+			}
+			else if (p[1] == 'X') {
+				/*
+				 * PX extension comprises:
+				 *   8 bytes for mode,
+				 *   8 bytes for nlinks,
+				 *   8 bytes for uid,
+				 *   8 bytes for gid,
+				 *   8 bytes for inode.
+				 */
+				if (version == 1) {
+					if (data_length >= 8)
+						file->mode
+						    = toi(data, 4);
+					if (data_length >= 16)
+						file->nlinks
+						    = toi(data + 8, 4);
+					if (data_length >= 24)
+						file->uid
+						    = toi(data + 16, 4);
+					if (data_length >= 32)
+						file->gid
+						    = toi(data + 24, 4);
+					if (data_length >= 40)
+						file->number
+						    = toi(data + 32, 4);
+					iso9660->seenRockridge = 1;
+				}
+			}
+			break;
+		case 'R':
+			if (p[1] == 'E' && version == 1) {
+				file->re = 1;
+				iso9660->seenRockridge = 1;
+			}
+			else if (p[1] == 'R' && version == 1) {
+				/*
+				 * RR extension comprises:
+				 *    one byte flag value
+				 * This extension is obsolete,
+				 * so contents are always ignored.
+				 */
+			}
+			break;
+		case 'S':
+			if (p[1] == 'L') {
+				if (version == 1) {
+					parse_rockridge_SL1(file,
+					    data, data_length);
+					iso9660->seenRockridge = 1;
+				}
+			}
+			else if (p[1] == 'T'
+			    && data_length == 0 && version == 1) {
+				/*
+				 * ST extension marks end of this
+				 * block of SUSP entries.
+				 *
+				 * It allows SUSP to coexist with
+				 * non-SUSP uses of the System
+				 * Use Area by placing non-SUSP data
+				 * after SUSP data.
+				 */
+				iso9660->seenSUSP = 0;
+				iso9660->seenRockridge = 0;
+				return (ARCHIVE_OK);
+			}
+			break;
+		case 'T':
+			if (p[1] == 'F') {
+				if (version == 1) {
+					parse_rockridge_TF1(file,
+					    data, data_length);
+					iso9660->seenRockridge = 1;
+				}
+			}
+			break;
+		case 'Z':
+			if (p[1] == 'F') {
+				if (version == 1)
+					parse_rockridge_ZF1(file,
+					    data, data_length);
+			}
+			break;
+		default:
+			break;
+		}
+
+		p += p[2];
+	}
+	return (ARCHIVE_OK);
+}
+
+static int
+register_CE(struct archive_read *a, int32_t location,
+    struct file_info *file)
+{
+	struct iso9660 *iso9660;
+	struct read_ce_queue *heap;
+	struct read_ce_req *p;
+	uint64_t offset, parent_offset;
+	int hole, parent;
+
+	iso9660 = (struct iso9660 *)(a->format->data);
+	offset = ((uint64_t)location) * (uint64_t)iso9660->logical_block_size;
+	if (((file->mode & AE_IFMT) == AE_IFREG &&
+	    offset >= file->offset) ||
+	    offset < iso9660->current_position ||
+	    (((uint64_t)file->ce_offset) + file->ce_size)
+	      > (uint64_t)iso9660->logical_block_size ||
+	    offset + file->ce_offset + file->ce_size
+		  > iso9660->volume_size) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+		    "Invalid parameter in SUSP \"CE\" extension");
+		return (ARCHIVE_FATAL);
+	}
+
+	/* Expand our CE list as necessary. */
+	heap = &(iso9660->read_ce_req);
+	if (heap->cnt >= heap->allocated) {
+		int new_size;
+
+		if (heap->allocated < 16)
+			new_size = 16;
+		else
+			new_size = heap->allocated * 2;
+		/* Overflow might keep us from growing the list. */
+		if (new_size <= heap->allocated) {
+			archive_set_error(&a->archive, ENOMEM, "Out of memory");
+			return (ARCHIVE_FATAL);
+		}
+		p = calloc(new_size, sizeof(p[0]));
+		if (p == NULL) {
+			archive_set_error(&a->archive, ENOMEM, "Out of memory");
+			return (ARCHIVE_FATAL);
+		}
+		if (heap->reqs != NULL) {
+			memcpy(p, heap->reqs, heap->cnt * sizeof(*p));
+			free(heap->reqs);
+		}
+		heap->reqs = p;
+		heap->allocated = new_size;
+	}
+
+	/*
+	 * Start with hole at end, walk it up tree to find insertion point.
+	 */
+	hole = heap->cnt++;
+	while (hole > 0) {
+		parent = (hole - 1)/2;
+		parent_offset = heap->reqs[parent].offset;
+		if (offset >= parent_offset) {
+			heap->reqs[hole].offset = offset;
+			heap->reqs[hole].file = file;
+			return (ARCHIVE_OK);
+		}
+		/* Move parent into hole <==> move hole up tree. */
+		heap->reqs[hole] = heap->reqs[parent];
+		hole = parent;
+	}
+	heap->reqs[0].offset = offset;
+	heap->reqs[0].file = file;
+	return (ARCHIVE_OK);
+}
+
+static void
+next_CE(struct read_ce_queue *heap)
+{
+	uint64_t a_offset, b_offset, c_offset;
+	int a, b, c;
+	struct read_ce_req tmp;
+
+	if (heap->cnt < 1)
+		return;
+
+	/*
+	 * Move the last item in the heap to the root of the tree
+	 */
+	heap->reqs[0] = heap->reqs[--(heap->cnt)];
+
+	/*
+	 * Rebalance the heap.
+	 */
+	a = 0; /* Starting element and its offset */
+	a_offset = heap->reqs[a].offset;
+	for (;;) {
+		b = a + a + 1; /* First child */
+		if (b >= heap->cnt)
+			return;
+		b_offset = heap->reqs[b].offset;
+		c = b + 1; /* Use second child if it is smaller. */
+		if (c < heap->cnt) {
+			c_offset = heap->reqs[c].offset;
+			if (c_offset < b_offset) {
+				b = c;
+				b_offset = c_offset;
+			}
+		}
+		if (a_offset <= b_offset)
+			return;
+		tmp = heap->reqs[a];
+		heap->reqs[a] = heap->reqs[b];
+		heap->reqs[b] = tmp;
+		a = b;
+	}
+}
+
+
+static int
+read_CE(struct archive_read *a, struct iso9660 *iso9660)
+{
+	struct read_ce_queue *heap;
+	const unsigned char *b, *p, *end;
+	struct file_info *file;
+	size_t step;
+	int r;
+
+	/* Read data which RRIP "CE" extension points. */
+	heap = &(iso9660->read_ce_req);
+	step = iso9660->logical_block_size;
+	while (heap->cnt &&
+	    heap->reqs[0].offset == iso9660->current_position) {
+		b = __archive_read_ahead(a, step, NULL);
+		if (b == NULL) {
+			archive_set_error(&a->archive,
+			    ARCHIVE_ERRNO_MISC,
+			    "Failed to read full block when scanning "
+			    "ISO9660 directory list");
+			return (ARCHIVE_FATAL);
+		}
+		do {
+			file = heap->reqs[0].file;
+			if (file->ce_offset + file->ce_size > step) {
+				archive_set_error(&a->archive,
+				    ARCHIVE_ERRNO_FILE_FORMAT,
+				    "Malformed CE information");
+				return (ARCHIVE_FATAL);
+			}
+			p = b + file->ce_offset;
+			end = p + file->ce_size;
+			next_CE(heap);
+			r = parse_rockridge(a, file, p, end);
+			if (r != ARCHIVE_OK)
+				return (ARCHIVE_FATAL);
+		} while (heap->cnt &&
+		    heap->reqs[0].offset == iso9660->current_position);
+		/* NOTE: Do not move this consume's code to front of
+		 * do-while loop. Registration of nested CE extension
+		 * might cause error because of current position. */
+		__archive_read_consume(a, step);
+		iso9660->current_position += step;
+	}
+	return (ARCHIVE_OK);
+}
+
+static void
+parse_rockridge_NM1(struct file_info *file,
+		    const unsigned char *data, int data_length)
+{
+	if (!file->name_continues)
+		archive_string_empty(&file->name);
+	file->name_continues = 0;
+	if (data_length < 1)
+		return;
+	/*
+	 * NM version 1 extension comprises:
+	 *   1 byte flag, value is one of:
+	 *     = 0: remainder is name
+	 *     = 1: remainder is name, next NM entry continues name
+	 *     = 2: "."
+	 *     = 4: ".."
+	 *     = 32: Implementation specific
+	 *     All other values are reserved.
+	 */
+	switch(data[0]) {
+	case 0:
+		if (data_length < 2)
+			return;
+		archive_strncat(&file->name,
+		    (const char *)data + 1, data_length - 1);
+		break;
+	case 1:
+		if (data_length < 2)
+			return;
+		archive_strncat(&file->name,
+		    (const char *)data + 1, data_length - 1);
+		file->name_continues = 1;
+		break;
+	case 2:
+		archive_strcat(&file->name, ".");
+		break;
+	case 4:
+		archive_strcat(&file->name, "..");
+		break;
+	default:
+		return;
+	}
+
+}
+
+static void
+parse_rockridge_TF1(struct file_info *file, const unsigned char *data,
+    int data_length)
+{
+	char flag;
+	/*
+	 * TF extension comprises:
+	 *   one byte flag
+	 *   create time (optional)
+	 *   modify time (optional)
+	 *   access time (optional)
+	 *   attribute time (optional)
+	 *  Time format and presence of fields
+	 *  is controlled by flag bits.
+	 */
+	if (data_length < 1)
+		return;
+	flag = data[0];
+	++data;
+	--data_length;
+	if (flag & 0x80) {
+		/* Use 17-byte time format. */
+		if ((flag & 1) && data_length >= 17) {
+			/* Create time. */
+			file->birthtime_is_set = 1;
+			file->birthtime = isodate17(data);
+			data += 17;
+			data_length -= 17;
+		}
+		if ((flag & 2) && data_length >= 17) {
+			/* Modify time. */
+			file->mtime = isodate17(data);
+			data += 17;
+			data_length -= 17;
+		}
+		if ((flag & 4) && data_length >= 17) {
+			/* Access time. */
+			file->atime = isodate17(data);
+			data += 17;
+			data_length -= 17;
+		}
+		if ((flag & 8) && data_length >= 17) {
+			/* Attribute change time. */
+			file->ctime = isodate17(data);
+		}
+	} else {
+		/* Use 7-byte time format. */
+		if ((flag & 1) && data_length >= 7) {
+			/* Create time. */
+			file->birthtime_is_set = 1;
+			file->birthtime = isodate7(data);
+			data += 7;
+			data_length -= 7;
+		}
+		if ((flag & 2) && data_length >= 7) {
+			/* Modify time. */
+			file->mtime = isodate7(data);
+			data += 7;
+			data_length -= 7;
+		}
+		if ((flag & 4) && data_length >= 7) {
+			/* Access time. */
+			file->atime = isodate7(data);
+			data += 7;
+			data_length -= 7;
+		}
+		if ((flag & 8) && data_length >= 7) {
+			/* Attribute change time. */
+			file->ctime = isodate7(data);
+		}
+	}
+}
+
+static void
+parse_rockridge_SL1(struct file_info *file, const unsigned char *data,
+    int data_length)
+{
+	const char *separator = "";
+
+	if (!file->symlink_continues || file->symlink.length < 1)
+		archive_string_empty(&file->symlink);
+	file->symlink_continues = 0;
+
+	/*
+	 * Defined flag values:
+	 *  0: This is the last SL record for this symbolic link
+	 *  1: this symbolic link field continues in next SL entry
+	 *  All other values are reserved.
+	 */
+	if (data_length < 1)
+		return;
+	switch(*data) {
+	case 0:
+		break;
+	case 1:
+		file->symlink_continues = 1;
+		break;
+	default:
+		return;
+	}
+	++data;  /* Skip flag byte. */
+	--data_length;
+
+	/*
+	 * SL extension body stores "components".
+	 * Basically, this is a complicated way of storing
+	 * a POSIX path.  It also interferes with using
+	 * symlinks for storing non-path data. <sigh>
+	 *
+	 * Each component is 2 bytes (flag and length)
+	 * possibly followed by name data.
+	 */
+	while (data_length >= 2) {
+		unsigned char flag = *data++;
+		unsigned char nlen = *data++;
+		data_length -= 2;
+
+		archive_strcat(&file->symlink, separator);
+		separator = "/";
+
+		switch(flag) {
+		case 0: /* Usual case, this is text. */
+			if (data_length < nlen)
+				return;
+			archive_strncat(&file->symlink,
+			    (const char *)data, nlen);
+			break;
+		case 0x01: /* Text continues in next component. */
+			if (data_length < nlen)
+				return;
+			archive_strncat(&file->symlink,
+			    (const char *)data, nlen);
+			separator = "";
+			break;
+		case 0x02: /* Current dir. */
+			archive_strcat(&file->symlink, ".");
+			break;
+		case 0x04: /* Parent dir. */
+			archive_strcat(&file->symlink, "..");
+			break;
+		case 0x08: /* Root of filesystem. */
+			archive_strcat(&file->symlink, "/");
+			separator = "";
+			break;
+		case 0x10: /* Undefined (historically "volume root" */
+			archive_string_empty(&file->symlink);
+			archive_strcat(&file->symlink, "ROOT");
+			break;
+		case 0x20: /* Undefined (historically "hostname") */
+			archive_strcat(&file->symlink, "hostname");
+			break;
+		default:
+			/* TODO: issue a warning ? */
+			return;
+		}
+		data += nlen;
+		data_length -= nlen;
+	}
+}
+
+static void
+parse_rockridge_ZF1(struct file_info *file, const unsigned char *data,
+    int data_length)
+{
+
+	if (data[0] == 0x70 && data[1] == 0x7a && data_length == 12) {
+		/* paged zlib */
+		file->pz = 1;
+		file->pz_log2_bs = data[3];
+		file->pz_uncompressed_size = archive_le32dec(&data[4]);
+	}
+}
+
+static void
+register_file(struct iso9660 *iso9660, struct file_info *file)
+{
+
+	file->use_next = iso9660->use_files;
+	iso9660->use_files = file;
+}
+
+static void
+release_files(struct iso9660 *iso9660)
+{
+	struct content *con, *connext;
+	struct file_info *file;
+
+	file = iso9660->use_files;
+	while (file != NULL) {
+		struct file_info *next = file->use_next;
+
+		archive_string_free(&file->name);
+		archive_string_free(&file->symlink);
+		free(file->utf16be_name);
+		con = file->contents.first;
+		while (con != NULL) {
+			connext = con->next;
+			free(con);
+			con = connext;
+		}
+		free(file);
+		file = next;
+	}
+}
+
+static int
+next_entry_seek(struct archive_read *a, struct iso9660 *iso9660,
+    struct file_info **pfile)
+{
+	struct file_info *file;
+	int r;
+
+	r = next_cache_entry(a, iso9660, pfile);
+	if (r != ARCHIVE_OK)
+		return (r);
+	file = *pfile;
+
+	/* Don't waste time seeking for zero-length bodies. */
+	if (file->size == 0)
+		file->offset = iso9660->current_position;
+
+	/* flush any remaining bytes from the last round to ensure
+	 * we're positioned */
+	if (iso9660->entry_bytes_unconsumed) {
+		__archive_read_consume(a, iso9660->entry_bytes_unconsumed);
+		iso9660->entry_bytes_unconsumed = 0;
+	}
+
+	/* Seek forward to the start of the entry. */
+	if (iso9660->current_position < file->offset) {
+		int64_t step;
+
+		step = file->offset - iso9660->current_position;
+		step = __archive_read_consume(a, step);
+		if (step < 0)
+			return ((int)step);
+		iso9660->current_position = file->offset;
+	}
+
+	/* We found body of file; handle it now. */
+	return (ARCHIVE_OK);
+}
+
+static int
+next_cache_entry(struct archive_read *a, struct iso9660 *iso9660,
+    struct file_info **pfile)
+{
+	struct file_info *file;
+	struct {
+		struct file_info	*first;
+		struct file_info	**last;
+	}	empty_files;
+	int64_t number;
+	int count;
+
+	file = cache_get_entry(iso9660);
+	if (file != NULL) {
+		*pfile = file;
+		return (ARCHIVE_OK);
+	}
+
+	for (;;) {
+		struct file_info *re, *d;
+
+		*pfile = file = next_entry(iso9660);
+		if (file == NULL) {
+			/*
+			 * If directory entries all which are descendant of
+			 * rr_moved are still remaining, expose their.
+			 */
+			if (iso9660->re_files.first != NULL && 
+			    iso9660->rr_moved != NULL &&
+			    iso9660->rr_moved->rr_moved_has_re_only)
+				/* Expose "rr_moved" entry. */
+				cache_add_entry(iso9660, iso9660->rr_moved);
+			while ((re = re_get_entry(iso9660)) != NULL) {
+				/* Expose its descendant dirs. */
+				while ((d = rede_get_entry(re)) != NULL)
+					cache_add_entry(iso9660, d);
+			}
+			if (iso9660->cache_files.first != NULL)
+				return (next_cache_entry(a, iso9660, pfile));
+			return (ARCHIVE_EOF);
+		}
+
+		if (file->cl_offset) {
+			struct file_info *first_re = NULL;
+			int nexted_re = 0;
+
+			/*
+			 * Find "RE" dir for the current file, which
+			 * has "CL" flag.
+			 */
+			while ((re = re_get_entry(iso9660))
+			    != first_re) {
+				if (first_re == NULL)
+					first_re = re;
+				if (re->offset == file->cl_offset) {
+					re->parent->subdirs--;
+					re->parent = file->parent;
+					re->re = 0;
+					if (re->parent->re_descendant) {
+						nexted_re = 1;
+						re->re_descendant = 1;
+						if (rede_add_entry(re) < 0)
+							goto fatal_rr;
+						/* Move a list of descendants
+						 * to a new ancestor. */
+						while ((d = rede_get_entry(
+						    re)) != NULL)
+							if (rede_add_entry(d)
+							    < 0)
+								goto fatal_rr;
+						break;
+					}
+					/* Replace the current file
+					 * with "RE" dir */
+					*pfile = file = re;
+					/* Expose its descendant */
+					while ((d = rede_get_entry(
+					    file)) != NULL)
+						cache_add_entry(
+						    iso9660, d);
+					break;
+				} else
+					re_add_entry(iso9660, re);
+			}
+			if (nexted_re) {
+				/*
+				 * Do not expose this at this time
+				 * because we have not gotten its full-path
+				 * name yet.
+				 */
+				continue;
+			}
+		} else if ((file->mode & AE_IFMT) == AE_IFDIR) {
+			int r;
+
+			/* Read file entries in this dir. */
+			r = read_children(a, file);
+			if (r != ARCHIVE_OK)
+				return (r);
+
+			/*
+			 * Handle a special dir of Rockridge extensions,
+			 * "rr_moved".
+			 */
+			if (file->rr_moved) {
+				/*
+				 * If this has only the subdirectories which
+				 * have "RE" flags, do not expose at this time.
+				 */
+				if (file->rr_moved_has_re_only)
+					continue;
+				/* Otherwise expose "rr_moved" entry. */
+			} else if (file->re) {
+				/*
+				 * Do not expose this at this time
+				 * because we have not gotten its full-path
+				 * name yet.
+				 */
+				re_add_entry(iso9660, file);
+				continue;
+			} else if (file->re_descendant) {
+				/*
+				 * If the top level "RE" entry of this entry
+				 * is not exposed, we, accordingly, should not
+				 * expose this entry at this time because
+				 * we cannot make its proper full-path name.
+				 */
+				if (rede_add_entry(file) == 0)
+					continue;
+				/* Otherwise we can expose this entry because
+				 * it seems its top level "RE" has already been
+				 * exposed. */
+			}
+		}
+		break;
+	}
+
+	if ((file->mode & AE_IFMT) != AE_IFREG || file->number == -1)
+		return (ARCHIVE_OK);
+
+	count = 0;
+	number = file->number;
+	iso9660->cache_files.first = NULL;
+	iso9660->cache_files.last = &(iso9660->cache_files.first);
+	empty_files.first = NULL;
+	empty_files.last = &empty_files.first;
+	/* Collect files which has the same file serial number.
+	 * Peek pending_files so that file which number is different
+	 * is not put back. */
+	while (iso9660->pending_files.used > 0 &&
+	    (iso9660->pending_files.files[0]->number == -1 ||
+	     iso9660->pending_files.files[0]->number == number)) {
+		if (file->number == -1) {
+			/* This file has the same offset
+			 * but it's wrong offset which empty files
+			 * and symlink files have.
+			 * NOTE: This wrong offset was recorded by
+			 * old mkisofs utility. If ISO images is
+			 * created by latest mkisofs, this does not
+			 * happen.
+			 */
+			file->next = NULL;
+			*empty_files.last = file;
+			empty_files.last = &(file->next);
+		} else {
+			count++;
+			cache_add_entry(iso9660, file);
+		}
+		file = next_entry(iso9660);
+	}
+
+	if (count == 0) {
+		*pfile = file;
+		return ((file == NULL)?ARCHIVE_EOF:ARCHIVE_OK);
+	}
+	if (file->number == -1) {
+		file->next = NULL;
+		*empty_files.last = file;
+		empty_files.last = &(file->next);
+	} else {
+		count++;
+		cache_add_entry(iso9660, file);
+	}
+
+	if (count > 1) {
+		/* The count is the same as number of hardlink,
+		 * so much so that each nlinks of files in cache_file
+		 * is overwritten by value of the count.
+		 */
+		for (file = iso9660->cache_files.first;
+		    file != NULL; file = file->next)
+			file->nlinks = count;
+	}
+	/* If there are empty files, that files are added
+	 * to the tail of the cache_files. */
+	if (empty_files.first != NULL) {
+		*iso9660->cache_files.last = empty_files.first;
+		iso9660->cache_files.last = empty_files.last;
+	}
+	*pfile = cache_get_entry(iso9660);
+	return ((*pfile == NULL)?ARCHIVE_EOF:ARCHIVE_OK);
+
+fatal_rr:
+	archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+	    "Failed to connect 'CL' pointer to 'RE' rr_moved pointer of "
+	    "Rockridge extensions: current position = %jd, CL offset = %jd",
+	    (intmax_t)iso9660->current_position, (intmax_t)file->cl_offset);
+	return (ARCHIVE_FATAL);
+}
+
+static inline void
+re_add_entry(struct iso9660 *iso9660, struct file_info *file)
+{
+	file->re_next = NULL;
+	*iso9660->re_files.last = file;
+	iso9660->re_files.last = &(file->re_next);
+}
+
+static inline struct file_info *
+re_get_entry(struct iso9660 *iso9660)
+{
+	struct file_info *file;
+
+	if ((file = iso9660->re_files.first) != NULL) {
+		iso9660->re_files.first = file->re_next;
+		if (iso9660->re_files.first == NULL)
+			iso9660->re_files.last =
+			    &(iso9660->re_files.first);
+	}
+	return (file);
+}
+
+static inline int
+rede_add_entry(struct file_info *file)
+{
+	struct file_info *re;
+
+	/*
+	 * Find "RE" entry.
+	 */
+	re = file->parent;
+	while (re != NULL && !re->re)
+		re = re->parent;
+	if (re == NULL)
+		return (-1);
+
+	file->re_next = NULL;
+	*re->rede_files.last = file;
+	re->rede_files.last = &(file->re_next);
+	return (0);
+}
+
+static inline struct file_info *
+rede_get_entry(struct file_info *re)
+{
+	struct file_info *file;
+
+	if ((file = re->rede_files.first) != NULL) {
+		re->rede_files.first = file->re_next;
+		if (re->rede_files.first == NULL)
+			re->rede_files.last =
+			    &(re->rede_files.first);
+	}
+	return (file);
+}
+
+static inline void
+cache_add_entry(struct iso9660 *iso9660, struct file_info *file)
+{
+	file->next = NULL;
+	*iso9660->cache_files.last = file;
+	iso9660->cache_files.last = &(file->next);
+}
+
+static inline struct file_info *
+cache_get_entry(struct iso9660 *iso9660)
+{
+	struct file_info *file;
+
+	if ((file = iso9660->cache_files.first) != NULL) {
+		iso9660->cache_files.first = file->next;
+		if (iso9660->cache_files.first == NULL)
+			iso9660->cache_files.last =
+			    &(iso9660->cache_files.first);
+	}
+	return (file);
+}
+
+static int
+heap_add_entry(struct archive_read *a, struct heap_queue *heap,
+    struct file_info *file, uint64_t key)
+{
+	uint64_t file_key, parent_key;
+	int hole, parent;
+
+	/* Expand our pending files list as necessary. */
+	if (heap->used >= heap->allocated) {
+		struct file_info **new_pending_files;
+		int new_size = heap->allocated * 2;
+
+		if (heap->allocated < 1024)
+			new_size = 1024;
+		/* Overflow might keep us from growing the list. */
+		if (new_size <= heap->allocated) {
+			archive_set_error(&a->archive,
+			    ENOMEM, "Out of memory");
+			return (ARCHIVE_FATAL);
+		}
+		new_pending_files = (struct file_info **)
+		    malloc(new_size * sizeof(new_pending_files[0]));
+		if (new_pending_files == NULL) {
+			archive_set_error(&a->archive,
+			    ENOMEM, "Out of memory");
+			return (ARCHIVE_FATAL);
+		}
+		if (heap->allocated)
+			memcpy(new_pending_files, heap->files,
+			    heap->allocated * sizeof(new_pending_files[0]));
+		if (heap->files != NULL)
+			free(heap->files);
+		heap->files = new_pending_files;
+		heap->allocated = new_size;
+	}
+
+	file_key = file->key = key;
+
+	/*
+	 * Start with hole at end, walk it up tree to find insertion point.
+	 */
+	hole = heap->used++;
+	while (hole > 0) {
+		parent = (hole - 1)/2;
+		parent_key = heap->files[parent]->key;
+		if (file_key >= parent_key) {
+			heap->files[hole] = file;
+			return (ARCHIVE_OK);
+		}
+		/* Move parent into hole <==> move hole up tree. */
+		heap->files[hole] = heap->files[parent];
+		hole = parent;
+	}
+	heap->files[0] = file;
+
+	return (ARCHIVE_OK);
+}
+
+static struct file_info *
+heap_get_entry(struct heap_queue *heap)
+{
+	uint64_t a_key, b_key, c_key;
+	int a, b, c;
+	struct file_info *r, *tmp;
+
+	if (heap->used < 1)
+		return (NULL);
+
+	/*
+	 * The first file in the list is the earliest; we'll return this.
+	 */
+	r = heap->files[0];
+
+	/*
+	 * Move the last item in the heap to the root of the tree
+	 */
+	heap->files[0] = heap->files[--(heap->used)];
+
+	/*
+	 * Rebalance the heap.
+	 */
+	a = 0; /* Starting element and its heap key */
+	a_key = heap->files[a]->key;
+	for (;;) {
+		b = a + a + 1; /* First child */
+		if (b >= heap->used)
+			return (r);
+		b_key = heap->files[b]->key;
+		c = b + 1; /* Use second child if it is smaller. */
+		if (c < heap->used) {
+			c_key = heap->files[c]->key;
+			if (c_key < b_key) {
+				b = c;
+				b_key = c_key;
+			}
+		}
+		if (a_key <= b_key)
+			return (r);
+		tmp = heap->files[a];
+		heap->files[a] = heap->files[b];
+		heap->files[b] = tmp;
+		a = b;
+	}
+}
+
+static unsigned int
+toi(const void *p, int n)
+{
+	const unsigned char *v = (const unsigned char *)p;
+	if (n > 1)
+		return v[0] + 256 * toi(v + 1, n - 1);
+	if (n == 1)
+		return v[0];
+	return (0);
+}
+
+static time_t
+isodate7(const unsigned char *v)
+{
+	struct tm tm;
+	int offset;
+	time_t t;
+
+	memset(&tm, 0, sizeof(tm));
+	tm.tm_year = v[0];
+	tm.tm_mon = v[1] - 1;
+	tm.tm_mday = v[2];
+	tm.tm_hour = v[3];
+	tm.tm_min = v[4];
+	tm.tm_sec = v[5];
+	/* v[6] is the signed timezone offset, in 1/4-hour increments. */
+	offset = ((const signed char *)v)[6];
+	if (offset > -48 && offset < 52) {
+		tm.tm_hour -= offset / 4;
+		tm.tm_min -= (offset % 4) * 15;
+	}
+	t = time_from_tm(&tm);
+	if (t == (time_t)-1)
+		return ((time_t)0);
+	return (t);
+}
+
+static time_t
+isodate17(const unsigned char *v)
+{
+	struct tm tm;
+	int offset;
+	time_t t;
+
+	memset(&tm, 0, sizeof(tm));
+	tm.tm_year = (v[0] - '0') * 1000 + (v[1] - '0') * 100
+	    + (v[2] - '0') * 10 + (v[3] - '0')
+	    - 1900;
+	tm.tm_mon = (v[4] - '0') * 10 + (v[5] - '0');
+	tm.tm_mday = (v[6] - '0') * 10 + (v[7] - '0');
+	tm.tm_hour = (v[8] - '0') * 10 + (v[9] - '0');
+	tm.tm_min = (v[10] - '0') * 10 + (v[11] - '0');
+	tm.tm_sec = (v[12] - '0') * 10 + (v[13] - '0');
+	/* v[16] is the signed timezone offset, in 1/4-hour increments. */
+	offset = ((const signed char *)v)[16];
+	if (offset > -48 && offset < 52) {
+		tm.tm_hour -= offset / 4;
+		tm.tm_min -= (offset % 4) * 15;
+	}
+	t = time_from_tm(&tm);
+	if (t == (time_t)-1)
+		return ((time_t)0);
+	return (t);
+}
+
+static time_t
+time_from_tm(struct tm *t)
+{
+#if HAVE_TIMEGM
+        /* Use platform timegm() if available. */
+        return (timegm(t));
+#elif HAVE__MKGMTIME64
+        return (_mkgmtime64(t));
+#else
+        /* Else use direct calculation using POSIX assumptions. */
+        /* First, fix up tm_yday based on the year/month/day. */
+        if (mktime(t) == (time_t)-1)
+                return ((time_t)-1);
+        /* Then we can compute timegm() from first principles. */
+        return (t->tm_sec
+            + t->tm_min * 60
+            + t->tm_hour * 3600
+            + t->tm_yday * 86400
+            + (t->tm_year - 70) * 31536000
+            + ((t->tm_year - 69) / 4) * 86400
+            - ((t->tm_year - 1) / 100) * 86400
+            + ((t->tm_year + 299) / 400) * 86400);
+#endif
+}
+
+static const char *
+build_pathname(struct archive_string *as, struct file_info *file, int depth)
+{
+	// Plain ISO9660 only allows 8 dir levels; if we get
+	// to 1000, then something is very, very wrong.
+	if (depth > 1000) {
+		return NULL;
+	}
+	if (file->parent != NULL && archive_strlen(&file->parent->name) > 0) {
+		if (build_pathname(as, file->parent, depth + 1) == NULL) {
+			return NULL;
+		}
+		archive_strcat(as, "/");
+	}
+	if (archive_strlen(&file->name) == 0)
+		archive_strcat(as, ".");
+	else
+		archive_string_concat(as, &file->name);
+	return (as->s);
+}
+
+static int
+build_pathname_utf16be(unsigned char *p, size_t max, size_t *len,
+    struct file_info *file)
+{
+	if (file->parent != NULL && file->parent->utf16be_bytes > 0) {
+		if (build_pathname_utf16be(p, max, len, file->parent) != 0)
+			return (-1);
+		p[*len] = 0;
+		p[*len + 1] = '/';
+		*len += 2;
+	}
+	if (file->utf16be_bytes == 0) {
+		if (*len + 2 > max)
+			return (-1);/* Path is too long! */
+		p[*len] = 0;
+		p[*len + 1] = '.';
+		*len += 2;
+	} else {
+		if (*len + file->utf16be_bytes > max)
+			return (-1);/* Path is too long! */
+		memcpy(p + *len, file->utf16be_name, file->utf16be_bytes);
+		*len += file->utf16be_bytes;
+	}
+	return (0);
+}
+
+#if DEBUG
+static void
+dump_isodirrec(FILE *out, const unsigned char *isodirrec)
+{
+	fprintf(out, " l %d,",
+	    toi(isodirrec + DR_length_offset, DR_length_size));
+	fprintf(out, " a %d,",
+	    toi(isodirrec + DR_ext_attr_length_offset, DR_ext_attr_length_size));
+	fprintf(out, " ext 0x%x,",
+	    toi(isodirrec + DR_extent_offset, DR_extent_size));
+	fprintf(out, " s %d,",
+	    toi(isodirrec + DR_size_offset, DR_extent_size));
+	fprintf(out, " f 0x%x,",
+	    toi(isodirrec + DR_flags_offset, DR_flags_size));
+	fprintf(out, " u %d,",
+	    toi(isodirrec + DR_file_unit_size_offset, DR_file_unit_size_size));
+	fprintf(out, " ilv %d,",
+	    toi(isodirrec + DR_interleave_offset, DR_interleave_size));
+	fprintf(out, " seq %d,",
+	    toi(isodirrec + DR_volume_sequence_number_offset,
+		DR_volume_sequence_number_size));
+	fprintf(out, " nl %d:",
+	    toi(isodirrec + DR_name_len_offset, DR_name_len_size));
+	fprintf(out, " `%.*s'",
+	    toi(isodirrec + DR_name_len_offset, DR_name_len_size),
+		isodirrec + DR_name_offset);
+}
+#endif
--- libarchive-3.3.3/libarchive/archive_read_support_format_zip.c
+++ libarchive-nenuzhnix/libarchive/archive_read_support_format_zip.c
@@ -1304,9 +1304,10 @@
 
 	/* If we haven't yet read any data, initialize the decompressor. */
 	if (!zip->decompress_init) {
-		if (zip->stream_valid)
-			r = inflateReset(&zip->stream);
-		else
+		if (zip->stream_valid) {
+			inflateReset(&zip->stream);
+			r = Z_OK;
+		} else
 			r = inflateInit2(&zip->stream,
 			    -15 /* Don't check for zlib header */);
 		if (r != Z_OK) {
--- /dev/null
+++ libarchive-nenuzhnix/libarchive/archive_read_support_format_zip.c.orig
@@ -0,0 +1,3143 @@
+/*-
+ * Copyright (c) 2004-2013 Tim Kientzle
+ * Copyright (c) 2011-2012,2014 Michihiro NAKAJIMA
+ * Copyright (c) 2013 Konrad Kleine
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "archive_platform.h"
+__FBSDID("$FreeBSD: head/lib/libarchive/archive_read_support_format_zip.c 201102 2009-12-28 03:11:36Z kientzle $");
+
+/*
+ * The definitive documentation of the Zip file format is:
+ *   http://www.pkware.com/documents/casestudies/APPNOTE.TXT
+ *
+ * The Info-Zip project has pioneered various extensions to better
+ * support Zip on Unix, including the 0x5455 "UT", 0x5855 "UX", 0x7855
+ * "Ux", and 0x7875 "ux" extensions for time and ownership
+ * information.
+ *
+ * History of this code: The streaming Zip reader was first added to
+ * libarchive in January 2005.  Support for seekable input sources was
+ * added in Nov 2011.  Zip64 support (including a significant code
+ * refactoring) was added in 2014.
+ */
+
+#ifdef HAVE_ERRNO_H
+#include <errno.h>
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_ZLIB_H
+#include <zlib.h>
+#endif
+
+#include "archive.h"
+#include "archive_digest_private.h"
+#include "archive_cryptor_private.h"
+#include "archive_endian.h"
+#include "archive_entry.h"
+#include "archive_entry_locale.h"
+#include "archive_hmac_private.h"
+#include "archive_private.h"
+#include "archive_rb.h"
+#include "archive_read_private.h"
+
+#ifndef HAVE_ZLIB_H
+#include "archive_crc32.h"
+#endif
+
+struct zip_entry {
+	struct archive_rb_node	node;
+	struct zip_entry	*next;
+	int64_t			local_header_offset;
+	int64_t			compressed_size;
+	int64_t			uncompressed_size;
+	int64_t			gid;
+	int64_t			uid;
+	struct archive_string	rsrcname;
+	time_t			mtime;
+	time_t			atime;
+	time_t			ctime;
+	uint32_t		crc32;
+	uint16_t		mode;
+	uint16_t		zip_flags; /* From GP Flags Field */
+	unsigned char		compression;
+	unsigned char		system; /* From "version written by" */
+	unsigned char		flags; /* Our extra markers. */
+	unsigned char		decdat;/* Used for Decryption check */
+
+	/* WinZip AES encryption extra field should be available
+	 * when compression is 99. */
+	struct {
+		/* Vendor version: AE-1 - 0x0001, AE-2 - 0x0002 */
+		unsigned	vendor;
+#define AES_VENDOR_AE_1	0x0001
+#define AES_VENDOR_AE_2	0x0002
+		/* AES encryption strength:
+		 * 1 - 128 bits, 2 - 192 bits, 2 - 256 bits. */
+		unsigned	strength;
+		/* Actual compression method. */
+		unsigned char	compression;
+	}			aes_extra;
+};
+
+struct trad_enc_ctx {
+	uint32_t	keys[3];
+};
+
+/* Bits used in zip_flags. */
+#define ZIP_ENCRYPTED	(1 << 0)
+#define ZIP_LENGTH_AT_END	(1 << 3)
+#define ZIP_STRONG_ENCRYPTED	(1 << 6)
+#define ZIP_UTF8_NAME	(1 << 11)
+/* See "7.2 Single Password Symmetric Encryption Method"
+   in http://www.pkware.com/documents/casestudies/APPNOTE.TXT */
+#define ZIP_CENTRAL_DIRECTORY_ENCRYPTED	(1 << 13)
+
+/* Bits used in flags. */
+#define LA_USED_ZIP64	(1 << 0)
+#define LA_FROM_CENTRAL_DIRECTORY (1 << 1)
+
+/*
+ * See "WinZip - AES Encryption Information"
+ *     http://www.winzip.com/aes_info.htm
+ */
+/* Value used in compression method. */
+#define WINZIP_AES_ENCRYPTION	99
+/* Authentication code size. */
+#define AUTH_CODE_SIZE	10
+/**/
+#define MAX_DERIVED_KEY_BUF_SIZE	(AES_MAX_KEY_SIZE * 2 + 2)
+
+struct zip {
+	/* Structural information about the archive. */
+	struct archive_string	format_name;
+	int64_t			central_directory_offset;
+	size_t			central_directory_entries_total;
+	size_t			central_directory_entries_on_this_disk;
+	int			has_encrypted_entries;
+
+	/* List of entries (seekable Zip only) */
+	struct zip_entry	*zip_entries;
+	struct archive_rb_tree	tree;
+	struct archive_rb_tree	tree_rsrc;
+
+	/* Bytes read but not yet consumed via __archive_read_consume() */
+	size_t			unconsumed;
+
+	/* Information about entry we're currently reading. */
+	struct zip_entry	*entry;
+	int64_t			entry_bytes_remaining;
+
+	/* These count the number of bytes actually read for the entry. */
+	int64_t			entry_compressed_bytes_read;
+	int64_t			entry_uncompressed_bytes_read;
+
+	/* Running CRC32 of the decompressed data */
+	unsigned long		entry_crc32;
+	unsigned long		(*crc32func)(unsigned long, const void *,
+				    size_t);
+	char			ignore_crc32;
+
+	/* Flags to mark progress of decompression. */
+	char			decompress_init;
+	char			end_of_entry;
+
+#ifdef HAVE_ZLIB_H
+	unsigned char 		*uncompressed_buffer;
+	size_t 			uncompressed_buffer_size;
+	z_stream		stream;
+	char			stream_valid;
+#endif
+
+	struct archive_string_conv *sconv;
+	struct archive_string_conv *sconv_default;
+	struct archive_string_conv *sconv_utf8;
+	int			init_default_conversion;
+	int			process_mac_extensions;
+
+	char			init_decryption;
+
+	/* Decryption buffer. */
+	/*
+	 * The decrypted data starts at decrypted_ptr and
+	 * extends for decrypted_bytes_remaining.  Decryption
+	 * adds new data to the end of this block, data is returned
+	 * to clients from the beginning.  When the block hits the
+	 * end of decrypted_buffer, it has to be shuffled back to
+	 * the beginning of the buffer.
+	 */
+	unsigned char 		*decrypted_buffer;
+	unsigned char 		*decrypted_ptr;
+	size_t 			decrypted_buffer_size;
+	size_t 			decrypted_bytes_remaining;
+	size_t 			decrypted_unconsumed_bytes;
+
+	/* Traditional PKWARE decryption. */
+	struct trad_enc_ctx	tctx;
+	char			tctx_valid;
+
+	/* WinZip AES decryption. */
+	/* Contexts used for AES decryption. */
+	archive_crypto_ctx	cctx;
+	char			cctx_valid;
+	archive_hmac_sha1_ctx	hctx;
+	char			hctx_valid;
+
+	/* Strong encryption's decryption header information. */
+	unsigned		iv_size;
+	unsigned		alg_id;
+	unsigned		bit_len;
+	unsigned		flags;
+	unsigned		erd_size;
+	unsigned		v_size;
+	unsigned		v_crc32;
+	uint8_t			*iv;
+	uint8_t			*erd;
+	uint8_t			*v_data;
+};
+
+/* Many systems define min or MIN, but not all. */
+#define	zipmin(a,b) ((a) < (b) ? (a) : (b))
+
+/* ------------------------------------------------------------------------ */
+
+/*
+  Traditional PKWARE Decryption functions.
+ */
+
+static void
+trad_enc_update_keys(struct trad_enc_ctx *ctx, uint8_t c)
+{
+	uint8_t t;
+#define CRC32(c, b) (crc32(c ^ 0xffffffffUL, &b, 1) ^ 0xffffffffUL)
+
+	ctx->keys[0] = CRC32(ctx->keys[0], c);
+	ctx->keys[1] = (ctx->keys[1] + (ctx->keys[0] & 0xff)) * 134775813L + 1;
+	t = (ctx->keys[1] >> 24) & 0xff;
+	ctx->keys[2] = CRC32(ctx->keys[2], t);
+#undef CRC32
+}
+
+static uint8_t
+trad_enc_decrypt_byte(struct trad_enc_ctx *ctx)
+{
+	unsigned temp = ctx->keys[2] | 2;
+	return (uint8_t)((temp * (temp ^ 1)) >> 8) & 0xff;
+}
+
+static void
+trad_enc_decrypt_update(struct trad_enc_ctx *ctx, const uint8_t *in,
+    size_t in_len, uint8_t *out, size_t out_len)
+{
+	unsigned i, max;
+
+	max = (unsigned)((in_len < out_len)? in_len: out_len);
+
+	for (i = 0; i < max; i++) {
+		uint8_t t = in[i] ^ trad_enc_decrypt_byte(ctx);
+		out[i] = t;
+		trad_enc_update_keys(ctx, t);
+	}
+}
+
+static int
+trad_enc_init(struct trad_enc_ctx *ctx, const char *pw, size_t pw_len,
+    const uint8_t *key, size_t key_len, uint8_t *crcchk)
+{
+	uint8_t header[12];
+
+	if (key_len < 12) {
+		*crcchk = 0xff;
+		return -1;
+	}
+
+	ctx->keys[0] = 305419896L;
+	ctx->keys[1] = 591751049L;
+	ctx->keys[2] = 878082192L;
+
+	for (;pw_len; --pw_len)
+		trad_enc_update_keys(ctx, *pw++);
+
+	trad_enc_decrypt_update(ctx, key, 12, header, 12);
+	/* Return the last byte for CRC check. */
+	*crcchk = header[11];
+	return 0;
+}
+
+#if 0
+static void
+crypt_derive_key_sha1(const void *p, int size, unsigned char *key,
+    int key_size)
+{
+#define MD_SIZE 20
+	archive_sha1_ctx ctx;
+	unsigned char md1[MD_SIZE];
+	unsigned char md2[MD_SIZE * 2];
+	unsigned char mkb[64];
+	int i;
+
+	archive_sha1_init(&ctx);
+	archive_sha1_update(&ctx, p, size);
+	archive_sha1_final(&ctx, md1);
+
+	memset(mkb, 0x36, sizeof(mkb));
+	for (i = 0; i < MD_SIZE; i++)
+		mkb[i] ^= md1[i];
+	archive_sha1_init(&ctx);
+	archive_sha1_update(&ctx, mkb, sizeof(mkb));
+	archive_sha1_final(&ctx, md2);
+
+	memset(mkb, 0x5C, sizeof(mkb));
+	for (i = 0; i < MD_SIZE; i++)
+		mkb[i] ^= md1[i];
+	archive_sha1_init(&ctx);
+	archive_sha1_update(&ctx, mkb, sizeof(mkb));
+	archive_sha1_final(&ctx, md2 + MD_SIZE);
+
+	if (key_size > 32)
+		key_size = 32;
+	memcpy(key, md2, key_size);
+#undef MD_SIZE
+}
+#endif
+
+/*
+ * Common code for streaming or seeking modes.
+ *
+ * Includes code to read local file headers, decompress data
+ * from entry bodies, and common API.
+ */
+
+static unsigned long
+real_crc32(unsigned long crc, const void *buff, size_t len)
+{
+	return crc32(crc, buff, (unsigned int)len);
+}
+
+/* Used by "ignorecrc32" option to speed up tests. */
+static unsigned long
+fake_crc32(unsigned long crc, const void *buff, size_t len)
+{
+	(void)crc; /* UNUSED */
+	(void)buff; /* UNUSED */
+	(void)len; /* UNUSED */
+	return 0;
+}
+
+static const struct {
+	int id;
+	const char * name;
+} compression_methods[] = {
+	{0, "uncompressed"}, /* The file is stored (no compression) */
+	{1, "shrinking"}, /* The file is Shrunk */
+	{2, "reduced-1"}, /* The file is Reduced with compression factor 1 */
+	{3, "reduced-2"}, /* The file is Reduced with compression factor 2 */
+	{4, "reduced-3"}, /* The file is Reduced with compression factor 3 */
+	{5, "reduced-4"}, /* The file is Reduced with compression factor 4 */
+	{6, "imploded"},  /* The file is Imploded */
+	{7, "reserved"},  /* Reserved for Tokenizing compression algorithm */
+	{8, "deflation"}, /* The file is Deflated */
+	{9, "deflation-64-bit"}, /* Enhanced Deflating using Deflate64(tm) */
+	{10, "ibm-terse"},/* PKWARE Data Compression Library Imploding
+			   * (old IBM TERSE) */
+	{11, "reserved"}, /* Reserved by PKWARE */
+	{12, "bzip"},     /* File is compressed using BZIP2 algorithm */
+	{13, "reserved"}, /* Reserved by PKWARE */
+	{14, "lzma"},     /* LZMA (EFS) */
+	{15, "reserved"}, /* Reserved by PKWARE */
+	{16, "reserved"}, /* Reserved by PKWARE */
+	{17, "reserved"}, /* Reserved by PKWARE */
+	{18, "ibm-terse-new"}, /* File is compressed using IBM TERSE (new) */
+	{19, "ibm-lz777"},/* IBM LZ77 z Architecture (PFS) */
+	{97, "wav-pack"}, /* WavPack compressed data */
+	{98, "ppmd-1"},   /* PPMd version I, Rev 1 */
+	{99, "aes"}       /* WinZip AES encryption  */
+};
+
+static const char *
+compression_name(const int compression)
+{
+	static const int num_compression_methods =
+		sizeof(compression_methods)/sizeof(compression_methods[0]);
+	int i=0;
+
+	while(compression >= 0 && i < num_compression_methods) {
+		if (compression_methods[i].id == compression)
+			return compression_methods[i].name;
+		i++;
+	}
+	return "??";
+}
+
+/* Convert an MSDOS-style date/time into Unix-style time. */
+static time_t
+zip_time(const char *p)
+{
+	int msTime, msDate;
+	struct tm ts;
+
+	msTime = (0xff & (unsigned)p[0]) + 256 * (0xff & (unsigned)p[1]);
+	msDate = (0xff & (unsigned)p[2]) + 256 * (0xff & (unsigned)p[3]);
+
+	memset(&ts, 0, sizeof(ts));
+	ts.tm_year = ((msDate >> 9) & 0x7f) + 80; /* Years since 1900. */
+	ts.tm_mon = ((msDate >> 5) & 0x0f) - 1; /* Month number. */
+	ts.tm_mday = msDate & 0x1f; /* Day of month. */
+	ts.tm_hour = (msTime >> 11) & 0x1f;
+	ts.tm_min = (msTime >> 5) & 0x3f;
+	ts.tm_sec = (msTime << 1) & 0x3e;
+	ts.tm_isdst = -1;
+	return mktime(&ts);
+}
+
+/*
+ * The extra data is stored as a list of
+ *	id1+size1+data1 + id2+size2+data2 ...
+ *  triplets.  id and size are 2 bytes each.
+ */
+static int
+process_extra(struct archive_read *a, const char *p, size_t extra_length, struct zip_entry* zip_entry)
+{
+	unsigned offset = 0;
+
+	if (extra_length == 0) {
+		return ARCHIVE_OK;
+	}
+
+	if (extra_length < 4) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+		    "Too-small extra data: Need at least 4 bytes, but only found %d bytes", (int)extra_length);
+		return ARCHIVE_FAILED;
+	}
+	while (offset <= extra_length - 4) {
+		unsigned short headerid = archive_le16dec(p + offset);
+		unsigned short datasize = archive_le16dec(p + offset + 2);
+
+		offset += 4;
+		if (offset + datasize > extra_length) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+			    "Extra data overflow: Need %d bytes but only found %d bytes",
+			    (int)datasize, (int)(extra_length - offset));
+			return ARCHIVE_FAILED;
+		}
+#ifdef DEBUG
+		fprintf(stderr, "Header id 0x%04x, length %d\n",
+		    headerid, datasize);
+#endif
+		switch (headerid) {
+		case 0x0001:
+			/* Zip64 extended information extra field. */
+			zip_entry->flags |= LA_USED_ZIP64;
+			if (zip_entry->uncompressed_size == 0xffffffff) {
+				uint64_t t = 0;
+				if (datasize < 8
+				    || (t = archive_le64dec(p + offset)) > INT64_MAX) {
+					archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+					    "Malformed 64-bit uncompressed size");
+					return ARCHIVE_FAILED;
+				}
+				zip_entry->uncompressed_size = t;
+				offset += 8;
+				datasize -= 8;
+			}
+			if (zip_entry->compressed_size == 0xffffffff) {
+				uint64_t t = 0;
+				if (datasize < 8
+				    || (t = archive_le64dec(p + offset)) > INT64_MAX) {
+					archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+					    "Malformed 64-bit compressed size");
+					return ARCHIVE_FAILED;
+				}
+				zip_entry->compressed_size = t;
+				offset += 8;
+				datasize -= 8;
+			}
+			if (zip_entry->local_header_offset == 0xffffffff) {
+				uint64_t t = 0;
+				if (datasize < 8
+				    || (t = archive_le64dec(p + offset)) > INT64_MAX) {
+					archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+					    "Malformed 64-bit local header offset");
+					return ARCHIVE_FAILED;
+				}
+				zip_entry->local_header_offset = t;
+				offset += 8;
+				datasize -= 8;
+			}
+			/* archive_le32dec(p + offset) gives disk
+			 * on which file starts, but we don't handle
+			 * multi-volume Zip files. */
+			break;
+#ifdef DEBUG
+		case 0x0017:
+		{
+			/* Strong encryption field. */
+			if (archive_le16dec(p + offset) == 2) {
+				unsigned algId =
+					archive_le16dec(p + offset + 2);
+				unsigned bitLen =
+					archive_le16dec(p + offset + 4);
+				int	 flags =
+					archive_le16dec(p + offset + 6);
+				fprintf(stderr, "algId=0x%04x, bitLen=%u, "
+				    "flgas=%d\n", algId, bitLen,flags);
+			}
+			break;
+		}
+#endif
+		case 0x5455:
+		{
+			/* Extended time field "UT". */
+			int flags;
+			if (datasize == 0) {
+				archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+				    "Incomplete extended time field");
+				return ARCHIVE_FAILED;
+			}
+			flags = p[offset];
+			offset++;
+			datasize--;
+			/* Flag bits indicate which dates are present. */
+			if (flags & 0x01)
+			{
+#ifdef DEBUG
+				fprintf(stderr, "mtime: %lld -> %d\n",
+				    (long long)zip_entry->mtime,
+				    archive_le32dec(p + offset));
+#endif
+				if (datasize < 4)
+					break;
+				zip_entry->mtime = archive_le32dec(p + offset);
+				offset += 4;
+				datasize -= 4;
+			}
+			if (flags & 0x02)
+			{
+				if (datasize < 4)
+					break;
+				zip_entry->atime = archive_le32dec(p + offset);
+				offset += 4;
+				datasize -= 4;
+			}
+			if (flags & 0x04)
+			{
+				if (datasize < 4)
+					break;
+				zip_entry->ctime = archive_le32dec(p + offset);
+				offset += 4;
+				datasize -= 4;
+			}
+			break;
+		}
+		case 0x5855:
+		{
+			/* Info-ZIP Unix Extra Field (old version) "UX". */
+			if (datasize >= 8) {
+				zip_entry->atime = archive_le32dec(p + offset);
+				zip_entry->mtime =
+				    archive_le32dec(p + offset + 4);
+			}
+			if (datasize >= 12) {
+				zip_entry->uid =
+				    archive_le16dec(p + offset + 8);
+				zip_entry->gid =
+				    archive_le16dec(p + offset + 10);
+			}
+			break;
+		}
+		case 0x6c78:
+		{
+			/* Experimental 'xl' field */
+			/*
+			 * Introduced Dec 2013 to provide a way to
+			 * include external file attributes (and other
+			 * fields that ordinarily appear only in
+			 * central directory) in local file header.
+			 * This provides file type and permission
+			 * information necessary to support full
+			 * streaming extraction.  Currently being
+			 * discussed with other Zip developers
+			 * ... subject to change.
+			 *
+			 * Format:
+			 *  The field starts with a bitmap that specifies
+			 *  which additional fields are included.  The
+			 *  bitmap is variable length and can be extended in
+			 *  the future.
+			 *
+			 *  n bytes - feature bitmap: first byte has low-order
+			 *    7 bits.  If high-order bit is set, a subsequent
+			 *    byte holds the next 7 bits, etc.
+			 *
+			 *  if bitmap & 1, 2 byte "version made by"
+			 *  if bitmap & 2, 2 byte "internal file attributes"
+			 *  if bitmap & 4, 4 byte "external file attributes"
+			 *  if bitmap & 8, 2 byte comment length + n byte comment
+			 */
+			int bitmap, bitmap_last;
+
+			if (datasize < 1)
+				break;
+			bitmap_last = bitmap = 0xff & p[offset];
+			offset += 1;
+			datasize -= 1;
+
+			/* We only support first 7 bits of bitmap; skip rest. */
+			while ((bitmap_last & 0x80) != 0
+			    && datasize >= 1) {
+				bitmap_last = p[offset];
+				offset += 1;
+				datasize -= 1;
+			}
+
+			if (bitmap & 1) {
+				/* 2 byte "version made by" */
+				if (datasize < 2)
+					break;
+				zip_entry->system
+				    = archive_le16dec(p + offset) >> 8;
+				offset += 2;
+				datasize -= 2;
+			}
+			if (bitmap & 2) {
+				/* 2 byte "internal file attributes" */
+				uint32_t internal_attributes;
+				if (datasize < 2)
+					break;
+				internal_attributes
+				    = archive_le16dec(p + offset);
+				/* Not used by libarchive at present. */
+				(void)internal_attributes; /* UNUSED */
+				offset += 2;
+				datasize -= 2;
+			}
+			if (bitmap & 4) {
+				/* 4 byte "external file attributes" */
+				uint32_t external_attributes;
+				if (datasize < 4)
+					break;
+				external_attributes
+				    = archive_le32dec(p + offset);
+				if (zip_entry->system == 3) {
+					zip_entry->mode
+					    = external_attributes >> 16;
+				} else if (zip_entry->system == 0) {
+					// Interpret MSDOS directory bit
+					if (0x10 == (external_attributes & 0x10)) {
+						zip_entry->mode = AE_IFDIR | 0775;
+					} else {
+						zip_entry->mode = AE_IFREG | 0664;
+					}
+					if (0x01 == (external_attributes & 0x01)) {
+						// Read-only bit; strip write permissions
+						zip_entry->mode &= 0555;
+					}
+				} else {
+					zip_entry->mode = 0;
+				}
+				offset += 4;
+				datasize -= 4;
+			}
+			if (bitmap & 8) {
+				/* 2 byte comment length + comment */
+				uint32_t comment_length;
+				if (datasize < 2)
+					break;
+				comment_length
+				    = archive_le16dec(p + offset);
+				offset += 2;
+				datasize -= 2;
+
+				if (datasize < comment_length)
+					break;
+				/* Comment is not supported by libarchive */
+				offset += comment_length;
+				datasize -= comment_length;
+			}
+			break;
+		}
+		case 0x7855:
+			/* Info-ZIP Unix Extra Field (type 2) "Ux". */
+#ifdef DEBUG
+			fprintf(stderr, "uid %d gid %d\n",
+			    archive_le16dec(p + offset),
+			    archive_le16dec(p + offset + 2));
+#endif
+			if (datasize >= 2)
+				zip_entry->uid = archive_le16dec(p + offset);
+			if (datasize >= 4)
+				zip_entry->gid =
+				    archive_le16dec(p + offset + 2);
+			break;
+		case 0x7875:
+		{
+			/* Info-Zip Unix Extra Field (type 3) "ux". */
+			int uidsize = 0, gidsize = 0;
+
+			/* TODO: support arbitrary uidsize/gidsize. */
+			if (datasize >= 1 && p[offset] == 1) {/* version=1 */
+				if (datasize >= 4) {
+					/* get a uid size. */
+					uidsize = 0xff & (int)p[offset+1];
+					if (uidsize == 2)
+						zip_entry->uid =
+						    archive_le16dec(
+						        p + offset + 2);
+					else if (uidsize == 4 && datasize >= 6)
+						zip_entry->uid =
+						    archive_le32dec(
+						        p + offset + 2);
+				}
+				if (datasize >= (2 + uidsize + 3)) {
+					/* get a gid size. */
+					gidsize = 0xff & (int)p[offset+2+uidsize];
+					if (gidsize == 2)
+						zip_entry->gid =
+						    archive_le16dec(
+						        p+offset+2+uidsize+1);
+					else if (gidsize == 4 &&
+					    datasize >= (2 + uidsize + 5))
+						zip_entry->gid =
+						    archive_le32dec(
+						        p+offset+2+uidsize+1);
+				}
+			}
+			break;
+		}
+		case 0x9901:
+			/* WinZip AES extra data field. */
+			if (datasize < 6) {
+				archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+				    "Incomplete AES field");
+				return ARCHIVE_FAILED;
+			}
+			if (p[offset + 2] == 'A' && p[offset + 3] == 'E') {
+				/* Vendor version. */
+				zip_entry->aes_extra.vendor =
+				    archive_le16dec(p + offset);
+				/* AES encryption strength. */
+				zip_entry->aes_extra.strength = p[offset + 4];
+				/* Actual compression method. */
+				zip_entry->aes_extra.compression =
+				    p[offset + 5];
+			}
+			break;
+		default:
+			break;
+		}
+		offset += datasize;
+	}
+	if (offset != extra_length) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+		    "Malformed extra data: Consumed %d bytes of %d bytes",
+		    (int)offset, (int)extra_length);
+		return ARCHIVE_FAILED;
+	}
+	return ARCHIVE_OK;
+}
+
+/*
+ * Assumes file pointer is at beginning of local file header.
+ */
+static int
+zip_read_local_file_header(struct archive_read *a, struct archive_entry *entry,
+    struct zip *zip)
+{
+	const char *p;
+	const void *h;
+	const wchar_t *wp;
+	const char *cp;
+	size_t len, filename_length, extra_length;
+	struct archive_string_conv *sconv;
+	struct zip_entry *zip_entry = zip->entry;
+	struct zip_entry zip_entry_central_dir;
+	int ret = ARCHIVE_OK;
+	char version;
+
+	/* Save a copy of the original for consistency checks. */
+	zip_entry_central_dir = *zip_entry;
+
+	zip->decompress_init = 0;
+	zip->end_of_entry = 0;
+	zip->entry_uncompressed_bytes_read = 0;
+	zip->entry_compressed_bytes_read = 0;
+	zip->entry_crc32 = zip->crc32func(0, NULL, 0);
+
+	/* Setup default conversion. */
+	if (zip->sconv == NULL && !zip->init_default_conversion) {
+		zip->sconv_default =
+		    archive_string_default_conversion_for_read(&(a->archive));
+		zip->init_default_conversion = 1;
+	}
+
+	if ((p = __archive_read_ahead(a, 30, NULL)) == NULL) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+		    "Truncated ZIP file header");
+		return (ARCHIVE_FATAL);
+	}
+
+	if (memcmp(p, "PK\003\004", 4) != 0) {
+		archive_set_error(&a->archive, -1, "Damaged Zip archive");
+		return ARCHIVE_FATAL;
+	}
+	version = p[4];
+	zip_entry->system = p[5];
+	zip_entry->zip_flags = archive_le16dec(p + 6);
+	if (zip_entry->zip_flags & (ZIP_ENCRYPTED | ZIP_STRONG_ENCRYPTED)) {
+		zip->has_encrypted_entries = 1;
+		archive_entry_set_is_data_encrypted(entry, 1);
+		if (zip_entry->zip_flags & ZIP_CENTRAL_DIRECTORY_ENCRYPTED &&
+			zip_entry->zip_flags & ZIP_ENCRYPTED &&
+			zip_entry->zip_flags & ZIP_STRONG_ENCRYPTED) {
+			archive_entry_set_is_metadata_encrypted(entry, 1);
+			return ARCHIVE_FATAL;
+		}
+	}
+	zip->init_decryption = (zip_entry->zip_flags & ZIP_ENCRYPTED);
+	zip_entry->compression = (char)archive_le16dec(p + 8);
+	zip_entry->mtime = zip_time(p + 10);
+	zip_entry->crc32 = archive_le32dec(p + 14);
+	if (zip_entry->zip_flags & ZIP_LENGTH_AT_END)
+		zip_entry->decdat = p[11];
+	else
+		zip_entry->decdat = p[17];
+	zip_entry->compressed_size = archive_le32dec(p + 18);
+	zip_entry->uncompressed_size = archive_le32dec(p + 22);
+	filename_length = archive_le16dec(p + 26);
+	extra_length = archive_le16dec(p + 28);
+
+	__archive_read_consume(a, 30);
+
+	/* Read the filename. */
+	if ((h = __archive_read_ahead(a, filename_length, NULL)) == NULL) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+		    "Truncated ZIP file header");
+		return (ARCHIVE_FATAL);
+	}
+	if (zip_entry->zip_flags & ZIP_UTF8_NAME) {
+		/* The filename is stored to be UTF-8. */
+		if (zip->sconv_utf8 == NULL) {
+			zip->sconv_utf8 =
+			    archive_string_conversion_from_charset(
+				&a->archive, "UTF-8", 1);
+			if (zip->sconv_utf8 == NULL)
+				return (ARCHIVE_FATAL);
+		}
+		sconv = zip->sconv_utf8;
+	} else if (zip->sconv != NULL)
+		sconv = zip->sconv;
+	else
+		sconv = zip->sconv_default;
+
+	if (archive_entry_copy_pathname_l(entry,
+	    h, filename_length, sconv) != 0) {
+		if (errno == ENOMEM) {
+			archive_set_error(&a->archive, ENOMEM,
+			    "Can't allocate memory for Pathname");
+			return (ARCHIVE_FATAL);
+		}
+		archive_set_error(&a->archive,
+		    ARCHIVE_ERRNO_FILE_FORMAT,
+		    "Pathname cannot be converted "
+		    "from %s to current locale.",
+		    archive_string_conversion_charset_name(sconv));
+		ret = ARCHIVE_WARN;
+	}
+	__archive_read_consume(a, filename_length);
+
+	/* Read the extra data. */
+	if ((h = __archive_read_ahead(a, extra_length, NULL)) == NULL) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+		    "Truncated ZIP file header");
+		return (ARCHIVE_FATAL);
+	}
+
+	if (ARCHIVE_OK != process_extra(a, h, extra_length, zip_entry)) {
+		return ARCHIVE_FATAL;
+	}
+	__archive_read_consume(a, extra_length);
+
+	/* Work around a bug in Info-Zip: When reading from a pipe, it
+	 * stats the pipe instead of synthesizing a file entry. */
+	if ((zip_entry->mode & AE_IFMT) == AE_IFIFO) {
+		zip_entry->mode &= ~ AE_IFMT;
+		zip_entry->mode |= AE_IFREG;
+	}
+
+	/* If the mode is totally empty, set some sane default. */
+	if (zip_entry->mode == 0) {
+		zip_entry->mode |= 0664;
+	}
+
+	/* Windows archivers sometimes use backslash as the directory separator.
+	   Normalize to slash. */
+	if (zip_entry->system == 0 &&
+	    (wp = archive_entry_pathname_w(entry)) != NULL) {
+		if (wcschr(wp, L'/') == NULL && wcschr(wp, L'\\') != NULL) {
+			size_t i;
+			struct archive_wstring s;
+			archive_string_init(&s);
+			archive_wstrcpy(&s, wp);
+			for (i = 0; i < archive_strlen(&s); i++) {
+				if (s.s[i] == '\\')
+					s.s[i] = '/';
+			}
+			archive_entry_copy_pathname_w(entry, s.s);
+			archive_wstring_free(&s);
+		}
+	}
+
+	/* Make sure that entries with a trailing '/' are marked as directories
+	 * even if the External File Attributes contains bogus values.  If this
+	 * is not a directory and there is no type, assume regularfile. */
+	if ((zip_entry->mode & AE_IFMT) != AE_IFDIR) {
+		int has_slash;
+
+		wp = archive_entry_pathname_w(entry);
+		if (wp != NULL) {
+			len = wcslen(wp);
+			has_slash = len > 0 && wp[len - 1] == L'/';
+		} else {
+			cp = archive_entry_pathname(entry);
+			len = (cp != NULL)?strlen(cp):0;
+			has_slash = len > 0 && cp[len - 1] == '/';
+		}
+		/* Correct file type as needed. */
+		if (has_slash) {
+			zip_entry->mode &= ~AE_IFMT;
+			zip_entry->mode |= AE_IFDIR;
+			zip_entry->mode |= 0111;
+		} else if ((zip_entry->mode & AE_IFMT) == 0) {
+			zip_entry->mode |= AE_IFREG;
+		}
+	}
+
+	/* Make sure directories end in '/' */
+	if ((zip_entry->mode & AE_IFMT) == AE_IFDIR) {
+		wp = archive_entry_pathname_w(entry);
+		if (wp != NULL) {
+			len = wcslen(wp);
+			if (len > 0 && wp[len - 1] != L'/') {
+				struct archive_wstring s;
+				archive_string_init(&s);
+				archive_wstrcat(&s, wp);
+				archive_wstrappend_wchar(&s, L'/');
+				archive_entry_copy_pathname_w(entry, s.s);
+				archive_wstring_free(&s);
+			}
+		} else {
+			cp = archive_entry_pathname(entry);
+			len = (cp != NULL)?strlen(cp):0;
+			if (len > 0 && cp[len - 1] != '/') {
+				struct archive_string s;
+				archive_string_init(&s);
+				archive_strcat(&s, cp);
+				archive_strappend_char(&s, '/');
+				archive_entry_set_pathname(entry, s.s);
+				archive_string_free(&s);
+			}
+		}
+	}
+
+	if (zip_entry->flags & LA_FROM_CENTRAL_DIRECTORY) {
+		/* If this came from the central dir, it's size info
+		 * is definitive, so ignore the length-at-end flag. */
+		zip_entry->zip_flags &= ~ZIP_LENGTH_AT_END;
+		/* If local header is missing a value, use the one from
+		   the central directory.  If both have it, warn about
+		   mismatches. */
+		if (zip_entry->crc32 == 0) {
+			zip_entry->crc32 = zip_entry_central_dir.crc32;
+		} else if (!zip->ignore_crc32
+		    && zip_entry->crc32 != zip_entry_central_dir.crc32) {
+			archive_set_error(&a->archive,
+			    ARCHIVE_ERRNO_FILE_FORMAT,
+			    "Inconsistent CRC32 values");
+			ret = ARCHIVE_WARN;
+		}
+		if (zip_entry->compressed_size == 0) {
+			zip_entry->compressed_size
+			    = zip_entry_central_dir.compressed_size;
+		} else if (zip_entry->compressed_size
+		    != zip_entry_central_dir.compressed_size) {
+			archive_set_error(&a->archive,
+			    ARCHIVE_ERRNO_FILE_FORMAT,
+			    "Inconsistent compressed size: "
+			    "%jd in central directory, %jd in local header",
+			    (intmax_t)zip_entry_central_dir.compressed_size,
+			    (intmax_t)zip_entry->compressed_size);
+			ret = ARCHIVE_WARN;
+		}
+		if (zip_entry->uncompressed_size == 0) {
+			zip_entry->uncompressed_size
+			    = zip_entry_central_dir.uncompressed_size;
+		} else if (zip_entry->uncompressed_size
+		    != zip_entry_central_dir.uncompressed_size) {
+			archive_set_error(&a->archive,
+			    ARCHIVE_ERRNO_FILE_FORMAT,
+			    "Inconsistent uncompressed size: "
+			    "%jd in central directory, %jd in local header",
+			    (intmax_t)zip_entry_central_dir.uncompressed_size,
+			    (intmax_t)zip_entry->uncompressed_size);
+			ret = ARCHIVE_WARN;
+		}
+	}
+
+	/* Populate some additional entry fields: */
+	archive_entry_set_mode(entry, zip_entry->mode);
+	archive_entry_set_uid(entry, zip_entry->uid);
+	archive_entry_set_gid(entry, zip_entry->gid);
+	archive_entry_set_mtime(entry, zip_entry->mtime, 0);
+	archive_entry_set_ctime(entry, zip_entry->ctime, 0);
+	archive_entry_set_atime(entry, zip_entry->atime, 0);
+
+	if ((zip->entry->mode & AE_IFMT) == AE_IFLNK) {
+		size_t linkname_length;
+
+		if (zip_entry->compressed_size > 64 * 1024) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "Zip file with oversized link entry");
+			return ARCHIVE_FATAL;
+		}
+
+		linkname_length = (size_t)zip_entry->compressed_size;
+
+		archive_entry_set_size(entry, 0);
+		p = __archive_read_ahead(a, linkname_length, NULL);
+		if (p == NULL) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "Truncated Zip file");
+			return ARCHIVE_FATAL;
+		}
+
+		sconv = zip->sconv;
+		if (sconv == NULL && (zip->entry->zip_flags & ZIP_UTF8_NAME))
+			sconv = zip->sconv_utf8;
+		if (sconv == NULL)
+			sconv = zip->sconv_default;
+		if (archive_entry_copy_symlink_l(entry, p, linkname_length,
+		    sconv) != 0) {
+			if (errno != ENOMEM && sconv == zip->sconv_utf8 &&
+			    (zip->entry->zip_flags & ZIP_UTF8_NAME))
+			    archive_entry_copy_symlink_l(entry, p,
+				linkname_length, NULL);
+			if (errno == ENOMEM) {
+				archive_set_error(&a->archive, ENOMEM,
+				    "Can't allocate memory for Symlink");
+				return (ARCHIVE_FATAL);
+			}
+			/*
+			 * Since there is no character-set regulation for
+			 * symlink name, do not report the conversion error
+			 * in an automatic conversion.
+			 */
+			if (sconv != zip->sconv_utf8 ||
+			    (zip->entry->zip_flags & ZIP_UTF8_NAME) == 0) {
+				archive_set_error(&a->archive,
+				    ARCHIVE_ERRNO_FILE_FORMAT,
+				    "Symlink cannot be converted "
+				    "from %s to current locale.",
+				    archive_string_conversion_charset_name(
+					sconv));
+				ret = ARCHIVE_WARN;
+			}
+		}
+		zip_entry->uncompressed_size = zip_entry->compressed_size = 0;
+
+		if (__archive_read_consume(a, linkname_length) < 0) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "Read error skipping symlink target name");
+			return ARCHIVE_FATAL;
+		}
+	} else if (0 == (zip_entry->zip_flags & ZIP_LENGTH_AT_END)
+	    || zip_entry->uncompressed_size > 0) {
+		/* Set the size only if it's meaningful. */
+		archive_entry_set_size(entry, zip_entry->uncompressed_size);
+	}
+	zip->entry_bytes_remaining = zip_entry->compressed_size;
+
+	/* If there's no body, force read_data() to return EOF immediately. */
+	if (0 == (zip_entry->zip_flags & ZIP_LENGTH_AT_END)
+	    && zip->entry_bytes_remaining < 1)
+		zip->end_of_entry = 1;
+
+	/* Set up a more descriptive format name. */
+        archive_string_empty(&zip->format_name);
+	archive_string_sprintf(&zip->format_name, "ZIP %d.%d (%s)",
+	    version / 10, version % 10,
+	    compression_name(zip->entry->compression));
+	a->archive.archive_format_name = zip->format_name.s;
+
+	return (ret);
+}
+
+static int
+check_authentication_code(struct archive_read *a, const void *_p)
+{
+	struct zip *zip = (struct zip *)(a->format->data);
+
+	/* Check authentication code. */
+	if (zip->hctx_valid) {
+		const void *p;
+		uint8_t hmac[20];
+		size_t hmac_len = 20;
+		int cmp;
+
+		archive_hmac_sha1_final(&zip->hctx, hmac, &hmac_len);
+		if (_p == NULL) {
+			/* Read authentication code. */
+			p = __archive_read_ahead(a, AUTH_CODE_SIZE, NULL);
+			if (p == NULL) {
+				archive_set_error(&a->archive,
+				    ARCHIVE_ERRNO_FILE_FORMAT,
+				    "Truncated ZIP file data");
+				return (ARCHIVE_FATAL);
+			}
+		} else {
+			p = _p;
+		}
+		cmp = memcmp(hmac, p, AUTH_CODE_SIZE);
+		__archive_read_consume(a, AUTH_CODE_SIZE);
+		if (cmp != 0) {
+			archive_set_error(&a->archive,
+			    ARCHIVE_ERRNO_MISC,
+			    "ZIP bad Authentication code");
+			return (ARCHIVE_WARN);
+		}
+	}
+	return (ARCHIVE_OK);
+}
+
+/*
+ * Read "uncompressed" data.  There are three cases:
+ *  1) We know the size of the data.  This is always true for the
+ * seeking reader (we've examined the Central Directory already).
+ *  2) ZIP_LENGTH_AT_END was set, but only the CRC was deferred.
+ * Info-ZIP seems to do this; we know the size but have to grab
+ * the CRC from the data descriptor afterwards.
+ *  3) We're streaming and ZIP_LENGTH_AT_END was specified and
+ * we have no size information.  In this case, we can do pretty
+ * well by watching for the data descriptor record.  The data
+ * descriptor is 16 bytes and includes a computed CRC that should
+ * provide a strong check.
+ *
+ * TODO: Technically, the PK\007\010 signature is optional.
+ * In the original spec, the data descriptor contained CRC
+ * and size fields but had no leading signature.  In practice,
+ * newer writers seem to provide the signature pretty consistently.
+ *
+ * For uncompressed data, the PK\007\010 marker seems essential
+ * to be sure we've actually seen the end of the entry.
+ *
+ * Returns ARCHIVE_OK if successful, ARCHIVE_FATAL otherwise, sets
+ * zip->end_of_entry if it consumes all of the data.
+ */
+static int
+zip_read_data_none(struct archive_read *a, const void **_buff,
+    size_t *size, int64_t *offset)
+{
+	struct zip *zip;
+	const char *buff;
+	ssize_t bytes_avail;
+	int r;
+
+	(void)offset; /* UNUSED */
+
+	zip = (struct zip *)(a->format->data);
+
+	if (zip->entry->zip_flags & ZIP_LENGTH_AT_END) {
+		const char *p;
+		ssize_t grabbing_bytes = 24;
+
+		if (zip->hctx_valid)
+			grabbing_bytes += AUTH_CODE_SIZE;
+		/* Grab at least 24 bytes. */
+		buff = __archive_read_ahead(a, grabbing_bytes, &bytes_avail);
+		if (bytes_avail < grabbing_bytes) {
+			/* Zip archives have end-of-archive markers
+			   that are longer than this, so a failure to get at
+			   least 24 bytes really does indicate a truncated
+			   file. */
+			archive_set_error(&a->archive,
+			    ARCHIVE_ERRNO_FILE_FORMAT,
+			    "Truncated ZIP file data");
+			return (ARCHIVE_FATAL);
+		}
+		/* Check for a complete PK\007\010 signature, followed
+		 * by the correct 4-byte CRC. */
+		p = buff;
+		if (zip->hctx_valid)
+			p += AUTH_CODE_SIZE;
+		if (p[0] == 'P' && p[1] == 'K'
+		    && p[2] == '\007' && p[3] == '\010'
+		    && (archive_le32dec(p + 4) == zip->entry_crc32
+			|| zip->ignore_crc32
+			|| (zip->hctx_valid
+			 && zip->entry->aes_extra.vendor == AES_VENDOR_AE_2))) {
+			if (zip->entry->flags & LA_USED_ZIP64) {
+				uint64_t compressed, uncompressed;
+				zip->entry->crc32 = archive_le32dec(p + 4);
+				compressed = archive_le64dec(p + 8);
+				uncompressed = archive_le64dec(p + 16);
+				if (compressed > INT64_MAX || uncompressed > INT64_MAX) {
+					archive_set_error(&a->archive,
+					    ARCHIVE_ERRNO_FILE_FORMAT,
+					    "Overflow of 64-bit file sizes");
+					return ARCHIVE_FAILED;
+				}
+				zip->entry->compressed_size = compressed;
+				zip->entry->uncompressed_size = uncompressed;
+				zip->unconsumed = 24;
+			} else {
+				zip->entry->crc32 = archive_le32dec(p + 4);
+				zip->entry->compressed_size =
+					archive_le32dec(p + 8);
+				zip->entry->uncompressed_size =
+					archive_le32dec(p + 12);
+				zip->unconsumed = 16;
+			}
+			if (zip->hctx_valid) {
+				r = check_authentication_code(a, buff);
+				if (r != ARCHIVE_OK)
+					return (r);
+			}
+			zip->end_of_entry = 1;
+			return (ARCHIVE_OK);
+		}
+		/* If not at EOF, ensure we consume at least one byte. */
+		++p;
+
+		/* Scan forward until we see where a PK\007\010 signature
+		 * might be. */
+		/* Return bytes up until that point.  On the next call,
+		 * the code above will verify the data descriptor. */
+		while (p < buff + bytes_avail - 4) {
+			if (p[3] == 'P') { p += 3; }
+			else if (p[3] == 'K') { p += 2; }
+			else if (p[3] == '\007') { p += 1; }
+			else if (p[3] == '\010' && p[2] == '\007'
+			    && p[1] == 'K' && p[0] == 'P') {
+				if (zip->hctx_valid)
+					p -= AUTH_CODE_SIZE;
+				break;
+			} else { p += 4; }
+		}
+		bytes_avail = p - buff;
+	} else {
+		if (zip->entry_bytes_remaining == 0) {
+			zip->end_of_entry = 1;
+			if (zip->hctx_valid) {
+				r = check_authentication_code(a, NULL);
+				if (r != ARCHIVE_OK)
+					return (r);
+			}
+			return (ARCHIVE_OK);
+		}
+		/* Grab a bunch of bytes. */
+		buff = __archive_read_ahead(a, 1, &bytes_avail);
+		if (bytes_avail <= 0) {
+			archive_set_error(&a->archive,
+			    ARCHIVE_ERRNO_FILE_FORMAT,
+			    "Truncated ZIP file data");
+			return (ARCHIVE_FATAL);
+		}
+		if (bytes_avail > zip->entry_bytes_remaining)
+			bytes_avail = (ssize_t)zip->entry_bytes_remaining;
+	}
+	if (zip->tctx_valid || zip->cctx_valid) {
+		size_t dec_size = bytes_avail;
+
+		if (dec_size > zip->decrypted_buffer_size)
+			dec_size = zip->decrypted_buffer_size;
+		if (zip->tctx_valid) {
+			trad_enc_decrypt_update(&zip->tctx,
+			    (const uint8_t *)buff, dec_size,
+			    zip->decrypted_buffer, dec_size);
+		} else {
+			size_t dsize = dec_size;
+			archive_hmac_sha1_update(&zip->hctx,
+			    (const uint8_t *)buff, dec_size);
+			archive_decrypto_aes_ctr_update(&zip->cctx,
+			    (const uint8_t *)buff, dec_size,
+			    zip->decrypted_buffer, &dsize);
+		}
+		bytes_avail = dec_size;
+		buff = (const char *)zip->decrypted_buffer;
+	}
+	*size = bytes_avail;
+	zip->entry_bytes_remaining -= bytes_avail;
+	zip->entry_uncompressed_bytes_read += bytes_avail;
+	zip->entry_compressed_bytes_read += bytes_avail;
+	zip->unconsumed += bytes_avail;
+	*_buff = buff;
+	return (ARCHIVE_OK);
+}
+
+#ifdef HAVE_ZLIB_H
+static int
+zip_deflate_init(struct archive_read *a, struct zip *zip)
+{
+	int r;
+
+	/* If we haven't yet read any data, initialize the decompressor. */
+	if (!zip->decompress_init) {
+		if (zip->stream_valid)
+			r = inflateReset(&zip->stream);
+		else
+			r = inflateInit2(&zip->stream,
+			    -15 /* Don't check for zlib header */);
+		if (r != Z_OK) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "Can't initialize ZIP decompression.");
+			return (ARCHIVE_FATAL);
+		}
+		/* Stream structure has been set up. */
+		zip->stream_valid = 1;
+		/* We've initialized decompression for this stream. */
+		zip->decompress_init = 1;
+	}
+	return (ARCHIVE_OK);
+}
+
+static int
+zip_read_data_deflate(struct archive_read *a, const void **buff,
+    size_t *size, int64_t *offset)
+{
+	struct zip *zip;
+	ssize_t bytes_avail;
+	const void *compressed_buff, *sp;
+	int r;
+
+	(void)offset; /* UNUSED */
+
+	zip = (struct zip *)(a->format->data);
+
+	/* If the buffer hasn't been allocated, allocate it now. */
+	if (zip->uncompressed_buffer == NULL) {
+		zip->uncompressed_buffer_size = 256 * 1024;
+		zip->uncompressed_buffer
+		    = (unsigned char *)malloc(zip->uncompressed_buffer_size);
+		if (zip->uncompressed_buffer == NULL) {
+			archive_set_error(&a->archive, ENOMEM,
+			    "No memory for ZIP decompression");
+			return (ARCHIVE_FATAL);
+		}
+	}
+
+	r = zip_deflate_init(a, zip);
+	if (r != ARCHIVE_OK)
+		return (r);
+
+	/*
+	 * Note: '1' here is a performance optimization.
+	 * Recall that the decompression layer returns a count of
+	 * available bytes; asking for more than that forces the
+	 * decompressor to combine reads by copying data.
+	 */
+	compressed_buff = sp = __archive_read_ahead(a, 1, &bytes_avail);
+	if (0 == (zip->entry->zip_flags & ZIP_LENGTH_AT_END)
+	    && bytes_avail > zip->entry_bytes_remaining) {
+		bytes_avail = (ssize_t)zip->entry_bytes_remaining;
+	}
+	if (bytes_avail < 0) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+		    "Truncated ZIP file body");
+		return (ARCHIVE_FATAL);
+	}
+
+	if (zip->tctx_valid || zip->cctx_valid) {
+		if (zip->decrypted_bytes_remaining < (size_t)bytes_avail) {
+			size_t buff_remaining =
+			    (zip->decrypted_buffer + zip->decrypted_buffer_size)
+			    - (zip->decrypted_ptr + zip->decrypted_bytes_remaining);
+
+			if (buff_remaining > (size_t)bytes_avail)
+				buff_remaining = (size_t)bytes_avail;
+
+			if (0 == (zip->entry->zip_flags & ZIP_LENGTH_AT_END) &&
+			      zip->entry_bytes_remaining > 0) {
+				if ((int64_t)(zip->decrypted_bytes_remaining
+				    + buff_remaining)
+				      > zip->entry_bytes_remaining) {
+					if (zip->entry_bytes_remaining <
+					      (int64_t)zip->decrypted_bytes_remaining)
+						buff_remaining = 0;
+					else
+						buff_remaining =
+						    (size_t)zip->entry_bytes_remaining
+						      - zip->decrypted_bytes_remaining;
+				}
+			}
+			if (buff_remaining > 0) {
+				if (zip->tctx_valid) {
+					trad_enc_decrypt_update(&zip->tctx,
+					    compressed_buff, buff_remaining,
+					    zip->decrypted_ptr
+					      + zip->decrypted_bytes_remaining,
+					    buff_remaining);
+				} else {
+					size_t dsize = buff_remaining;
+					archive_decrypto_aes_ctr_update(
+					    &zip->cctx,
+					    compressed_buff, buff_remaining,
+					    zip->decrypted_ptr
+					      + zip->decrypted_bytes_remaining,
+					    &dsize);
+				}
+				zip->decrypted_bytes_remaining += buff_remaining;
+			}
+		}
+		bytes_avail = zip->decrypted_bytes_remaining;
+		compressed_buff = (const char *)zip->decrypted_ptr;
+	}
+
+	/*
+	 * A bug in zlib.h: stream.next_in should be marked 'const'
+	 * but isn't (the library never alters data through the
+	 * next_in pointer, only reads it).  The result: this ugly
+	 * cast to remove 'const'.
+	 */
+	zip->stream.next_in = (Bytef *)(uintptr_t)(const void *)compressed_buff;
+	zip->stream.avail_in = (uInt)bytes_avail;
+	zip->stream.total_in = 0;
+	zip->stream.next_out = zip->uncompressed_buffer;
+	zip->stream.avail_out = (uInt)zip->uncompressed_buffer_size;
+	zip->stream.total_out = 0;
+
+	r = inflate(&zip->stream, 0);
+	switch (r) {
+	case Z_OK:
+		break;
+	case Z_STREAM_END:
+		zip->end_of_entry = 1;
+		break;
+	case Z_MEM_ERROR:
+		archive_set_error(&a->archive, ENOMEM,
+		    "Out of memory for ZIP decompression");
+		return (ARCHIVE_FATAL);
+	default:
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+		    "ZIP decompression failed (%d)", r);
+		return (ARCHIVE_FATAL);
+	}
+
+	/* Consume as much as the compressor actually used. */
+	bytes_avail = zip->stream.total_in;
+	if (zip->tctx_valid || zip->cctx_valid) {
+		zip->decrypted_bytes_remaining -= bytes_avail;
+		if (zip->decrypted_bytes_remaining == 0)
+			zip->decrypted_ptr = zip->decrypted_buffer;
+		else
+			zip->decrypted_ptr += bytes_avail;
+	}
+	/* Calculate compressed data as much as we used.*/
+	if (zip->hctx_valid)
+		archive_hmac_sha1_update(&zip->hctx, sp, bytes_avail);
+	__archive_read_consume(a, bytes_avail);
+	zip->entry_bytes_remaining -= bytes_avail;
+	zip->entry_compressed_bytes_read += bytes_avail;
+
+	*size = zip->stream.total_out;
+	zip->entry_uncompressed_bytes_read += zip->stream.total_out;
+	*buff = zip->uncompressed_buffer;
+
+	if (zip->end_of_entry && zip->hctx_valid) {
+		r = check_authentication_code(a, NULL);
+		if (r != ARCHIVE_OK)
+			return (r);
+	}
+
+	if (zip->end_of_entry && (zip->entry->zip_flags & ZIP_LENGTH_AT_END)) {
+		const char *p;
+
+		if (NULL == (p = __archive_read_ahead(a, 24, NULL))) {
+			archive_set_error(&a->archive,
+			    ARCHIVE_ERRNO_FILE_FORMAT,
+			    "Truncated ZIP end-of-file record");
+			return (ARCHIVE_FATAL);
+		}
+		/* Consume the optional PK\007\010 marker. */
+		if (p[0] == 'P' && p[1] == 'K' &&
+		    p[2] == '\007' && p[3] == '\010') {
+			p += 4;
+			zip->unconsumed = 4;
+		}
+		if (zip->entry->flags & LA_USED_ZIP64) {
+			uint64_t compressed, uncompressed;
+			zip->entry->crc32 = archive_le32dec(p);
+			compressed = archive_le64dec(p + 4);
+			uncompressed = archive_le64dec(p + 12);
+			if (compressed > INT64_MAX || uncompressed > INT64_MAX) {
+				archive_set_error(&a->archive,
+				    ARCHIVE_ERRNO_FILE_FORMAT,
+				    "Overflow of 64-bit file sizes");
+				return ARCHIVE_FAILED;
+			}
+			zip->entry->compressed_size = compressed;
+			zip->entry->uncompressed_size = uncompressed;
+			zip->unconsumed += 20;
+		} else {
+			zip->entry->crc32 = archive_le32dec(p);
+			zip->entry->compressed_size = archive_le32dec(p + 4);
+			zip->entry->uncompressed_size = archive_le32dec(p + 8);
+			zip->unconsumed += 12;
+		}
+	}
+
+	return (ARCHIVE_OK);
+}
+#endif
+
+static int
+read_decryption_header(struct archive_read *a)
+{
+	struct zip *zip = (struct zip *)(a->format->data);
+	const char *p;
+	unsigned int remaining_size;
+	unsigned int ts;
+
+	/*
+	 * Read an initialization vector data field.
+	 */
+	p = __archive_read_ahead(a, 2, NULL);
+	if (p == NULL)
+		goto truncated;
+	ts = zip->iv_size;
+	zip->iv_size = archive_le16dec(p);
+	__archive_read_consume(a, 2);
+	if (ts < zip->iv_size) {
+		free(zip->iv);
+		zip->iv = NULL;
+	}
+	p = __archive_read_ahead(a, zip->iv_size, NULL);
+	if (p == NULL)
+		goto truncated;
+	if (zip->iv == NULL) {
+		zip->iv = malloc(zip->iv_size);
+		if (zip->iv == NULL)
+			goto nomem;
+	}
+	memcpy(zip->iv, p, zip->iv_size);
+	__archive_read_consume(a, zip->iv_size);
+
+	/*
+	 * Read a size of remaining decryption header field.
+	 */
+	p = __archive_read_ahead(a, 14, NULL);
+	if (p == NULL)
+		goto truncated;
+	remaining_size = archive_le32dec(p);
+	if (remaining_size < 16 || remaining_size > (1 << 18))
+		goto corrupted;
+
+	/* Check if format version is supported. */
+	if (archive_le16dec(p+4) != 3) {
+		archive_set_error(&a->archive,
+		    ARCHIVE_ERRNO_FILE_FORMAT,
+		    "Unsupported encryption format version: %u",
+		    archive_le16dec(p+4));
+		return (ARCHIVE_FAILED);
+	}
+
+	/*
+	 * Read an encryption algorithm field.
+	 */
+	zip->alg_id = archive_le16dec(p+6);
+	switch (zip->alg_id) {
+	case 0x6601:/* DES */
+	case 0x6602:/* RC2 */
+	case 0x6603:/* 3DES 168 */
+	case 0x6609:/* 3DES 112 */
+	case 0x660E:/* AES 128 */
+	case 0x660F:/* AES 192 */
+	case 0x6610:/* AES 256 */
+	case 0x6702:/* RC2 (version >= 5.2) */
+	case 0x6720:/* Blowfish */
+	case 0x6721:/* Twofish */
+	case 0x6801:/* RC4 */
+		/* Supported encryption algorithm. */
+		break;
+	default:
+		archive_set_error(&a->archive,
+		    ARCHIVE_ERRNO_FILE_FORMAT,
+		    "Unknown encryption algorithm: %u", zip->alg_id);
+		return (ARCHIVE_FAILED);
+	}
+
+	/*
+	 * Read a bit length field.
+	 */
+	zip->bit_len = archive_le16dec(p+8);
+
+	/*
+	 * Read a flags field.
+	 */
+	zip->flags = archive_le16dec(p+10);
+	switch (zip->flags & 0xf000) {
+	case 0x0001: /* Password is required to decrypt. */
+	case 0x0002: /* Certificates only. */
+	case 0x0003: /* Password or certificate required to decrypt. */
+		break;
+	default:
+		archive_set_error(&a->archive,
+		    ARCHIVE_ERRNO_FILE_FORMAT,
+		    "Unknown encryption flag: %u", zip->flags);
+		return (ARCHIVE_FAILED);
+	}
+	if ((zip->flags & 0xf000) == 0 ||
+	    (zip->flags & 0xf000) == 0x4000) {
+		archive_set_error(&a->archive,
+		    ARCHIVE_ERRNO_FILE_FORMAT,
+		    "Unknown encryption flag: %u", zip->flags);
+		return (ARCHIVE_FAILED);
+	}
+
+	/*
+	 * Read an encrypted random data field.
+	 */
+	ts = zip->erd_size;
+	zip->erd_size = archive_le16dec(p+12);
+	__archive_read_consume(a, 14);
+	if ((zip->erd_size & 0xf) != 0 ||
+	    (zip->erd_size + 16) > remaining_size ||
+	    (zip->erd_size + 16) < zip->erd_size)
+		goto corrupted;
+
+	if (ts < zip->erd_size) {
+		free(zip->erd);
+		zip->erd = NULL;
+	}
+	p = __archive_read_ahead(a, zip->erd_size, NULL);
+	if (p == NULL)
+		goto truncated;
+	if (zip->erd == NULL) {
+		zip->erd = malloc(zip->erd_size);
+		if (zip->erd == NULL)
+			goto nomem;
+	}
+	memcpy(zip->erd, p, zip->erd_size);
+	__archive_read_consume(a, zip->erd_size);
+
+	/*
+	 * Read a reserved data field.
+	 */
+	p = __archive_read_ahead(a, 4, NULL);
+	if (p == NULL)
+		goto truncated;
+	/* Reserved data size should be zero. */
+	if (archive_le32dec(p) != 0)
+		goto corrupted;
+	__archive_read_consume(a, 4);
+
+	/*
+	 * Read a password validation data field.
+	 */
+	p = __archive_read_ahead(a, 2, NULL);
+	if (p == NULL)
+		goto truncated;
+	ts = zip->v_size;
+	zip->v_size = archive_le16dec(p);
+	__archive_read_consume(a, 2);
+	if ((zip->v_size & 0x0f) != 0 ||
+	    (zip->erd_size + zip->v_size + 16) > remaining_size ||
+	    (zip->erd_size + zip->v_size + 16) < (zip->erd_size + zip->v_size))
+		goto corrupted;
+	if (ts < zip->v_size) {
+		free(zip->v_data);
+		zip->v_data = NULL;
+	}
+	p = __archive_read_ahead(a, zip->v_size, NULL);
+	if (p == NULL)
+		goto truncated;
+	if (zip->v_data == NULL) {
+		zip->v_data = malloc(zip->v_size);
+		if (zip->v_data == NULL)
+			goto nomem;
+	}
+	memcpy(zip->v_data, p, zip->v_size);
+	__archive_read_consume(a, zip->v_size);
+
+	p = __archive_read_ahead(a, 4, NULL);
+	if (p == NULL)
+		goto truncated;
+	zip->v_crc32 = archive_le32dec(p);
+	__archive_read_consume(a, 4);
+
+	/*return (ARCHIVE_OK);
+	 * This is not fully implemented yet.*/
+	archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+	    "Encrypted file is unsupported");
+	return (ARCHIVE_FAILED);
+truncated:
+	archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+	    "Truncated ZIP file data");
+	return (ARCHIVE_FATAL);
+corrupted:
+	archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+	    "Corrupted ZIP file data");
+	return (ARCHIVE_FATAL);
+nomem:
+	archive_set_error(&a->archive, ENOMEM,
+	    "No memory for ZIP decryption");
+	return (ARCHIVE_FATAL);
+}
+
+static int
+zip_alloc_decryption_buffer(struct archive_read *a)
+{
+	struct zip *zip = (struct zip *)(a->format->data);
+	size_t bs = 256 * 1024;
+
+	if (zip->decrypted_buffer == NULL) {
+		zip->decrypted_buffer_size = bs;
+		zip->decrypted_buffer = malloc(bs);
+		if (zip->decrypted_buffer == NULL) {
+			archive_set_error(&a->archive, ENOMEM,
+			    "No memory for ZIP decryption");
+			return (ARCHIVE_FATAL);
+		}
+	}
+	zip->decrypted_ptr = zip->decrypted_buffer;
+	return (ARCHIVE_OK);
+}
+
+static int
+init_traditional_PKWARE_decryption(struct archive_read *a)
+{
+	struct zip *zip = (struct zip *)(a->format->data);
+	const void *p;
+	int retry;
+	int r;
+
+	if (zip->tctx_valid)
+		return (ARCHIVE_OK);
+
+	/*
+	   Read the 12 bytes encryption header stored at
+	   the start of the data area.
+	 */
+#define ENC_HEADER_SIZE	12
+	if (0 == (zip->entry->zip_flags & ZIP_LENGTH_AT_END)
+	    && zip->entry_bytes_remaining < ENC_HEADER_SIZE) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+		    "Truncated Zip encrypted body: only %jd bytes available",
+		    (intmax_t)zip->entry_bytes_remaining);
+		return (ARCHIVE_FATAL);
+	}
+
+	p = __archive_read_ahead(a, ENC_HEADER_SIZE, NULL);
+	if (p == NULL) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+		    "Truncated ZIP file data");
+		return (ARCHIVE_FATAL);
+	}
+
+	for (retry = 0;; retry++) {
+		const char *passphrase;
+		uint8_t crcchk;
+
+		passphrase = __archive_read_next_passphrase(a);
+		if (passphrase == NULL) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    (retry > 0)?
+				"Incorrect passphrase":
+				"Passphrase required for this entry");
+			return (ARCHIVE_FAILED);
+		}
+
+		/*
+		 * Initialize ctx for Traditional PKWARE Decryption.
+		 */
+		r = trad_enc_init(&zip->tctx, passphrase, strlen(passphrase),
+			p, ENC_HEADER_SIZE, &crcchk);
+		if (r == 0 && crcchk == zip->entry->decdat)
+			break;/* The passphrase is OK. */
+		if (retry > 10000) {
+			/* Avoid infinity loop. */
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "Too many incorrect passphrases");
+			return (ARCHIVE_FAILED);
+		}
+	}
+
+	__archive_read_consume(a, ENC_HEADER_SIZE);
+	zip->tctx_valid = 1;
+	if (0 == (zip->entry->zip_flags & ZIP_LENGTH_AT_END)) {
+	    zip->entry_bytes_remaining -= ENC_HEADER_SIZE;
+	}
+	/*zip->entry_uncompressed_bytes_read += ENC_HEADER_SIZE;*/
+	zip->entry_compressed_bytes_read += ENC_HEADER_SIZE;
+	zip->decrypted_bytes_remaining = 0;
+
+	return (zip_alloc_decryption_buffer(a));
+#undef ENC_HEADER_SIZE
+}
+
+static int
+init_WinZip_AES_decryption(struct archive_read *a)
+{
+	struct zip *zip = (struct zip *)(a->format->data);
+	const void *p;
+	const uint8_t *pv;
+	size_t key_len, salt_len;
+	uint8_t derived_key[MAX_DERIVED_KEY_BUF_SIZE];
+	int retry;
+	int r;
+
+	if (zip->cctx_valid || zip->hctx_valid)
+		return (ARCHIVE_OK);
+
+	switch (zip->entry->aes_extra.strength) {
+	case 1: salt_len = 8;  key_len = 16; break;
+	case 2: salt_len = 12; key_len = 24; break;
+	case 3: salt_len = 16; key_len = 32; break;
+	default: goto corrupted;
+	}
+	p = __archive_read_ahead(a, salt_len + 2, NULL);
+	if (p == NULL)
+		goto truncated;
+
+	for (retry = 0;; retry++) {
+		const char *passphrase;
+
+		passphrase = __archive_read_next_passphrase(a);
+		if (passphrase == NULL) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    (retry > 0)?
+				"Incorrect passphrase":
+				"Passphrase required for this entry");
+			return (ARCHIVE_FAILED);
+		}
+		memset(derived_key, 0, sizeof(derived_key));
+		r = archive_pbkdf2_sha1(passphrase, strlen(passphrase),
+		    p, salt_len, 1000, derived_key, key_len * 2 + 2);
+		if (r != 0) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "Decryption is unsupported due to lack of "
+			    "crypto library");
+			return (ARCHIVE_FAILED);
+		}
+
+		/* Check password verification value. */
+		pv = ((const uint8_t *)p) + salt_len;
+		if (derived_key[key_len * 2] == pv[0] &&
+		    derived_key[key_len * 2 + 1] == pv[1])
+			break;/* The passphrase is OK. */
+		if (retry > 10000) {
+			/* Avoid infinity loop. */
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "Too many incorrect passphrases");
+			return (ARCHIVE_FAILED);
+		}
+	}
+
+	r = archive_decrypto_aes_ctr_init(&zip->cctx, derived_key, key_len);
+	if (r != 0) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+		    "Decryption is unsupported due to lack of crypto library");
+		return (ARCHIVE_FAILED);
+	}
+	r = archive_hmac_sha1_init(&zip->hctx, derived_key + key_len, key_len);
+	if (r != 0) {
+		archive_decrypto_aes_ctr_release(&zip->cctx);
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+		    "Failed to initialize HMAC-SHA1");
+		return (ARCHIVE_FAILED);
+	}
+	zip->cctx_valid = zip->hctx_valid = 1;
+	__archive_read_consume(a, salt_len + 2);
+	zip->entry_bytes_remaining -= salt_len + 2 + AUTH_CODE_SIZE;
+	if (0 == (zip->entry->zip_flags & ZIP_LENGTH_AT_END)
+	    && zip->entry_bytes_remaining < 0)
+		goto corrupted;
+	zip->entry_compressed_bytes_read += salt_len + 2 + AUTH_CODE_SIZE;
+	zip->decrypted_bytes_remaining = 0;
+
+	zip->entry->compression = zip->entry->aes_extra.compression;
+	return (zip_alloc_decryption_buffer(a));
+
+truncated:
+	archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+	    "Truncated ZIP file data");
+	return (ARCHIVE_FATAL);
+corrupted:
+	archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+	    "Corrupted ZIP file data");
+	return (ARCHIVE_FATAL);
+}
+
+static int
+archive_read_format_zip_read_data(struct archive_read *a,
+    const void **buff, size_t *size, int64_t *offset)
+{
+	int r;
+	struct zip *zip = (struct zip *)(a->format->data);
+
+	if (zip->has_encrypted_entries ==
+			ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {
+		zip->has_encrypted_entries = 0;
+	}
+
+	*offset = zip->entry_uncompressed_bytes_read;
+	*size = 0;
+	*buff = NULL;
+
+	/* If we hit end-of-entry last time, return ARCHIVE_EOF. */
+	if (zip->end_of_entry)
+		return (ARCHIVE_EOF);
+
+	/* Return EOF immediately if this is a non-regular file. */
+	if (AE_IFREG != (zip->entry->mode & AE_IFMT))
+		return (ARCHIVE_EOF);
+
+	__archive_read_consume(a, zip->unconsumed);
+	zip->unconsumed = 0;
+
+	if (zip->init_decryption) {
+		zip->has_encrypted_entries = 1;
+		if (zip->entry->zip_flags & ZIP_STRONG_ENCRYPTED)
+			r = read_decryption_header(a);
+		else if (zip->entry->compression == WINZIP_AES_ENCRYPTION)
+			r = init_WinZip_AES_decryption(a);
+		else
+			r = init_traditional_PKWARE_decryption(a);
+		if (r != ARCHIVE_OK)
+			return (r);
+		zip->init_decryption = 0;
+	}
+
+	switch(zip->entry->compression) {
+	case 0:  /* No compression. */
+		r =  zip_read_data_none(a, buff, size, offset);
+		break;
+#ifdef HAVE_ZLIB_H
+	case 8: /* Deflate compression. */
+		r =  zip_read_data_deflate(a, buff, size, offset);
+		break;
+#endif
+	default: /* Unsupported compression. */
+		/* Return a warning. */
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+		    "Unsupported ZIP compression method (%s)",
+		    compression_name(zip->entry->compression));
+		/* We can't decompress this entry, but we will
+		 * be able to skip() it and try the next entry. */
+		return (ARCHIVE_FAILED);
+		break;
+	}
+	if (r != ARCHIVE_OK)
+		return (r);
+	/* Update checksum */
+	if (*size)
+		zip->entry_crc32 = zip->crc32func(zip->entry_crc32, *buff,
+		    (unsigned)*size);
+	/* If we hit the end, swallow any end-of-data marker. */
+	if (zip->end_of_entry) {
+		/* Check file size, CRC against these values. */
+		if (zip->entry->compressed_size !=
+		    zip->entry_compressed_bytes_read) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "ZIP compressed data is wrong size "
+			    "(read %jd, expected %jd)",
+			    (intmax_t)zip->entry_compressed_bytes_read,
+			    (intmax_t)zip->entry->compressed_size);
+			return (ARCHIVE_WARN);
+		}
+		/* Size field only stores the lower 32 bits of the actual
+		 * size. */
+		if ((zip->entry->uncompressed_size & UINT32_MAX)
+		    != (zip->entry_uncompressed_bytes_read & UINT32_MAX)) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "ZIP uncompressed data is wrong size "
+			    "(read %jd, expected %jd)\n",
+			    (intmax_t)zip->entry_uncompressed_bytes_read,
+			    (intmax_t)zip->entry->uncompressed_size);
+			return (ARCHIVE_WARN);
+		}
+		/* Check computed CRC against header */
+		if ((!zip->hctx_valid ||
+		      zip->entry->aes_extra.vendor != AES_VENDOR_AE_2) &&
+		   zip->entry->crc32 != zip->entry_crc32
+		    && !zip->ignore_crc32) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "ZIP bad CRC: 0x%lx should be 0x%lx",
+			    (unsigned long)zip->entry_crc32,
+			    (unsigned long)zip->entry->crc32);
+			return (ARCHIVE_WARN);
+		}
+	}
+
+	return (ARCHIVE_OK);
+}
+
+static int
+archive_read_format_zip_cleanup(struct archive_read *a)
+{
+	struct zip *zip;
+	struct zip_entry *zip_entry, *next_zip_entry;
+
+	zip = (struct zip *)(a->format->data);
+#ifdef HAVE_ZLIB_H
+	if (zip->stream_valid)
+		inflateEnd(&zip->stream);
+	free(zip->uncompressed_buffer);
+#endif
+	if (zip->zip_entries) {
+		zip_entry = zip->zip_entries;
+		while (zip_entry != NULL) {
+			next_zip_entry = zip_entry->next;
+			archive_string_free(&zip_entry->rsrcname);
+			free(zip_entry);
+			zip_entry = next_zip_entry;
+		}
+	}
+	free(zip->decrypted_buffer);
+	if (zip->cctx_valid)
+		archive_decrypto_aes_ctr_release(&zip->cctx);
+	if (zip->hctx_valid)
+		archive_hmac_sha1_cleanup(&zip->hctx);
+	free(zip->iv);
+	free(zip->erd);
+	free(zip->v_data);
+	archive_string_free(&zip->format_name);
+	free(zip);
+	(a->format->data) = NULL;
+	return (ARCHIVE_OK);
+}
+
+static int
+archive_read_format_zip_has_encrypted_entries(struct archive_read *_a)
+{
+	if (_a && _a->format) {
+		struct zip * zip = (struct zip *)_a->format->data;
+		if (zip) {
+			return zip->has_encrypted_entries;
+		}
+	}
+	return ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW;
+}
+
+static int
+archive_read_format_zip_options(struct archive_read *a,
+    const char *key, const char *val)
+{
+	struct zip *zip;
+	int ret = ARCHIVE_FAILED;
+
+	zip = (struct zip *)(a->format->data);
+	if (strcmp(key, "compat-2x")  == 0) {
+		/* Handle filenames as libarchive 2.x */
+		zip->init_default_conversion = (val != NULL) ? 1 : 0;
+		return (ARCHIVE_OK);
+	} else if (strcmp(key, "hdrcharset")  == 0) {
+		if (val == NULL || val[0] == 0)
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "zip: hdrcharset option needs a character-set name"
+			);
+		else {
+			zip->sconv = archive_string_conversion_from_charset(
+			    &a->archive, val, 0);
+			if (zip->sconv != NULL) {
+				if (strcmp(val, "UTF-8") == 0)
+					zip->sconv_utf8 = zip->sconv;
+				ret = ARCHIVE_OK;
+			} else
+				ret = ARCHIVE_FATAL;
+		}
+		return (ret);
+	} else if (strcmp(key, "ignorecrc32") == 0) {
+		/* Mostly useful for testing. */
+		if (val == NULL || val[0] == 0) {
+			zip->crc32func = real_crc32;
+			zip->ignore_crc32 = 0;
+		} else {
+			zip->crc32func = fake_crc32;
+			zip->ignore_crc32 = 1;
+		}
+		return (ARCHIVE_OK);
+	} else if (strcmp(key, "mac-ext") == 0) {
+		zip->process_mac_extensions = (val != NULL && val[0] != 0);
+		return (ARCHIVE_OK);
+	}
+
+	/* Note: The "warn" return is just to inform the options
+	 * supervisor that we didn't handle it.  It will generate
+	 * a suitable error if no one used this option. */
+	return (ARCHIVE_WARN);
+}
+
+int
+archive_read_support_format_zip(struct archive *a)
+{
+	int r;
+	r = archive_read_support_format_zip_streamable(a);
+	if (r != ARCHIVE_OK)
+		return r;
+	return (archive_read_support_format_zip_seekable(a));
+}
+
+/* ------------------------------------------------------------------------ */
+
+/*
+ * Streaming-mode support
+ */
+
+
+static int
+archive_read_support_format_zip_capabilities_streamable(struct archive_read * a)
+{
+	(void)a; /* UNUSED */
+	return (ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_DATA |
+		ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_METADATA);
+}
+
+static int
+archive_read_format_zip_streamable_bid(struct archive_read *a, int best_bid)
+{
+	const char *p;
+
+	(void)best_bid; /* UNUSED */
+
+	if ((p = __archive_read_ahead(a, 4, NULL)) == NULL)
+		return (-1);
+
+	/*
+	 * Bid of 29 here comes from:
+	 *  + 16 bits for "PK",
+	 *  + next 16-bit field has 6 options so contributes
+	 *    about 16 - log_2(6) ~= 16 - 2.6 ~= 13 bits
+	 *
+	 * So we've effectively verified ~29 total bits of check data.
+	 */
+	if (p[0] == 'P' && p[1] == 'K') {
+		if ((p[2] == '\001' && p[3] == '\002')
+		    || (p[2] == '\003' && p[3] == '\004')
+		    || (p[2] == '\005' && p[3] == '\006')
+		    || (p[2] == '\006' && p[3] == '\006')
+		    || (p[2] == '\007' && p[3] == '\010')
+		    || (p[2] == '0' && p[3] == '0'))
+			return (29);
+	}
+
+	/* TODO: It's worth looking ahead a little bit for a valid
+	 * PK signature.  In particular, that would make it possible
+	 * to read some UUEncoded SFX files or SFX files coming from
+	 * a network socket. */
+
+	return (0);
+}
+
+static int
+archive_read_format_zip_streamable_read_header(struct archive_read *a,
+    struct archive_entry *entry)
+{
+	struct zip *zip;
+
+	a->archive.archive_format = ARCHIVE_FORMAT_ZIP;
+	if (a->archive.archive_format_name == NULL)
+		a->archive.archive_format_name = "ZIP";
+
+	zip = (struct zip *)(a->format->data);
+
+	/*
+	 * It should be sufficient to call archive_read_next_header() for
+	 * a reader to determine if an entry is encrypted or not. If the
+	 * encryption of an entry is only detectable when calling
+	 * archive_read_data(), so be it. We'll do the same check there
+	 * as well.
+	 */
+	if (zip->has_encrypted_entries ==
+			ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW)
+		zip->has_encrypted_entries = 0;
+
+	/* Make sure we have a zip_entry structure to use. */
+	if (zip->zip_entries == NULL) {
+		zip->zip_entries = malloc(sizeof(struct zip_entry));
+		if (zip->zip_entries == NULL) {
+			archive_set_error(&a->archive, ENOMEM,
+			    "Out  of memory");
+			return ARCHIVE_FATAL;
+		}
+	}
+	zip->entry = zip->zip_entries;
+	memset(zip->entry, 0, sizeof(struct zip_entry));
+
+	if (zip->cctx_valid)
+		archive_decrypto_aes_ctr_release(&zip->cctx);
+	if (zip->hctx_valid)
+		archive_hmac_sha1_cleanup(&zip->hctx);
+	zip->tctx_valid = zip->cctx_valid = zip->hctx_valid = 0;
+	__archive_read_reset_passphrase(a);
+
+	/* Search ahead for the next local file header. */
+	__archive_read_consume(a, zip->unconsumed);
+	zip->unconsumed = 0;
+	for (;;) {
+		int64_t skipped = 0;
+		const char *p, *end;
+		ssize_t bytes;
+
+		p = __archive_read_ahead(a, 4, &bytes);
+		if (p == NULL)
+			return (ARCHIVE_FATAL);
+		end = p + bytes;
+
+		while (p + 4 <= end) {
+			if (p[0] == 'P' && p[1] == 'K') {
+				if (p[2] == '\003' && p[3] == '\004') {
+					/* Regular file entry. */
+					__archive_read_consume(a, skipped);
+					return zip_read_local_file_header(a,
+					    entry, zip);
+				}
+
+                              /*
+                               * TODO: We cannot restore permissions
+                               * based only on the local file headers.
+                               * Consider scanning the central
+                               * directory and returning additional
+                               * entries for at least directories.
+                               * This would allow us to properly set
+                               * directory permissions.
+			       *
+			       * This won't help us fix symlinks
+			       * and may not help with regular file
+			       * permissions, either.  <sigh>
+                               */
+                              if (p[2] == '\001' && p[3] == '\002') {
+                                      return (ARCHIVE_EOF);
+                              }
+
+                              /* End of central directory?  Must be an
+                               * empty archive. */
+                              if ((p[2] == '\005' && p[3] == '\006')
+                                  || (p[2] == '\006' && p[3] == '\006'))
+                                      return (ARCHIVE_EOF);
+			}
+			++p;
+			++skipped;
+		}
+		__archive_read_consume(a, skipped);
+	}
+}
+
+static int
+archive_read_format_zip_read_data_skip_streamable(struct archive_read *a)
+{
+	struct zip *zip;
+	int64_t bytes_skipped;
+
+	zip = (struct zip *)(a->format->data);
+	bytes_skipped = __archive_read_consume(a, zip->unconsumed);
+	zip->unconsumed = 0;
+	if (bytes_skipped < 0)
+		return (ARCHIVE_FATAL);
+
+	/* If we've already read to end of data, we're done. */
+	if (zip->end_of_entry)
+		return (ARCHIVE_OK);
+
+	/* So we know we're streaming... */
+	if (0 == (zip->entry->zip_flags & ZIP_LENGTH_AT_END)
+	    || zip->entry->compressed_size > 0) {
+		/* We know the compressed length, so we can just skip. */
+		bytes_skipped = __archive_read_consume(a,
+					zip->entry_bytes_remaining);
+		if (bytes_skipped < 0)
+			return (ARCHIVE_FATAL);
+		return (ARCHIVE_OK);
+	}
+
+	if (zip->init_decryption) {
+		int r;
+
+		zip->has_encrypted_entries = 1;
+		if (zip->entry->zip_flags & ZIP_STRONG_ENCRYPTED)
+			r = read_decryption_header(a);
+		else if (zip->entry->compression == WINZIP_AES_ENCRYPTION)
+			r = init_WinZip_AES_decryption(a);
+		else
+			r = init_traditional_PKWARE_decryption(a);
+		if (r != ARCHIVE_OK)
+			return (r);
+		zip->init_decryption = 0;
+	}
+
+	/* We're streaming and we don't know the length. */
+	/* If the body is compressed and we know the format, we can
+	 * find an exact end-of-entry by decompressing it. */
+	switch (zip->entry->compression) {
+#ifdef HAVE_ZLIB_H
+	case 8: /* Deflate compression. */
+		while (!zip->end_of_entry) {
+			int64_t offset = 0;
+			const void *buff = NULL;
+			size_t size = 0;
+			int r;
+			r =  zip_read_data_deflate(a, &buff, &size, &offset);
+			if (r != ARCHIVE_OK)
+				return (r);
+		}
+		return ARCHIVE_OK;
+#endif
+	default: /* Uncompressed or unknown. */
+		/* Scan for a PK\007\010 signature. */
+		for (;;) {
+			const char *p, *buff;
+			ssize_t bytes_avail;
+			buff = __archive_read_ahead(a, 16, &bytes_avail);
+			if (bytes_avail < 16) {
+				archive_set_error(&a->archive,
+				    ARCHIVE_ERRNO_FILE_FORMAT,
+				    "Truncated ZIP file data");
+				return (ARCHIVE_FATAL);
+			}
+			p = buff;
+			while (p <= buff + bytes_avail - 16) {
+				if (p[3] == 'P') { p += 3; }
+				else if (p[3] == 'K') { p += 2; }
+				else if (p[3] == '\007') { p += 1; }
+				else if (p[3] == '\010' && p[2] == '\007'
+				    && p[1] == 'K' && p[0] == 'P') {
+					if (zip->entry->flags & LA_USED_ZIP64)
+						__archive_read_consume(a,
+						    p - buff + 24);
+					else
+						__archive_read_consume(a,
+						    p - buff + 16);
+					return ARCHIVE_OK;
+				} else { p += 4; }
+			}
+			__archive_read_consume(a, p - buff);
+		}
+	}
+}
+
+int
+archive_read_support_format_zip_streamable(struct archive *_a)
+{
+	struct archive_read *a = (struct archive_read *)_a;
+	struct zip *zip;
+	int r;
+
+	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
+	    ARCHIVE_STATE_NEW, "archive_read_support_format_zip");
+
+	zip = (struct zip *)calloc(1, sizeof(*zip));
+	if (zip == NULL) {
+		archive_set_error(&a->archive, ENOMEM,
+		    "Can't allocate zip data");
+		return (ARCHIVE_FATAL);
+	}
+
+	/* Streamable reader doesn't support mac extensions. */
+	zip->process_mac_extensions = 0;
+
+	/*
+	 * Until enough data has been read, we cannot tell about
+	 * any encrypted entries yet.
+	 */
+	zip->has_encrypted_entries = ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW;
+	zip->crc32func = real_crc32;
+
+	r = __archive_read_register_format(a,
+	    zip,
+	    "zip",
+	    archive_read_format_zip_streamable_bid,
+	    archive_read_format_zip_options,
+	    archive_read_format_zip_streamable_read_header,
+	    archive_read_format_zip_read_data,
+	    archive_read_format_zip_read_data_skip_streamable,
+	    NULL,
+	    archive_read_format_zip_cleanup,
+	    archive_read_support_format_zip_capabilities_streamable,
+	    archive_read_format_zip_has_encrypted_entries);
+
+	if (r != ARCHIVE_OK)
+		free(zip);
+	return (ARCHIVE_OK);
+}
+
+/* ------------------------------------------------------------------------ */
+
+/*
+ * Seeking-mode support
+ */
+
+static int
+archive_read_support_format_zip_capabilities_seekable(struct archive_read * a)
+{
+	(void)a; /* UNUSED */
+	return (ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_DATA |
+		ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_METADATA);
+}
+
+/*
+ * TODO: This is a performance sink because it forces the read core to
+ * drop buffered data from the start of file, which will then have to
+ * be re-read again if this bidder loses.
+ *
+ * We workaround this a little by passing in the best bid so far so
+ * that later bidders can do nothing if they know they'll never
+ * outbid.  But we can certainly do better...
+ */
+static int
+read_eocd(struct zip *zip, const char *p, int64_t current_offset)
+{
+	/* Sanity-check the EOCD we've found. */
+
+	/* This must be the first volume. */
+	if (archive_le16dec(p + 4) != 0)
+		return 0;
+	/* Central directory must be on this volume. */
+	if (archive_le16dec(p + 4) != archive_le16dec(p + 6))
+		return 0;
+	/* All central directory entries must be on this volume. */
+	if (archive_le16dec(p + 10) != archive_le16dec(p + 8))
+		return 0;
+	/* Central directory can't extend beyond start of EOCD record. */
+	if (archive_le32dec(p + 16) + archive_le32dec(p + 12)
+	    > current_offset)
+		return 0;
+
+	/* Save the central directory location for later use. */
+	zip->central_directory_offset = archive_le32dec(p + 16);
+
+	/* This is just a tiny bit higher than the maximum
+	   returned by the streaming Zip bidder.  This ensures
+	   that the more accurate seeking Zip parser wins
+	   whenever seek is available. */
+	return 32;
+}
+
+/*
+ * Examine Zip64 EOCD locator:  If it's valid, store the information
+ * from it.
+ */
+static int
+read_zip64_eocd(struct archive_read *a, struct zip *zip, const char *p)
+{
+	int64_t eocd64_offset;
+	int64_t eocd64_size;
+
+	/* Sanity-check the locator record. */
+
+	/* Central dir must be on first volume. */
+	if (archive_le32dec(p + 4) != 0)
+		return 0;
+	/* Must be only a single volume. */
+	if (archive_le32dec(p + 16) != 1)
+		return 0;
+
+	/* Find the Zip64 EOCD record. */
+	eocd64_offset = archive_le64dec(p + 8);
+	if (__archive_read_seek(a, eocd64_offset, SEEK_SET) < 0)
+		return 0;
+	if ((p = __archive_read_ahead(a, 56, NULL)) == NULL)
+		return 0;
+	/* Make sure we can read all of it. */
+	eocd64_size = archive_le64dec(p + 4) + 12;
+	if (eocd64_size < 56 || eocd64_size > 16384)
+		return 0;
+	if ((p = __archive_read_ahead(a, (size_t)eocd64_size, NULL)) == NULL)
+		return 0;
+
+	/* Sanity-check the EOCD64 */
+	if (archive_le32dec(p + 16) != 0) /* Must be disk #0 */
+		return 0;
+	if (archive_le32dec(p + 20) != 0) /* CD must be on disk #0 */
+		return 0;
+	/* CD can't be split. */
+	if (archive_le64dec(p + 24) != archive_le64dec(p + 32))
+		return 0;
+
+	/* Save the central directory offset for later use. */
+	zip->central_directory_offset = archive_le64dec(p + 48);
+
+	return 32;
+}
+
+static int
+archive_read_format_zip_seekable_bid(struct archive_read *a, int best_bid)
+{
+	struct zip *zip = (struct zip *)a->format->data;
+	int64_t file_size, current_offset;
+	const char *p;
+	int i, tail;
+
+	/* If someone has already bid more than 32, then avoid
+	   trashing the look-ahead buffers with a seek. */
+	if (best_bid > 32)
+		return (-1);
+
+	file_size = __archive_read_seek(a, 0, SEEK_END);
+	if (file_size <= 0)
+		return 0;
+
+	/* Search last 16k of file for end-of-central-directory
+	 * record (which starts with PK\005\006) */
+	tail = (int)zipmin(1024 * 16, file_size);
+	current_offset = __archive_read_seek(a, -tail, SEEK_END);
+	if (current_offset < 0)
+		return 0;
+	if ((p = __archive_read_ahead(a, (size_t)tail, NULL)) == NULL)
+		return 0;
+	/* Boyer-Moore search backwards from the end, since we want
+	 * to match the last EOCD in the file (there can be more than
+	 * one if there is an uncompressed Zip archive as a member
+	 * within this Zip archive). */
+	for (i = tail - 22; i > 0;) {
+		switch (p[i]) {
+		case 'P':
+			if (memcmp(p + i, "PK\005\006", 4) == 0) {
+				int ret = read_eocd(zip, p + i,
+				    current_offset + i);
+				/* Zip64 EOCD locator precedes
+				 * regular EOCD if present. */
+				if (i >= 20 && memcmp(p + i - 20, "PK\006\007", 4) == 0) {
+					int ret_zip64 = read_zip64_eocd(a, zip, p + i - 20);
+					if (ret_zip64 > ret)
+						ret = ret_zip64;
+				}
+				return (ret);
+			}
+			i -= 4;
+			break;
+		case 'K': i -= 1; break;
+		case 005: i -= 2; break;
+		case 006: i -= 3; break;
+		default: i -= 4; break;
+		}
+	}
+	return 0;
+}
+
+/* The red-black trees are only used in seeking mode to manage
+ * the in-memory copy of the central directory. */
+
+static int
+cmp_node(const struct archive_rb_node *n1, const struct archive_rb_node *n2)
+{
+	const struct zip_entry *e1 = (const struct zip_entry *)n1;
+	const struct zip_entry *e2 = (const struct zip_entry *)n2;
+
+	if (e1->local_header_offset > e2->local_header_offset)
+		return -1;
+	if (e1->local_header_offset < e2->local_header_offset)
+		return 1;
+	return 0;
+}
+
+static int
+cmp_key(const struct archive_rb_node *n, const void *key)
+{
+	/* This function won't be called */
+	(void)n; /* UNUSED */
+	(void)key; /* UNUSED */
+	return 1;
+}
+
+static const struct archive_rb_tree_ops rb_ops = {
+	&cmp_node, &cmp_key
+};
+
+static int
+rsrc_cmp_node(const struct archive_rb_node *n1,
+    const struct archive_rb_node *n2)
+{
+	const struct zip_entry *e1 = (const struct zip_entry *)n1;
+	const struct zip_entry *e2 = (const struct zip_entry *)n2;
+
+	return (strcmp(e2->rsrcname.s, e1->rsrcname.s));
+}
+
+static int
+rsrc_cmp_key(const struct archive_rb_node *n, const void *key)
+{
+	const struct zip_entry *e = (const struct zip_entry *)n;
+	return (strcmp((const char *)key, e->rsrcname.s));
+}
+
+static const struct archive_rb_tree_ops rb_rsrc_ops = {
+	&rsrc_cmp_node, &rsrc_cmp_key
+};
+
+static const char *
+rsrc_basename(const char *name, size_t name_length)
+{
+	const char *s, *r;
+
+	r = s = name;
+	for (;;) {
+		s = memchr(s, '/', name_length - (s - name));
+		if (s == NULL)
+			break;
+		r = ++s;
+	}
+	return (r);
+}
+
+static void
+expose_parent_dirs(struct zip *zip, const char *name, size_t name_length)
+{
+	struct archive_string str;
+	struct zip_entry *dir;
+	char *s;
+
+	archive_string_init(&str);
+	archive_strncpy(&str, name, name_length);
+	for (;;) {
+		s = strrchr(str.s, '/');
+		if (s == NULL)
+			break;
+		*s = '\0';
+		/* Transfer the parent directory from zip->tree_rsrc RB
+		 * tree to zip->tree RB tree to expose. */
+		dir = (struct zip_entry *)
+		    __archive_rb_tree_find_node(&zip->tree_rsrc, str.s);
+		if (dir == NULL)
+			break;
+		__archive_rb_tree_remove_node(&zip->tree_rsrc, &dir->node);
+		archive_string_free(&dir->rsrcname);
+		__archive_rb_tree_insert_node(&zip->tree, &dir->node);
+	}
+	archive_string_free(&str);
+}
+
+static int
+slurp_central_directory(struct archive_read *a, struct zip *zip)
+{
+	ssize_t i;
+	unsigned found;
+	int64_t correction;
+	ssize_t bytes_avail;
+	const char *p;
+
+	/*
+	 * Find the start of the central directory.  The end-of-CD
+	 * record has our starting point, but there are lots of
+	 * Zip archives which have had other data prepended to the
+	 * file, which makes the recorded offsets all too small.
+	 * So we search forward from the specified offset until we
+	 * find the real start of the central directory.  Then we
+	 * know the correction we need to apply to account for leading
+	 * padding.
+	 */
+	if (__archive_read_seek(a, zip->central_directory_offset, SEEK_SET) < 0)
+		return ARCHIVE_FATAL;
+
+	found = 0;
+	while (!found) {
+		if ((p = __archive_read_ahead(a, 20, &bytes_avail)) == NULL)
+			return ARCHIVE_FATAL;
+		for (found = 0, i = 0; !found && i < bytes_avail - 4;) {
+			switch (p[i + 3]) {
+			case 'P': i += 3; break;
+			case 'K': i += 2; break;
+			case 001: i += 1; break;
+			case 002:
+				if (memcmp(p + i, "PK\001\002", 4) == 0) {
+					p += i;
+					found = 1;
+				} else
+					i += 4;
+				break;
+			case 005: i += 1; break;
+			case 006:
+				if (memcmp(p + i, "PK\005\006", 4) == 0) {
+					p += i;
+					found = 1;
+				} else if (memcmp(p + i, "PK\006\006", 4) == 0) {
+					p += i;
+					found = 1;
+				} else
+					i += 1;
+				break;
+			default: i += 4; break;
+			}
+		}
+		__archive_read_consume(a, i);
+	}
+	correction = archive_filter_bytes(&a->archive, 0)
+			- zip->central_directory_offset;
+
+	__archive_rb_tree_init(&zip->tree, &rb_ops);
+	__archive_rb_tree_init(&zip->tree_rsrc, &rb_rsrc_ops);
+
+	zip->central_directory_entries_total = 0;
+	while (1) {
+		struct zip_entry *zip_entry;
+		size_t filename_length, extra_length, comment_length;
+		uint32_t external_attributes;
+		const char *name, *r;
+
+		if ((p = __archive_read_ahead(a, 4, NULL)) == NULL)
+			return ARCHIVE_FATAL;
+		if (memcmp(p, "PK\006\006", 4) == 0
+		    || memcmp(p, "PK\005\006", 4) == 0) {
+			break;
+		} else if (memcmp(p, "PK\001\002", 4) != 0) {
+			archive_set_error(&a->archive,
+			    -1, "Invalid central directory signature");
+			return ARCHIVE_FATAL;
+		}
+		if ((p = __archive_read_ahead(a, 46, NULL)) == NULL)
+			return ARCHIVE_FATAL;
+
+		zip_entry = calloc(1, sizeof(struct zip_entry));
+		zip_entry->next = zip->zip_entries;
+		zip_entry->flags |= LA_FROM_CENTRAL_DIRECTORY;
+		zip->zip_entries = zip_entry;
+		zip->central_directory_entries_total++;
+
+		/* version = p[4]; */
+		zip_entry->system = p[5];
+		/* version_required = archive_le16dec(p + 6); */
+		zip_entry->zip_flags = archive_le16dec(p + 8);
+		if (zip_entry->zip_flags
+		      & (ZIP_ENCRYPTED | ZIP_STRONG_ENCRYPTED)){
+			zip->has_encrypted_entries = 1;
+		}
+		zip_entry->compression = (char)archive_le16dec(p + 10);
+		zip_entry->mtime = zip_time(p + 12);
+		zip_entry->crc32 = archive_le32dec(p + 16);
+		if (zip_entry->zip_flags & ZIP_LENGTH_AT_END)
+			zip_entry->decdat = p[13];
+		else
+			zip_entry->decdat = p[19];
+		zip_entry->compressed_size = archive_le32dec(p + 20);
+		zip_entry->uncompressed_size = archive_le32dec(p + 24);
+		filename_length = archive_le16dec(p + 28);
+		extra_length = archive_le16dec(p + 30);
+		comment_length = archive_le16dec(p + 32);
+		/* disk_start = archive_le16dec(p + 34); */ /* Better be zero. */
+		/* internal_attributes = archive_le16dec(p + 36); */ /* text bit */
+		external_attributes = archive_le32dec(p + 38);
+		zip_entry->local_header_offset =
+		    archive_le32dec(p + 42) + correction;
+
+		/* If we can't guess the mode, leave it zero here;
+		   when we read the local file header we might get
+		   more information. */
+		if (zip_entry->system == 3) {
+			zip_entry->mode = external_attributes >> 16;
+		} else if (zip_entry->system == 0) {
+			// Interpret MSDOS directory bit
+			if (0x10 == (external_attributes & 0x10)) {
+				zip_entry->mode = AE_IFDIR | 0775;
+			} else {
+				zip_entry->mode = AE_IFREG | 0664;
+			}
+			if (0x01 == (external_attributes & 0x01)) {
+				// Read-only bit; strip write permissions
+				zip_entry->mode &= 0555;
+			}
+		} else {
+			zip_entry->mode = 0;
+		}
+
+		/* We're done with the regular data; get the filename and
+		 * extra data. */
+		__archive_read_consume(a, 46);
+		p = __archive_read_ahead(a, filename_length + extra_length,
+			NULL);
+		if (p == NULL) {
+			archive_set_error(&a->archive,
+			    ARCHIVE_ERRNO_FILE_FORMAT,
+			    "Truncated ZIP file header");
+			return ARCHIVE_FATAL;
+		}
+		if (ARCHIVE_OK != process_extra(a, p + filename_length, extra_length, zip_entry)) {
+			return ARCHIVE_FATAL;
+		}
+
+		/*
+		 * Mac resource fork files are stored under the
+		 * "__MACOSX/" directory, so we should check if
+		 * it is.
+		 */
+		if (!zip->process_mac_extensions) {
+			/* Treat every entry as a regular entry. */
+			__archive_rb_tree_insert_node(&zip->tree,
+			    &zip_entry->node);
+		} else {
+			name = p;
+			r = rsrc_basename(name, filename_length);
+			if (filename_length >= 9 &&
+			    strncmp("__MACOSX/", name, 9) == 0) {
+				/* If this file is not a resource fork nor
+				 * a directory. We should treat it as a non
+				 * resource fork file to expose it. */
+				if (name[filename_length-1] != '/' &&
+				    (r - name < 3 || r[0] != '.' || r[1] != '_')) {
+					__archive_rb_tree_insert_node(
+					    &zip->tree, &zip_entry->node);
+					/* Expose its parent directories. */
+					expose_parent_dirs(zip, name,
+					    filename_length);
+				} else {
+					/* This file is a resource fork file or
+					 * a directory. */
+					archive_strncpy(&(zip_entry->rsrcname),
+					     name, filename_length);
+					__archive_rb_tree_insert_node(
+					    &zip->tree_rsrc, &zip_entry->node);
+				}
+			} else {
+				/* Generate resource fork name to find its
+				 * resource file at zip->tree_rsrc. */
+				archive_strcpy(&(zip_entry->rsrcname),
+				    "__MACOSX/");
+				archive_strncat(&(zip_entry->rsrcname),
+				    name, r - name);
+				archive_strcat(&(zip_entry->rsrcname), "._");
+				archive_strncat(&(zip_entry->rsrcname),
+				    name + (r - name),
+				    filename_length - (r - name));
+				/* Register an entry to RB tree to sort it by
+				 * file offset. */
+				__archive_rb_tree_insert_node(&zip->tree,
+				    &zip_entry->node);
+			}
+		}
+
+		/* Skip the comment too ... */
+		__archive_read_consume(a,
+		    filename_length + extra_length + comment_length);
+	}
+
+	return ARCHIVE_OK;
+}
+
+static ssize_t
+zip_get_local_file_header_size(struct archive_read *a, size_t extra)
+{
+	const char *p;
+	ssize_t filename_length, extra_length;
+
+	if ((p = __archive_read_ahead(a, extra + 30, NULL)) == NULL) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+		    "Truncated ZIP file header");
+		return (ARCHIVE_WARN);
+	}
+	p += extra;
+
+	if (memcmp(p, "PK\003\004", 4) != 0) {
+		archive_set_error(&a->archive, -1, "Damaged Zip archive");
+		return ARCHIVE_WARN;
+	}
+	filename_length = archive_le16dec(p + 26);
+	extra_length = archive_le16dec(p + 28);
+
+	return (30 + filename_length + extra_length);
+}
+
+static int
+zip_read_mac_metadata(struct archive_read *a, struct archive_entry *entry,
+    struct zip_entry *rsrc)
+{
+	struct zip *zip = (struct zip *)a->format->data;
+	unsigned char *metadata, *mp;
+	int64_t offset = archive_filter_bytes(&a->archive, 0);
+	size_t remaining_bytes, metadata_bytes;
+	ssize_t hsize;
+	int ret = ARCHIVE_OK, eof;
+
+	switch(rsrc->compression) {
+	case 0:  /* No compression. */
+		if (rsrc->uncompressed_size != rsrc->compressed_size) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+			    "Malformed OS X metadata entry: inconsistent size");
+			return (ARCHIVE_FATAL);
+		}
+#ifdef HAVE_ZLIB_H
+	case 8: /* Deflate compression. */
+#endif
+		break;
+	default: /* Unsupported compression. */
+		/* Return a warning. */
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+		    "Unsupported ZIP compression method (%s)",
+		    compression_name(rsrc->compression));
+		/* We can't decompress this entry, but we will
+		 * be able to skip() it and try the next entry. */
+		return (ARCHIVE_WARN);
+	}
+
+	if (rsrc->uncompressed_size > (4 * 1024 * 1024)) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+		    "Mac metadata is too large: %jd > 4M bytes",
+		    (intmax_t)rsrc->uncompressed_size);
+		return (ARCHIVE_WARN);
+	}
+	if (rsrc->compressed_size > (4 * 1024 * 1024)) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+		    "Mac metadata is too large: %jd > 4M bytes",
+		    (intmax_t)rsrc->compressed_size);
+		return (ARCHIVE_WARN);
+	}
+
+	metadata = malloc((size_t)rsrc->uncompressed_size);
+	if (metadata == NULL) {
+		archive_set_error(&a->archive, ENOMEM,
+		    "Can't allocate memory for Mac metadata");
+		return (ARCHIVE_FATAL);
+	}
+
+	if (offset < rsrc->local_header_offset)
+		__archive_read_consume(a, rsrc->local_header_offset - offset);
+	else if (offset != rsrc->local_header_offset) {
+		__archive_read_seek(a, rsrc->local_header_offset, SEEK_SET);
+	}
+
+	hsize = zip_get_local_file_header_size(a, 0);
+	__archive_read_consume(a, hsize);
+
+	remaining_bytes = (size_t)rsrc->compressed_size;
+	metadata_bytes = (size_t)rsrc->uncompressed_size;
+	mp = metadata;
+	eof = 0;
+	while (!eof && remaining_bytes) {
+		const unsigned char *p;
+		ssize_t bytes_avail;
+		size_t bytes_used;
+
+		p = __archive_read_ahead(a, 1, &bytes_avail);
+		if (p == NULL) {
+			archive_set_error(&a->archive,
+			    ARCHIVE_ERRNO_FILE_FORMAT,
+			    "Truncated ZIP file header");
+			ret = ARCHIVE_WARN;
+			goto exit_mac_metadata;
+		}
+		if ((size_t)bytes_avail > remaining_bytes)
+			bytes_avail = remaining_bytes;
+		switch(rsrc->compression) {
+		case 0:  /* No compression. */
+			if ((size_t)bytes_avail > metadata_bytes)
+				bytes_avail = metadata_bytes;
+			memcpy(mp, p, bytes_avail);
+			bytes_used = (size_t)bytes_avail;
+			metadata_bytes -= bytes_used;
+			mp += bytes_used;
+			if (metadata_bytes == 0)
+				eof = 1;
+			break;
+#ifdef HAVE_ZLIB_H
+		case 8: /* Deflate compression. */
+		{
+			int r;
+
+			ret = zip_deflate_init(a, zip);
+			if (ret != ARCHIVE_OK)
+				goto exit_mac_metadata;
+			zip->stream.next_in =
+			    (Bytef *)(uintptr_t)(const void *)p;
+			zip->stream.avail_in = (uInt)bytes_avail;
+			zip->stream.total_in = 0;
+			zip->stream.next_out = mp;
+			zip->stream.avail_out = (uInt)metadata_bytes;
+			zip->stream.total_out = 0;
+
+			r = inflate(&zip->stream, 0);
+			switch (r) {
+			case Z_OK:
+				break;
+			case Z_STREAM_END:
+				eof = 1;
+				break;
+			case Z_MEM_ERROR:
+				archive_set_error(&a->archive, ENOMEM,
+				    "Out of memory for ZIP decompression");
+				ret = ARCHIVE_FATAL;
+				goto exit_mac_metadata;
+			default:
+				archive_set_error(&a->archive,
+				    ARCHIVE_ERRNO_MISC,
+				    "ZIP decompression failed (%d)", r);
+				ret = ARCHIVE_FATAL;
+				goto exit_mac_metadata;
+			}
+			bytes_used = zip->stream.total_in;
+			metadata_bytes -= zip->stream.total_out;
+			mp += zip->stream.total_out;
+			break;
+		}
+#endif
+		default:
+			bytes_used = 0;
+			break;
+		}
+		__archive_read_consume(a, bytes_used);
+		remaining_bytes -= bytes_used;
+	}
+	archive_entry_copy_mac_metadata(entry, metadata,
+	    (size_t)rsrc->uncompressed_size - metadata_bytes);
+
+exit_mac_metadata:
+	__archive_read_seek(a, offset, SEEK_SET);
+	zip->decompress_init = 0;
+	free(metadata);
+	return (ret);
+}
+
+static int
+archive_read_format_zip_seekable_read_header(struct archive_read *a,
+	struct archive_entry *entry)
+{
+	struct zip *zip = (struct zip *)a->format->data;
+	struct zip_entry *rsrc;
+	int64_t offset;
+	int r, ret = ARCHIVE_OK;
+
+	/*
+	 * It should be sufficient to call archive_read_next_header() for
+	 * a reader to determine if an entry is encrypted or not. If the
+	 * encryption of an entry is only detectable when calling
+	 * archive_read_data(), so be it. We'll do the same check there
+	 * as well.
+	 */
+	if (zip->has_encrypted_entries ==
+			ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW)
+		zip->has_encrypted_entries = 0;
+
+	a->archive.archive_format = ARCHIVE_FORMAT_ZIP;
+	if (a->archive.archive_format_name == NULL)
+		a->archive.archive_format_name = "ZIP";
+
+	if (zip->zip_entries == NULL) {
+		r = slurp_central_directory(a, zip);
+		if (r != ARCHIVE_OK)
+			return r;
+		/* Get first entry whose local header offset is lower than
+		 * other entries in the archive file. */
+		zip->entry =
+		    (struct zip_entry *)ARCHIVE_RB_TREE_MIN(&zip->tree);
+	} else if (zip->entry != NULL) {
+		/* Get next entry in local header offset order. */
+		zip->entry = (struct zip_entry *)__archive_rb_tree_iterate(
+		    &zip->tree, &zip->entry->node, ARCHIVE_RB_DIR_RIGHT);
+	}
+
+	if (zip->entry == NULL)
+		return ARCHIVE_EOF;
+
+	if (zip->entry->rsrcname.s)
+		rsrc = (struct zip_entry *)__archive_rb_tree_find_node(
+		    &zip->tree_rsrc, zip->entry->rsrcname.s);
+	else
+		rsrc = NULL;
+
+	if (zip->cctx_valid)
+		archive_decrypto_aes_ctr_release(&zip->cctx);
+	if (zip->hctx_valid)
+		archive_hmac_sha1_cleanup(&zip->hctx);
+	zip->tctx_valid = zip->cctx_valid = zip->hctx_valid = 0;
+	__archive_read_reset_passphrase(a);
+
+	/* File entries are sorted by the header offset, we should mostly
+	 * use __archive_read_consume to advance a read point to avoid redundant
+	 * data reading.  */
+	offset = archive_filter_bytes(&a->archive, 0);
+	if (offset < zip->entry->local_header_offset)
+		__archive_read_consume(a,
+		    zip->entry->local_header_offset - offset);
+	else if (offset != zip->entry->local_header_offset) {
+		__archive_read_seek(a, zip->entry->local_header_offset,
+		    SEEK_SET);
+	}
+	zip->unconsumed = 0;
+	r = zip_read_local_file_header(a, entry, zip);
+	if (r != ARCHIVE_OK)
+		return r;
+	if (rsrc) {
+		int ret2 = zip_read_mac_metadata(a, entry, rsrc);
+		if (ret2 < ret)
+			ret = ret2;
+	}
+	return (ret);
+}
+
+/*
+ * We're going to seek for the next header anyway, so we don't
+ * need to bother doing anything here.
+ */
+static int
+archive_read_format_zip_read_data_skip_seekable(struct archive_read *a)
+{
+	struct zip *zip;
+	zip = (struct zip *)(a->format->data);
+
+	zip->unconsumed = 0;
+	return (ARCHIVE_OK);
+}
+
+int
+archive_read_support_format_zip_seekable(struct archive *_a)
+{
+	struct archive_read *a = (struct archive_read *)_a;
+	struct zip *zip;
+	int r;
+
+	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
+	    ARCHIVE_STATE_NEW, "archive_read_support_format_zip_seekable");
+
+	zip = (struct zip *)calloc(1, sizeof(*zip));
+	if (zip == NULL) {
+		archive_set_error(&a->archive, ENOMEM,
+		    "Can't allocate zip data");
+		return (ARCHIVE_FATAL);
+	}
+
+#ifdef HAVE_COPYFILE_H
+	/* Set this by default on Mac OS. */
+	zip->process_mac_extensions = 1;
+#endif
+
+	/*
+	 * Until enough data has been read, we cannot tell about
+	 * any encrypted entries yet.
+	 */
+	zip->has_encrypted_entries = ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW;
+	zip->crc32func = real_crc32;
+
+	r = __archive_read_register_format(a,
+	    zip,
+	    "zip",
+	    archive_read_format_zip_seekable_bid,
+	    archive_read_format_zip_options,
+	    archive_read_format_zip_seekable_read_header,
+	    archive_read_format_zip_read_data,
+	    archive_read_format_zip_read_data_skip_seekable,
+	    NULL,
+	    archive_read_format_zip_cleanup,
+	    archive_read_support_format_zip_capabilities_seekable,
+	    archive_read_format_zip_has_encrypted_entries);
+
+	if (r != ARCHIVE_OK)
+		free(zip);
+	return (ARCHIVE_OK);
+}
--- libarchive-3.3.3/libarchive/archive_write_set_format_iso9660.c
+++ libarchive-nenuzhnix/libarchive/archive_write_set_format_iso9660.c
@@ -7950,9 +7950,10 @@
 		zisofs->block_off += 4;
 
 		/* Initialize compression library for new block. */
-		if (zisofs->stream_valid)
-			r = inflateReset(&zisofs->stream);
-		else
+		if (zisofs->stream_valid) {
+			inflateReset(&zisofs->stream);
+			r = Z_OK;
+		} else
 			r = inflateInit(&zisofs->stream);
 		if (r != Z_OK) {
 			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
